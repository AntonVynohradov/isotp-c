{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ISO-TP C Implementation \u00b6 ISO-TP (ISO 15765-2) protocol implementation in C for CAN communication. This library implements ISO-TP frame fragmentation and reassembly and provides a simple interface for sending and receiving messages longer than 8 bytes. Key features \u00b6 Full ISO-TP support (Single, First, Consecutive, Flow Control) Configurable timing parameters and buffer sizes Minimal dependencies and easy integration in embedded systems Main-loop (polling) operation, no mandatory OS required Optional callbacks for TX and RX completion Intended use \u00b6 The library is intended for embedded systems and CAN applications where deterministic behavior, small memory footprint, and simple integration are required. Quick start \u00b6 Build (CMake) \u00b6 This project uses CMake presets. You can build with the default generator or use the provided presets for Debug, Release, and Unit Tests. Quick local build: cmake -B build cmake --build build Build with presets: cmake --preset \"ISO-TP[Debug]\" -B \"build/ISO-TP[Debug]\" cmake --build \"build/ISO-TP[Debug]\" cmake --preset \"ISO-TP[Release]\" -B \"build/ISO-TP[Release]\" cmake --build \"build/ISO-TP[Release]\" Unit tests (requires Google Test): cmake --preset \"ISO-TP[UnitTests]\" -B \"build/ISO-TP[UnitTests]\" cmake --build \"build/ISO-TP[UnitTests]\" ctest --test-dir \"build/ISO-TP[UnitTests]\" --output-on-failure Integration \u00b6 Add the header and configure user functions in isotp_user.h : #include \"isotp.h\" static uint8_t tx_buffer [ 4095 ]; static uint8_t rx_buffer [ 4095 ]; static IsoTpLink link ; isotp_init_link ( & link , 0x7E0 , tx_buffer , sizeof ( tx_buffer ), rx_buffer , sizeof ( rx_buffer )); In the application loop: isotp_on_can_message ( & link , can_data , can_len ); isotp_poll ( & link ); uint8_t payload [ 4095 ]; uint32_t payload_len = 0 ; if ( isotp_receive ( & link , payload , sizeof ( payload ), & payload_len ) == ISOTP_RET_OK ) { /* process payload */ } Core API \u00b6 Key public functions (see API Reference ): isotp_init_link() - link initialization isotp_destroy_link() - release link resources isotp_send() / isotp_send_with_id() - send ISO-TP messages isotp_on_can_message() - handle incoming CAN frames isotp_poll() - handle timeouts and send consecutive frames isotp_receive() - fetch reassembled payload Configuration \u00b6 Configuration is done statically via files in inc/ : inc/isotp_config.h - timing parameters, sizes, enable/disable options inc/isotp_user.h - user functions (CAN send, time, debug) inc/isotp_defines.h - protocol definitions and error codes More details in Configuration Guide . Usage model \u00b6 The library does not manage the CAN bus; it expects a CAN send function and delivery of received frames via isotp_on_can_message() . The isotp_poll() function must be called periodically in the main loop (or in a thread/RTOS) at an appropriate frequency. Examples \u00b6 The Linux SocketCAN example is in example/linux_socket/linux_socket.c . Tests \u00b6 Unit tests are located in the tests/ directory. Details are in the project documentation and the test files. To run unit tests locally (requires Google Test): cmake --preset \"ISO-TP[UnitTests]\" -B \"build/ISO-TP[UnitTests]\" cmake --build \"build/ISO-TP[UnitTests]\" ctest --test-dir \"build/ISO-TP[UnitTests]\" --output-on-failure Install Google Test on Ubuntu/Debian: sudo apt-get update sudo apt-get install -y libgtest-dev Limitations and notes \u00b6 The maximum payload length depends on configuration and buffers. Provide sufficiently large TX/RX buffers (typically 4095 bytes for full ISO-TP). For realtime systems, adjust timeouts and polling frequency. Documentation \u00b6 API Reference Configuration Guide Getting Started License \u00b6 Details in LICENSE .","title":"Home"},{"location":"#iso-tp-c-implementation","text":"ISO-TP (ISO 15765-2) protocol implementation in C for CAN communication. This library implements ISO-TP frame fragmentation and reassembly and provides a simple interface for sending and receiving messages longer than 8 bytes.","title":"ISO-TP C Implementation"},{"location":"#key-features","text":"Full ISO-TP support (Single, First, Consecutive, Flow Control) Configurable timing parameters and buffer sizes Minimal dependencies and easy integration in embedded systems Main-loop (polling) operation, no mandatory OS required Optional callbacks for TX and RX completion","title":"Key features"},{"location":"#intended-use","text":"The library is intended for embedded systems and CAN applications where deterministic behavior, small memory footprint, and simple integration are required.","title":"Intended use"},{"location":"#quick-start","text":"","title":"Quick start"},{"location":"#build-cmake","text":"This project uses CMake presets. You can build with the default generator or use the provided presets for Debug, Release, and Unit Tests. Quick local build: cmake -B build cmake --build build Build with presets: cmake --preset \"ISO-TP[Debug]\" -B \"build/ISO-TP[Debug]\" cmake --build \"build/ISO-TP[Debug]\" cmake --preset \"ISO-TP[Release]\" -B \"build/ISO-TP[Release]\" cmake --build \"build/ISO-TP[Release]\" Unit tests (requires Google Test): cmake --preset \"ISO-TP[UnitTests]\" -B \"build/ISO-TP[UnitTests]\" cmake --build \"build/ISO-TP[UnitTests]\" ctest --test-dir \"build/ISO-TP[UnitTests]\" --output-on-failure","title":"Build (CMake)"},{"location":"#integration","text":"Add the header and configure user functions in isotp_user.h : #include \"isotp.h\" static uint8_t tx_buffer [ 4095 ]; static uint8_t rx_buffer [ 4095 ]; static IsoTpLink link ; isotp_init_link ( & link , 0x7E0 , tx_buffer , sizeof ( tx_buffer ), rx_buffer , sizeof ( rx_buffer )); In the application loop: isotp_on_can_message ( & link , can_data , can_len ); isotp_poll ( & link ); uint8_t payload [ 4095 ]; uint32_t payload_len = 0 ; if ( isotp_receive ( & link , payload , sizeof ( payload ), & payload_len ) == ISOTP_RET_OK ) { /* process payload */ }","title":"Integration"},{"location":"#core-api","text":"Key public functions (see API Reference ): isotp_init_link() - link initialization isotp_destroy_link() - release link resources isotp_send() / isotp_send_with_id() - send ISO-TP messages isotp_on_can_message() - handle incoming CAN frames isotp_poll() - handle timeouts and send consecutive frames isotp_receive() - fetch reassembled payload","title":"Core API"},{"location":"#configuration","text":"Configuration is done statically via files in inc/ : inc/isotp_config.h - timing parameters, sizes, enable/disable options inc/isotp_user.h - user functions (CAN send, time, debug) inc/isotp_defines.h - protocol definitions and error codes More details in Configuration Guide .","title":"Configuration"},{"location":"#usage-model","text":"The library does not manage the CAN bus; it expects a CAN send function and delivery of received frames via isotp_on_can_message() . The isotp_poll() function must be called periodically in the main loop (or in a thread/RTOS) at an appropriate frequency.","title":"Usage model"},{"location":"#examples","text":"The Linux SocketCAN example is in example/linux_socket/linux_socket.c .","title":"Examples"},{"location":"#tests","text":"Unit tests are located in the tests/ directory. Details are in the project documentation and the test files. To run unit tests locally (requires Google Test): cmake --preset \"ISO-TP[UnitTests]\" -B \"build/ISO-TP[UnitTests]\" cmake --build \"build/ISO-TP[UnitTests]\" ctest --test-dir \"build/ISO-TP[UnitTests]\" --output-on-failure Install Google Test on Ubuntu/Debian: sudo apt-get update sudo apt-get install -y libgtest-dev","title":"Tests"},{"location":"#limitations-and-notes","text":"The maximum payload length depends on configuration and buffers. Provide sufficiently large TX/RX buffers (typically 4095 bytes for full ISO-TP). For realtime systems, adjust timeouts and polling frequency.","title":"Limitations and notes"},{"location":"#documentation","text":"API Reference Configuration Guide Getting Started","title":"Documentation"},{"location":"#license","text":"Details in LICENSE .","title":"License"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2019-2024 Li Shen & Co-Operators Copyright (c) 2024 Simon Cahill & Contributors. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"LICENSE"},{"location":"api/","text":"API Reference \u00b6 This API reference is generated from the source code with Doxygen and mirrors the public headers and their supporting modules. Main Components \u00b6 isotp.h - Public ISO-TP API: link lifecycle, send/receive, and polling. isotp_config.h - Build-time configuration parameters and feature toggles. isotp_user.h - User hooks for CAN transmit, timing, and debug output. isotp_defines.h - Internal protocol definitions, frame layouts, and enums. Tests \u00b6 isotp_test_support.h - Test utilities used by unit tests. Examples \u00b6 linux_socket.c - Linux SocketCAN example showing end-to-end usage. Modules and Functions \u00b6 Browse the modules overview for a grouped view of public interfaces, configuration, and user hooks. Each module page links to the relevant functions and data structures. Data Structures \u00b6 Core ISO-TP structures, such as the link state and frame types, are documented in the generated API pages referenced above. For more details on protocol behavior, see ISO 15765-2.","title":"API Reference"},{"location":"api/#api-reference","text":"This API reference is generated from the source code with Doxygen and mirrors the public headers and their supporting modules.","title":"API Reference"},{"location":"api/#main-components","text":"isotp.h - Public ISO-TP API: link lifecycle, send/receive, and polling. isotp_config.h - Build-time configuration parameters and feature toggles. isotp_user.h - User hooks for CAN transmit, timing, and debug output. isotp_defines.h - Internal protocol definitions, frame layouts, and enums.","title":"Main Components"},{"location":"api/#tests","text":"isotp_test_support.h - Test utilities used by unit tests.","title":"Tests"},{"location":"api/#examples","text":"linux_socket.c - Linux SocketCAN example showing end-to-end usage.","title":"Examples"},{"location":"api/#modules-and-functions","text":"Browse the modules overview for a grouped view of public interfaces, configuration, and user hooks. Each module page links to the relevant functions and data structures.","title":"Modules and Functions"},{"location":"api/#data-structures","text":"Core ISO-TP structures, such as the link state and frame types, are documented in the generated API pages referenced above. For more details on protocol behavior, see ISO 15765-2.","title":"Data Structures"},{"location":"configuration/","text":"Configuration Guide \u00b6 isotp_config.h \u00b6 The isotp_config.h file defines compile-time configuration options that control ISO-TP timing, limits, and optional features. These settings are applied at build time and affect both send and receive behavior for single- and multi-frame traffic. Key Configuration Options \u00b6 ISO_TP_DEFAULT_BLOCK_SIZE - Default receiver block size (BS). This limits how many consecutive frames can be sent before the receiver responds with Flow Control. ISO_TP_DEFAULT_ST_MIN_US - Default minimum separation time (ST_min) in microseconds between consecutive frames. ISO_TP_MAX_WFT_NUMBER - Maximum number of consecutive Flow Control Wait frames the receiver may send. ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US - Default response timeout (microseconds) while waiting for Flow Control during a multi-frame transfer. ISO_TP_FRAME_PADDING - Enable ISO-TP frame padding by default. ISO_TP_FRAME_PADDING_VALUE - Padding byte value used when padding is enabled. ISO_TP_USER_SEND_CAN_ARG - Adds an extra user argument to isotp_user_send_can() . ISO_TP_TRANSMIT_COMPLETE_CALLBACK - Enable transmission complete callback support. ISO_TP_RECEIVE_COMPLETE_CALLBACK - Enable receive complete callback support. User Callbacks \u00b6 Define user callbacks in isotp_user.h for: - CAN frame transmission - Timing source access (microsecond timebase) - Optional debug output - Optional transmit/receive completion hooks (when enabled) More Information \u00b6 See inc/isotp_config.h for detailed configuration parameters and inline documentation for each option.","title":"Configuration"},{"location":"configuration/#configuration-guide","text":"","title":"Configuration Guide"},{"location":"configuration/#isotp_configh","text":"The isotp_config.h file defines compile-time configuration options that control ISO-TP timing, limits, and optional features. These settings are applied at build time and affect both send and receive behavior for single- and multi-frame traffic.","title":"isotp_config.h"},{"location":"configuration/#key-configuration-options","text":"ISO_TP_DEFAULT_BLOCK_SIZE - Default receiver block size (BS). This limits how many consecutive frames can be sent before the receiver responds with Flow Control. ISO_TP_DEFAULT_ST_MIN_US - Default minimum separation time (ST_min) in microseconds between consecutive frames. ISO_TP_MAX_WFT_NUMBER - Maximum number of consecutive Flow Control Wait frames the receiver may send. ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US - Default response timeout (microseconds) while waiting for Flow Control during a multi-frame transfer. ISO_TP_FRAME_PADDING - Enable ISO-TP frame padding by default. ISO_TP_FRAME_PADDING_VALUE - Padding byte value used when padding is enabled. ISO_TP_USER_SEND_CAN_ARG - Adds an extra user argument to isotp_user_send_can() . ISO_TP_TRANSMIT_COMPLETE_CALLBACK - Enable transmission complete callback support. ISO_TP_RECEIVE_COMPLETE_CALLBACK - Enable receive complete callback support.","title":"Key Configuration Options"},{"location":"configuration/#user-callbacks","text":"Define user callbacks in isotp_user.h for: - CAN frame transmission - Timing source access (microsecond timebase) - Optional debug output - Optional transmit/receive completion hooks (when enabled)","title":"User Callbacks"},{"location":"configuration/#more-information","text":"See inc/isotp_config.h for detailed configuration parameters and inline documentation for each option.","title":"More Information"},{"location":"guide/","text":"Getting Started \u00b6 This guide shows how to initialize an ISO-TP link, send and receive payloads, and integrate the polling model into your main loop. For full definitions and return codes, see the API Reference . Initialization \u00b6 Create a link and provide dedicated TX/RX buffers. The link tracks protocol state and owns the buffers you pass in. #include \"isotp.h\" static uint8_t tx_buffer [ 4095 ]; static uint8_t rx_buffer [ 4095 ]; static IsoTpLink link ; isotp_init_link ( & link , 0x7E0 , tx_buffer , sizeof ( tx_buffer ), rx_buffer , sizeof ( rx_buffer )); The sendid you pass to isotp_init_link() is used for transmissions. Make sure the receiver expects this ID. Sending Data \u00b6 Single-frame payloads are sent immediately. Multi-frame payloads are queued and sent by isotp_poll() . uint8_t data [] = { 0x01 , 0x02 , 0x03 }; int ret = isotp_send ( & link , data , sizeof ( data )); if ( ret == ISOTP_RET_OK || ret == ISOTP_RET_INPROGRESS ) { /* OK: in progress or already sent */ } Use isotp_send_with_id() for functional addressing or when you need to send with a different arbitration ID. Receiving Data \u00b6 Deliver each incoming CAN frame to the ISO-TP handler and poll periodically. When a complete payload is available, call isotp_receive() to copy it out. isotp_on_can_message ( & link , can_data , can_len ); isotp_poll ( & link ); uint8_t payload [ 4095 ]; uint32_t payload_len = 0 ; if ( isotp_receive ( & link , payload , sizeof ( payload ), & payload_len ) == ISOTP_RET_OK ) { /* process payload */ } Polling Model \u00b6 ISO-TP timing is managed by isotp_poll() . Call it from the main loop or a dedicated thread with a consistent period that matches your timing needs. The poll function drives consecutive frame sending and timeout handling. User Hooks \u00b6 Implement user hooks in isotp_user.h for: CAN frame transmission (required) Microsecond time source (required) Optional debug output Optional TX/RX completion callbacks (when enabled in configuration) Example Flow (Linux SocketCAN) \u00b6 The Linux example creates a PF_CAN / SOCK_RAW socket, binds it to a CAN interface, and then runs the ISO-TP loop: Initialize the SocketCAN interface and bind the socket. Call isotp_init_link() with buffers and the transmit ID. In a loop, read CAN frames, pass them to isotp_on_can_message() , and call isotp_poll() . When isotp_receive() returns ISOTP_RET_OK , the payload is complete. See the Linux SocketCAN example for a full working reference: example/linux_socket/linux_socket.c . Configuration \u00b6 See Configuration Guide for detailed configuration options. Error Handling \u00b6 The library returns status codes for common conditions: ISOTP_RET_OK - Success ISOTP_RET_INPROGRESS - Multi-frame transfer in progress ISOTP_RET_OVERFLOW - Payload larger than available buffer ISOTP_RET_NO_DATA - No complete payload available yet For the full list and detailed meanings, refer to the API Reference .","title":"Getting Started"},{"location":"guide/#getting-started","text":"This guide shows how to initialize an ISO-TP link, send and receive payloads, and integrate the polling model into your main loop. For full definitions and return codes, see the API Reference .","title":"Getting Started"},{"location":"guide/#initialization","text":"Create a link and provide dedicated TX/RX buffers. The link tracks protocol state and owns the buffers you pass in. #include \"isotp.h\" static uint8_t tx_buffer [ 4095 ]; static uint8_t rx_buffer [ 4095 ]; static IsoTpLink link ; isotp_init_link ( & link , 0x7E0 , tx_buffer , sizeof ( tx_buffer ), rx_buffer , sizeof ( rx_buffer )); The sendid you pass to isotp_init_link() is used for transmissions. Make sure the receiver expects this ID.","title":"Initialization"},{"location":"guide/#sending-data","text":"Single-frame payloads are sent immediately. Multi-frame payloads are queued and sent by isotp_poll() . uint8_t data [] = { 0x01 , 0x02 , 0x03 }; int ret = isotp_send ( & link , data , sizeof ( data )); if ( ret == ISOTP_RET_OK || ret == ISOTP_RET_INPROGRESS ) { /* OK: in progress or already sent */ } Use isotp_send_with_id() for functional addressing or when you need to send with a different arbitration ID.","title":"Sending Data"},{"location":"guide/#receiving-data","text":"Deliver each incoming CAN frame to the ISO-TP handler and poll periodically. When a complete payload is available, call isotp_receive() to copy it out. isotp_on_can_message ( & link , can_data , can_len ); isotp_poll ( & link ); uint8_t payload [ 4095 ]; uint32_t payload_len = 0 ; if ( isotp_receive ( & link , payload , sizeof ( payload ), & payload_len ) == ISOTP_RET_OK ) { /* process payload */ }","title":"Receiving Data"},{"location":"guide/#polling-model","text":"ISO-TP timing is managed by isotp_poll() . Call it from the main loop or a dedicated thread with a consistent period that matches your timing needs. The poll function drives consecutive frame sending and timeout handling.","title":"Polling Model"},{"location":"guide/#user-hooks","text":"Implement user hooks in isotp_user.h for: CAN frame transmission (required) Microsecond time source (required) Optional debug output Optional TX/RX completion callbacks (when enabled in configuration)","title":"User Hooks"},{"location":"guide/#example-flow-linux-socketcan","text":"The Linux example creates a PF_CAN / SOCK_RAW socket, binds it to a CAN interface, and then runs the ISO-TP loop: Initialize the SocketCAN interface and bind the socket. Call isotp_init_link() with buffers and the transmit ID. In a loop, read CAN frames, pass them to isotp_on_can_message() , and call isotp_poll() . When isotp_receive() returns ISOTP_RET_OK , the payload is complete. See the Linux SocketCAN example for a full working reference: example/linux_socket/linux_socket.c .","title":"Example Flow (Linux SocketCAN)"},{"location":"guide/#configuration","text":"See Configuration Guide for detailed configuration options.","title":"Configuration"},{"location":"guide/#error-handling","text":"The library returns status codes for common conditions: ISOTP_RET_OK - Success ISOTP_RET_INPROGRESS - Multi-frame transfer in progress ISOTP_RET_OVERFLOW - Payload larger than available buffer ISOTP_RET_NO_DATA - No complete payload available yet For the full list and detailed meanings, refer to the API Reference .","title":"Error Handling"},{"location":"examples/linux_socket/","text":"Linux socket \u00b6 How to use \u00b6 This example shows how to run ISO-TP-C on Linux SocketCAN. Below are the build steps and a short explanation of what the program does. Requirements \u00b6 Linux with SocketCAN enabled. A configured CAN interface (default: slcan0 ). C99 compiler and CMake >= 3.20. Example configuration \u00b6 In example/linux_socket/linux_socket.c the key parameters are defined: _CAN_INTERFACE - CAN interface name (e.g., can0 , slcan0 ). _ISOTP_CAN_ID - CAN ID used for ISO-TP transmission. _ISOTP_BUFSIZE - TX/RX buffer size (>= 4095 for full ISO-TP support). Build \u00b6 From the example directory: cd example/linux_socket cmake -G \"Unix Makefiles\" -B build cmake --build build Run \u00b6 After building, run the application: ./build/LinuxSocketExample The program listens on CAN, assembles ISO-TP frames, and prints the received payload. What the program does \u00b6 Creates a PF_CAN / SOCK_RAW socket and binds it to the CAN interface. Initializes the ISO-TP link via isotp_init_link() . Receives CAN frames in a loop, passes them to isotp_on_can_message() , and calls isotp_poll() . When receive_status is ISOTP_RECEIVE_STATUS_FULL , reads data with isotp_receive() and prints it as hex. Notes \u00b6 The CAN interface and CAN ID must match the configuration on the other side. The example uses extended identifiers ( CAN_EFF_FLAG ).","title":"Linux SocketCAN"},{"location":"examples/linux_socket/#linux-socket","text":"","title":"Linux socket"},{"location":"examples/linux_socket/#how-to-use","text":"This example shows how to run ISO-TP-C on Linux SocketCAN. Below are the build steps and a short explanation of what the program does.","title":"How to use"},{"location":"examples/linux_socket/#requirements","text":"Linux with SocketCAN enabled. A configured CAN interface (default: slcan0 ). C99 compiler and CMake >= 3.20.","title":"Requirements"},{"location":"examples/linux_socket/#example-configuration","text":"In example/linux_socket/linux_socket.c the key parameters are defined: _CAN_INTERFACE - CAN interface name (e.g., can0 , slcan0 ). _ISOTP_CAN_ID - CAN ID used for ISO-TP transmission. _ISOTP_BUFSIZE - TX/RX buffer size (>= 4095 for full ISO-TP support).","title":"Example configuration"},{"location":"examples/linux_socket/#build","text":"From the example directory: cd example/linux_socket cmake -G \"Unix Makefiles\" -B build cmake --build build","title":"Build"},{"location":"examples/linux_socket/#run","text":"After building, run the application: ./build/LinuxSocketExample The program listens on CAN, assembles ISO-TP frames, and prints the received payload.","title":"Run"},{"location":"examples/linux_socket/#what-the-program-does","text":"Creates a PF_CAN / SOCK_RAW socket and binds it to the CAN interface. Initializes the ISO-TP link via isotp_init_link() . Receives CAN frames in a loop, passes them to isotp_on_can_message() , and calls isotp_poll() . When receive_status is ISOTP_RECEIVE_STATUS_FULL , reads data with isotp_receive() and prints it as hex.","title":"What the program does"},{"location":"examples/linux_socket/#notes","text":"The CAN interface and CAN ID must match the configuration on the other side. The example uses extended identifiers ( CAN_EFF_FLAG ).","title":"Notes"},{"location":"docs/annotated/","text":"Class List \u00b6 Here are the classes, structs, unions and interfaces with brief descriptions: struct IsoTpCanMessage struct IsoTpConsecutiveFrame Consecutive frame layout. struct IsoTpDataArray struct IsoTpFirstFrameShort First frame (short) layout. struct IsoTpFlowControl Flow control frame layout. struct IsoTpLink Link state for a single ISO-TP connection. struct IsoTpPciType CAN frame definitions. struct IsoTpSingleFrame Single frame layout. struct MockCanState Mock CAN state structure for testing purposes.","title":"Class List"},{"location":"docs/annotated/#class-list","text":"Here are the classes, structs, unions and interfaces with brief descriptions: struct IsoTpCanMessage struct IsoTpConsecutiveFrame Consecutive frame layout. struct IsoTpDataArray struct IsoTpFirstFrameShort First frame (short) layout. struct IsoTpFlowControl Flow control frame layout. struct IsoTpLink Link state for a single ISO-TP connection. struct IsoTpPciType CAN frame definitions. struct IsoTpSingleFrame Single frame layout. struct MockCanState Mock CAN state structure for testing purposes.","title":"Class List"},{"location":"docs/files/","text":"File List \u00b6 Here is a list of all files with brief descriptions: dir example dir linux_socket file linux_socket.c dir inc file isotp_config.h ISO-TP configuration parameters and feature toggles. file isotp_defines.h Internal protocol definitions and type structures for ISO-TP. file isotp_user.h User callback interfaces and platform abstraction layer. file isotp.h Core ISO-TP protocol API with link management and message handling. dir src file isotp.c dir tests file isotp_test_support.h","title":"File List"},{"location":"docs/files/#file-list","text":"Here is a list of all files with brief descriptions: dir example dir linux_socket file linux_socket.c dir inc file isotp_config.h ISO-TP configuration parameters and feature toggles. file isotp_defines.h Internal protocol definitions and type structures for ISO-TP. file isotp_user.h User callback interfaces and platform abstraction layer. file isotp.h Core ISO-TP protocol API with link management and message handling. dir src file isotp.c dir tests file isotp_test_support.h","title":"File List"},{"location":"docs/structIsoTpCanMessage/","text":"Struct IsoTpCanMessage \u00b6 ClassList > IsoTpCanMessage Public Attributes \u00b6 Type Name union IsoTpCanMessage as IsoTpPciType common IsoTpConsecutiveFrame consecutive_frame IsoTpDataArray data_array IsoTpFirstFrameLong first_frame_long IsoTpFirstFrameShort first_frame_short IsoTpFlowControl flow_control IsoTpSingleFrame single_frame Public Attributes Documentation \u00b6 variable as \u00b6 union IsoTpCanMessage IsoTpCanMessage :: as ; variable common \u00b6 IsoTpPciType IsoTpCanMessage :: common ; variable consecutive_frame \u00b6 IsoTpConsecutiveFrame IsoTpCanMessage :: consecutive_frame ; variable data_array \u00b6 IsoTpDataArray IsoTpCanMessage :: data_array ; variable first_frame_long \u00b6 IsoTpFirstFrameLong IsoTpCanMessage :: first_frame_long ; variable first_frame_short \u00b6 IsoTpFirstFrameShort IsoTpCanMessage :: first_frame_short ; variable flow_control \u00b6 IsoTpFlowControl IsoTpCanMessage :: flow_control ; variable single_frame \u00b6 IsoTpSingleFrame IsoTpCanMessage :: single_frame ; The documentation for this class was generated from the following file inc/isotp_defines.h","title":"Struct IsoTpCanMessage"},{"location":"docs/structIsoTpCanMessage/#struct-isotpcanmessage","text":"ClassList > IsoTpCanMessage","title":"Struct IsoTpCanMessage"},{"location":"docs/structIsoTpCanMessage/#public-attributes","text":"Type Name union IsoTpCanMessage as IsoTpPciType common IsoTpConsecutiveFrame consecutive_frame IsoTpDataArray data_array IsoTpFirstFrameLong first_frame_long IsoTpFirstFrameShort first_frame_short IsoTpFlowControl flow_control IsoTpSingleFrame single_frame","title":"Public Attributes"},{"location":"docs/structIsoTpCanMessage/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/structIsoTpCanMessage/#variable-as","text":"union IsoTpCanMessage IsoTpCanMessage :: as ;","title":"variable as"},{"location":"docs/structIsoTpCanMessage/#variable-common","text":"IsoTpPciType IsoTpCanMessage :: common ;","title":"variable common"},{"location":"docs/structIsoTpCanMessage/#variable-consecutive_frame","text":"IsoTpConsecutiveFrame IsoTpCanMessage :: consecutive_frame ;","title":"variable consecutive_frame"},{"location":"docs/structIsoTpCanMessage/#variable-data_array","text":"IsoTpDataArray IsoTpCanMessage :: data_array ;","title":"variable data_array"},{"location":"docs/structIsoTpCanMessage/#variable-first_frame_long","text":"IsoTpFirstFrameLong IsoTpCanMessage :: first_frame_long ;","title":"variable first_frame_long"},{"location":"docs/structIsoTpCanMessage/#variable-first_frame_short","text":"IsoTpFirstFrameShort IsoTpCanMessage :: first_frame_short ;","title":"variable first_frame_short"},{"location":"docs/structIsoTpCanMessage/#variable-flow_control","text":"IsoTpFlowControl IsoTpCanMessage :: flow_control ;","title":"variable flow_control"},{"location":"docs/structIsoTpCanMessage/#variable-single_frame","text":"IsoTpSingleFrame IsoTpCanMessage :: single_frame ; The documentation for this class was generated from the following file inc/isotp_defines.h","title":"variable single_frame"},{"location":"docs/structIsoTpConsecutiveFrame/","text":"Struct IsoTpConsecutiveFrame \u00b6 ClassList > IsoTpConsecutiveFrame Consecutive frame layout. More... #include <isotp_defines.h> Public Attributes \u00b6 Type Name uint8_t SN uint8_t data uint8_t type Detailed Description \u00b6 +-------------------------+-----+ | byte # 0 | ... | +-------------------------+-----+ | nibble # 0 | nibble # 1 | ... | +-------------+-----------+ ... + | PCIType = 0 | SN | ... | +-------------+-----------+-----+ Public Attributes Documentation \u00b6 variable SN \u00b6 uint8_t IsoTpConsecutiveFrame :: SN ; Sequence number. variable data \u00b6 uint8_t IsoTpConsecutiveFrame :: data [ 7 ]; Payload bytes. variable type \u00b6 uint8_t IsoTpConsecutiveFrame :: type ; PCI type. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"Struct IsoTpConsecutiveFrame"},{"location":"docs/structIsoTpConsecutiveFrame/#struct-isotpconsecutiveframe","text":"ClassList > IsoTpConsecutiveFrame Consecutive frame layout. More... #include <isotp_defines.h>","title":"Struct IsoTpConsecutiveFrame"},{"location":"docs/structIsoTpConsecutiveFrame/#public-attributes","text":"Type Name uint8_t SN uint8_t data uint8_t type","title":"Public Attributes"},{"location":"docs/structIsoTpConsecutiveFrame/#detailed-description","text":"+-------------------------+-----+ | byte # 0 | ... | +-------------------------+-----+ | nibble # 0 | nibble # 1 | ... | +-------------+-----------+ ... + | PCIType = 0 | SN | ... | +-------------+-----------+-----+","title":"Detailed Description"},{"location":"docs/structIsoTpConsecutiveFrame/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/structIsoTpConsecutiveFrame/#variable-sn","text":"uint8_t IsoTpConsecutiveFrame :: SN ; Sequence number.","title":"variable SN"},{"location":"docs/structIsoTpConsecutiveFrame/#variable-data","text":"uint8_t IsoTpConsecutiveFrame :: data [ 7 ]; Payload bytes.","title":"variable data"},{"location":"docs/structIsoTpConsecutiveFrame/#variable-type","text":"uint8_t IsoTpConsecutiveFrame :: type ; PCI type. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"variable type"},{"location":"docs/structIsoTpDataArray/","text":"Struct IsoTpDataArray \u00b6 ClassList > IsoTpDataArray Public Attributes \u00b6 Type Name uint8_t ptr Public Attributes Documentation \u00b6 variable ptr \u00b6 uint8_t IsoTpDataArray :: ptr [ 8 ]; The documentation for this class was generated from the following file inc/isotp_defines.h","title":"Struct IsoTpDataArray"},{"location":"docs/structIsoTpDataArray/#struct-isotpdataarray","text":"ClassList > IsoTpDataArray","title":"Struct IsoTpDataArray"},{"location":"docs/structIsoTpDataArray/#public-attributes","text":"Type Name uint8_t ptr","title":"Public Attributes"},{"location":"docs/structIsoTpDataArray/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/structIsoTpDataArray/#variable-ptr","text":"uint8_t IsoTpDataArray :: ptr [ 8 ]; The documentation for this class was generated from the following file inc/isotp_defines.h","title":"variable ptr"},{"location":"docs/structIsoTpFirstFrameShort/","text":"Struct IsoTpFirstFrameShort \u00b6 ClassList > IsoTpFirstFrameShort First frame (short) layout. More... #include <isotp_defines.h> Public Attributes \u00b6 Type Name uint8_t FF_DL_high uint8_t FF_DL_low uint8_t data uint8_t type Detailed Description \u00b6 +-------------------------+-----------------------+-----+ | byte # 0 | byte # 1 | ... | +-------------------------+-----------+-----------+-----+ | nibble # 0 | nibble # 1 | nibble # 2 | nibble # 3 | ... | +-------------+-----------+-----------+-----------+-----+ | PCIType = 1 | FF_DL | ... | +-------------+-----------+-----------------------+-----+ Public Attributes Documentation \u00b6 variable FF_DL_high \u00b6 uint8_t IsoTpFirstFrameShort :: FF_DL_high ; First-frame data length (high nibble). variable FF_DL_low \u00b6 uint8_t IsoTpFirstFrameShort :: FF_DL_low ; First-frame data length (low byte). variable data \u00b6 uint8_t IsoTpFirstFrameShort :: data [ 6 ]; Payload bytes. variable type \u00b6 uint8_t IsoTpFirstFrameShort :: type ; PCI type. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"Struct IsoTpFirstFrameShort"},{"location":"docs/structIsoTpFirstFrameShort/#struct-isotpfirstframeshort","text":"ClassList > IsoTpFirstFrameShort First frame (short) layout. More... #include <isotp_defines.h>","title":"Struct IsoTpFirstFrameShort"},{"location":"docs/structIsoTpFirstFrameShort/#public-attributes","text":"Type Name uint8_t FF_DL_high uint8_t FF_DL_low uint8_t data uint8_t type","title":"Public Attributes"},{"location":"docs/structIsoTpFirstFrameShort/#detailed-description","text":"+-------------------------+-----------------------+-----+ | byte # 0 | byte # 1 | ... | +-------------------------+-----------+-----------+-----+ | nibble # 0 | nibble # 1 | nibble # 2 | nibble # 3 | ... | +-------------+-----------+-----------+-----------+-----+ | PCIType = 1 | FF_DL | ... | +-------------+-----------+-----------------------+-----+","title":"Detailed Description"},{"location":"docs/structIsoTpFirstFrameShort/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/structIsoTpFirstFrameShort/#variable-ff_dl_high","text":"uint8_t IsoTpFirstFrameShort :: FF_DL_high ; First-frame data length (high nibble).","title":"variable FF_DL_high"},{"location":"docs/structIsoTpFirstFrameShort/#variable-ff_dl_low","text":"uint8_t IsoTpFirstFrameShort :: FF_DL_low ; First-frame data length (low byte).","title":"variable FF_DL_low"},{"location":"docs/structIsoTpFirstFrameShort/#variable-data","text":"uint8_t IsoTpFirstFrameShort :: data [ 6 ]; Payload bytes.","title":"variable data"},{"location":"docs/structIsoTpFirstFrameShort/#variable-type","text":"uint8_t IsoTpFirstFrameShort :: type ; PCI type. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"variable type"},{"location":"docs/structIsoTpFlowControl/","text":"Struct IsoTpFlowControl \u00b6 ClassList > IsoTpFlowControl Flow control frame layout. More... #include <isotp_defines.h> Public Attributes \u00b6 Type Name uint8_t BS uint8_t FS uint8_t STmin uint8_t reserve uint8_t type Detailed Description \u00b6 +-------------------------+-----------------------+-----------------------+-----+ | byte # 0 | byte # 1 | byte # 2 | ... | +-------------------------+-----------+-----------+-----------+-----------+-----+ | nibble # 0 | nibble # 1 | nibble # 2 | nibble # 3 | nibble # 4 | nibble # 5 | ... | +-------------+-----------+-----------+-----------+-----------+-----------+-----+ | PCIType = 1 | FS | BS | STmin | ... | +-------------+-----------+-----------------------+-----------------------+-----+ Public Attributes Documentation \u00b6 variable BS \u00b6 uint8_t IsoTpFlowControl :: BS ; Block size. variable FS \u00b6 uint8_t IsoTpFlowControl :: FS ; Flow status. variable STmin \u00b6 uint8_t IsoTpFlowControl :: STmin ; Minimum separation time. variable reserve \u00b6 uint8_t IsoTpFlowControl :: reserve [ 5 ]; Reserved. variable type \u00b6 uint8_t IsoTpFlowControl :: type ; PCI type. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"Struct IsoTpFlowControl"},{"location":"docs/structIsoTpFlowControl/#struct-isotpflowcontrol","text":"ClassList > IsoTpFlowControl Flow control frame layout. More... #include <isotp_defines.h>","title":"Struct IsoTpFlowControl"},{"location":"docs/structIsoTpFlowControl/#public-attributes","text":"Type Name uint8_t BS uint8_t FS uint8_t STmin uint8_t reserve uint8_t type","title":"Public Attributes"},{"location":"docs/structIsoTpFlowControl/#detailed-description","text":"+-------------------------+-----------------------+-----------------------+-----+ | byte # 0 | byte # 1 | byte # 2 | ... | +-------------------------+-----------+-----------+-----------+-----------+-----+ | nibble # 0 | nibble # 1 | nibble # 2 | nibble # 3 | nibble # 4 | nibble # 5 | ... | +-------------+-----------+-----------+-----------+-----------+-----------+-----+ | PCIType = 1 | FS | BS | STmin | ... | +-------------+-----------+-----------------------+-----------------------+-----+","title":"Detailed Description"},{"location":"docs/structIsoTpFlowControl/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/structIsoTpFlowControl/#variable-bs","text":"uint8_t IsoTpFlowControl :: BS ; Block size.","title":"variable BS"},{"location":"docs/structIsoTpFlowControl/#variable-fs","text":"uint8_t IsoTpFlowControl :: FS ; Flow status.","title":"variable FS"},{"location":"docs/structIsoTpFlowControl/#variable-stmin","text":"uint8_t IsoTpFlowControl :: STmin ; Minimum separation time.","title":"variable STmin"},{"location":"docs/structIsoTpFlowControl/#variable-reserve","text":"uint8_t IsoTpFlowControl :: reserve [ 5 ]; Reserved.","title":"variable reserve"},{"location":"docs/structIsoTpFlowControl/#variable-type","text":"uint8_t IsoTpFlowControl :: type ; PCI type. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"variable type"},{"location":"docs/structIsoTpPciType/","text":"Struct IsoTpPciType \u00b6 ClassList > IsoTpPciType CAN frame definitions. #include <isotp_defines.h> Public Attributes \u00b6 Type Name uint8_t reserve_1 uint8_t reserve_2 uint8_t type Public Attributes Documentation \u00b6 variable reserve_1 \u00b6 uint8_t IsoTpPciType :: reserve_1 ; Reserved. variable reserve_2 \u00b6 uint8_t IsoTpPciType :: reserve_2 [ 7 ]; Reserved. variable type \u00b6 uint8_t IsoTpPciType :: type ; PCI type. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"Struct IsoTpPciType"},{"location":"docs/structIsoTpPciType/#struct-isotppcitype","text":"ClassList > IsoTpPciType CAN frame definitions. #include <isotp_defines.h>","title":"Struct IsoTpPciType"},{"location":"docs/structIsoTpPciType/#public-attributes","text":"Type Name uint8_t reserve_1 uint8_t reserve_2 uint8_t type","title":"Public Attributes"},{"location":"docs/structIsoTpPciType/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/structIsoTpPciType/#variable-reserve_1","text":"uint8_t IsoTpPciType :: reserve_1 ; Reserved.","title":"variable reserve_1"},{"location":"docs/structIsoTpPciType/#variable-reserve_2","text":"uint8_t IsoTpPciType :: reserve_2 [ 7 ]; Reserved.","title":"variable reserve_2"},{"location":"docs/structIsoTpPciType/#variable-type","text":"uint8_t IsoTpPciType :: type ; PCI type. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"variable type"},{"location":"docs/structIsoTpSingleFrame/","text":"Struct IsoTpSingleFrame \u00b6 ClassList > IsoTpSingleFrame Single frame layout. More... #include <isotp_defines.h> Public Attributes \u00b6 Type Name uint8_t SF_DL uint8_t data uint8_t type Detailed Description \u00b6 +-------------------------+-----+ | byte # 0 | ... | +-------------------------+-----+ | nibble # 0 | nibble # 1 | ... | +-------------+-----------+ ... + | PCIType = 0 | SF_DL | ... | +-------------+-----------+-----+ Public Attributes Documentation \u00b6 variable SF_DL \u00b6 uint8_t IsoTpSingleFrame :: SF_DL ; Single-frame data length. variable data \u00b6 uint8_t IsoTpSingleFrame :: data [ 7 ]; Payload bytes. variable type \u00b6 uint8_t IsoTpSingleFrame :: type ; PCI type. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"Struct IsoTpSingleFrame"},{"location":"docs/structIsoTpSingleFrame/#struct-isotpsingleframe","text":"ClassList > IsoTpSingleFrame Single frame layout. More... #include <isotp_defines.h>","title":"Struct IsoTpSingleFrame"},{"location":"docs/structIsoTpSingleFrame/#public-attributes","text":"Type Name uint8_t SF_DL uint8_t data uint8_t type","title":"Public Attributes"},{"location":"docs/structIsoTpSingleFrame/#detailed-description","text":"+-------------------------+-----+ | byte # 0 | ... | +-------------------------+-----+ | nibble # 0 | nibble # 1 | ... | +-------------+-----------+ ... + | PCIType = 0 | SF_DL | ... | +-------------+-----------+-----+","title":"Detailed Description"},{"location":"docs/structIsoTpSingleFrame/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/structIsoTpSingleFrame/#variable-sf_dl","text":"uint8_t IsoTpSingleFrame :: SF_DL ; Single-frame data length.","title":"variable SF_DL"},{"location":"docs/structIsoTpSingleFrame/#variable-data","text":"uint8_t IsoTpSingleFrame :: data [ 7 ]; Payload bytes.","title":"variable data"},{"location":"docs/structIsoTpSingleFrame/#variable-type","text":"uint8_t IsoTpSingleFrame :: type ; PCI type. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"variable type"},{"location":"docs/structMockCanState/","text":"Struct MockCanState \u00b6 ClassList > MockCanState Mock CAN state structure for testing purposes. #include <isotp_test_support.h> Public Attributes \u00b6 Type Name int call_count uint8_t last_data uint32_t last_id uint8_t last_size int return_value Public Attributes Documentation \u00b6 variable call_count \u00b6 int MockCanState :: call_count ; variable last_data \u00b6 uint8_t MockCanState :: last_data [ 8 ]; variable last_id \u00b6 uint32_t MockCanState :: last_id ; variable last_size \u00b6 uint8_t MockCanState :: last_size ; variable return_value \u00b6 int MockCanState :: return_value ; The documentation for this class was generated from the following file tests/isotp_test_support.h","title":"Struct MockCanState"},{"location":"docs/structMockCanState/#struct-mockcanstate","text":"ClassList > MockCanState Mock CAN state structure for testing purposes. #include <isotp_test_support.h>","title":"Struct MockCanState"},{"location":"docs/structMockCanState/#public-attributes","text":"Type Name int call_count uint8_t last_data uint32_t last_id uint8_t last_size int return_value","title":"Public Attributes"},{"location":"docs/structMockCanState/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/structMockCanState/#variable-call_count","text":"int MockCanState :: call_count ;","title":"variable call_count"},{"location":"docs/structMockCanState/#variable-last_data","text":"uint8_t MockCanState :: last_data [ 8 ];","title":"variable last_data"},{"location":"docs/structMockCanState/#variable-last_id","text":"uint32_t MockCanState :: last_id ;","title":"variable last_id"},{"location":"docs/structMockCanState/#variable-last_size","text":"uint8_t MockCanState :: last_size ;","title":"variable last_size"},{"location":"docs/structMockCanState/#variable-return_value","text":"int MockCanState :: return_value ; The documentation for this class was generated from the following file tests/isotp_test_support.h","title":"variable return_value"},{"location":"docs/group__isotp/","text":"Group isotp \u00b6 Modules > isotp Public API for ISO-TP link management and message handling. More... Modules \u00b6 Type Name module Configuration Build-time configuration for ISO-TP. module Protocol definitions Internal protocol definitions and type structures. module User hooks User-implemented callbacks and platform hooks. Classes \u00b6 Type Name struct IsoTpLink Link state for a single ISO-TP connection. Public Types \u00b6 Type Name typedef struct IsoTpLink IsoTpLink Link state for a single ISO-TP connection. Public Functions \u00b6 Type Name void isotp_destroy_link ( IsoTpLink * link) Destroys the ISO-TP link and releases associated resources. void isotp_init_link ( IsoTpLink * link, uint32_t sendid, uint8_t * sendbuf, uint32_t sendbufsize, uint8_t * recvbuf, uint32_t recvbufsize) Initialises the ISO-TP library. void isotp_on_can_message ( IsoTpLink * link, const uint8_t * data, uint8_t len) Handles incoming CAN messages. Determines whether an incoming message is a valid ISO-TP frame or not and handles it accordingly. void isotp_poll ( IsoTpLink * link) Polling function; call this function periodically to handle timeouts, send consecutive frames, etc. int isotp_receive ( IsoTpLink * link, uint8_t * payload, const uint32_t payload_size, uint32_t * out_size) Receives and parses the received data and copies the parsed data into the internal buffer. int isotp_send ( IsoTpLink * link, const uint8_t payload, uint32_t size) Sends ISO-TP frames via CAN, using the ID set in the initialising function. int isotp_send_with_id ( IsoTpLink * link, uint32_t id, const uint8_t payload, uint32_t size) See isotp_send , with the exception that this function is used only for functional addressing. Detailed Description \u00b6 This module groups the public interface and its supporting submodules: Configuration , Protocol definitions , and User hooks . This group defines the public interface for initializing links, sending and receiving messages, handling incoming CAN frames, and polling the protocol state machine. It also exposes optional callback registration when enabled in configuration. ** ** Link lifecycle: isotp_init_link , isotp_destroy_link . Message flow: isotp_send , isotp_send_with_id , isotp_on_can_message , isotp_receive , isotp_poll . Link data model: IsoTpLink . Optional callbacks: isotp_set_tx_done_cb, isotp_set_rx_done_cb. Public Types Documentation \u00b6 typedef IsoTpLink \u00b6 Link state for a single ISO-TP connection. typedef struct IsoTpLink IsoTpLink; The data stored in this struct is used internally and may be used by software programs using this library. Public Functions Documentation \u00b6 function isotp_destroy_link \u00b6 Destroys the ISO-TP link and releases associated resources. void isotp_destroy_link ( IsoTpLink * link ) Parameters: link The IsoTpLink instance to destroy. function isotp_init_link \u00b6 Initialises the ISO-TP library. void isotp_init_link ( IsoTpLink * link, uint32_t sendid, uint8_t * sendbuf, uint32_t sendbufsize, uint8_t * recvbuf, uint32_t recvbufsize ) Parameters: link The IsoTpLink instance used for transceiving data. sendid The ID used to send data to other CAN nodes. sendbuf A pointer to an area in memory which can be used as a buffer for data to be sent. sendbufsize The size of the buffer area. recvbuf A pointer to an area in memory which can be used as a buffer for data to be received. recvbufsize The size of the buffer area. function isotp_on_can_message \u00b6 Handles incoming CAN messages. Determines whether an incoming message is a valid ISO-TP frame or not and handles it accordingly. void isotp_on_can_message ( IsoTpLink * link, const uint8_t * data, uint8_t len ) Parameters: link The IsoTpLink instance used for transceiving data. data The data received via CAN. len The length of the data received. function isotp_poll \u00b6 Polling function; call this function periodically to handle timeouts, send consecutive frames, etc. void isotp_poll ( IsoTpLink * link ) Parameters: link The IsoTpLink instance used. function isotp_receive \u00b6 Receives and parses the received data and copies the parsed data into the internal buffer. int isotp_receive ( IsoTpLink * link, uint8_t * payload, const uint32_t payload_size, uint32_t * out_size ) Parameters: link The IsoTpLink instance used to transceive data. payload A pointer to an area in memory where the raw data is copied from. payload_size The size of the received (raw) CAN data. out_size A reference to a variable which will contain the size of the actual (parsed) data. Returns: Possible return values: * ISOTP_RET_OK * ISOTP_RET_NO_DATA function isotp_send \u00b6 Sends ISO-TP frames via CAN, using the ID set in the initialising function. int isotp_send ( IsoTpLink * link, const uint8_t payload, uint32_t size ) Single-frame messages will be sent immediately when calling this function. Multi-frame messages will be sent consecutively when calling isotp_poll. Parameters: link The IsoTpLink instance used for transceiving data. payload The payload to be sent. (Up to 4095 bytes). size The size of the payload to be sent. Returns: Possible return values: * ISOTP_RET_OVERFLOW ISOTP_RET_INPROGRESS ISOTP_RET_OK The return value of the user shim function isotp_user_send_can() . function isotp_send_with_id \u00b6 See isotp_send , with the exception that this function is used only for functional addressing. int isotp_send_with_id ( IsoTpLink * link, uint32_t id, const uint8_t payload, uint32_t size )","title":"Group isotp"},{"location":"docs/group__isotp/#group-isotp","text":"Modules > isotp Public API for ISO-TP link management and message handling. More...","title":"Group isotp"},{"location":"docs/group__isotp/#modules","text":"Type Name module Configuration Build-time configuration for ISO-TP. module Protocol definitions Internal protocol definitions and type structures. module User hooks User-implemented callbacks and platform hooks.","title":"Modules"},{"location":"docs/group__isotp/#classes","text":"Type Name struct IsoTpLink Link state for a single ISO-TP connection.","title":"Classes"},{"location":"docs/group__isotp/#public-types","text":"Type Name typedef struct IsoTpLink IsoTpLink Link state for a single ISO-TP connection.","title":"Public Types"},{"location":"docs/group__isotp/#public-functions","text":"Type Name void isotp_destroy_link ( IsoTpLink * link) Destroys the ISO-TP link and releases associated resources. void isotp_init_link ( IsoTpLink * link, uint32_t sendid, uint8_t * sendbuf, uint32_t sendbufsize, uint8_t * recvbuf, uint32_t recvbufsize) Initialises the ISO-TP library. void isotp_on_can_message ( IsoTpLink * link, const uint8_t * data, uint8_t len) Handles incoming CAN messages. Determines whether an incoming message is a valid ISO-TP frame or not and handles it accordingly. void isotp_poll ( IsoTpLink * link) Polling function; call this function periodically to handle timeouts, send consecutive frames, etc. int isotp_receive ( IsoTpLink * link, uint8_t * payload, const uint32_t payload_size, uint32_t * out_size) Receives and parses the received data and copies the parsed data into the internal buffer. int isotp_send ( IsoTpLink * link, const uint8_t payload, uint32_t size) Sends ISO-TP frames via CAN, using the ID set in the initialising function. int isotp_send_with_id ( IsoTpLink * link, uint32_t id, const uint8_t payload, uint32_t size) See isotp_send , with the exception that this function is used only for functional addressing.","title":"Public Functions"},{"location":"docs/group__isotp/#detailed-description","text":"This module groups the public interface and its supporting submodules: Configuration , Protocol definitions , and User hooks . This group defines the public interface for initializing links, sending and receiving messages, handling incoming CAN frames, and polling the protocol state machine. It also exposes optional callback registration when enabled in configuration. ** ** Link lifecycle: isotp_init_link , isotp_destroy_link . Message flow: isotp_send , isotp_send_with_id , isotp_on_can_message , isotp_receive , isotp_poll . Link data model: IsoTpLink . Optional callbacks: isotp_set_tx_done_cb, isotp_set_rx_done_cb.","title":"Detailed Description"},{"location":"docs/group__isotp/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"docs/group__isotp/#typedef-isotplink","text":"Link state for a single ISO-TP connection. typedef struct IsoTpLink IsoTpLink; The data stored in this struct is used internally and may be used by software programs using this library.","title":"typedef IsoTpLink"},{"location":"docs/group__isotp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/group__isotp/#function-isotp_destroy_link","text":"Destroys the ISO-TP link and releases associated resources. void isotp_destroy_link ( IsoTpLink * link ) Parameters: link The IsoTpLink instance to destroy.","title":"function isotp_destroy_link"},{"location":"docs/group__isotp/#function-isotp_init_link","text":"Initialises the ISO-TP library. void isotp_init_link ( IsoTpLink * link, uint32_t sendid, uint8_t * sendbuf, uint32_t sendbufsize, uint8_t * recvbuf, uint32_t recvbufsize ) Parameters: link The IsoTpLink instance used for transceiving data. sendid The ID used to send data to other CAN nodes. sendbuf A pointer to an area in memory which can be used as a buffer for data to be sent. sendbufsize The size of the buffer area. recvbuf A pointer to an area in memory which can be used as a buffer for data to be received. recvbufsize The size of the buffer area.","title":"function isotp_init_link"},{"location":"docs/group__isotp/#function-isotp_on_can_message","text":"Handles incoming CAN messages. Determines whether an incoming message is a valid ISO-TP frame or not and handles it accordingly. void isotp_on_can_message ( IsoTpLink * link, const uint8_t * data, uint8_t len ) Parameters: link The IsoTpLink instance used for transceiving data. data The data received via CAN. len The length of the data received.","title":"function isotp_on_can_message"},{"location":"docs/group__isotp/#function-isotp_poll","text":"Polling function; call this function periodically to handle timeouts, send consecutive frames, etc. void isotp_poll ( IsoTpLink * link ) Parameters: link The IsoTpLink instance used.","title":"function isotp_poll"},{"location":"docs/group__isotp/#function-isotp_receive","text":"Receives and parses the received data and copies the parsed data into the internal buffer. int isotp_receive ( IsoTpLink * link, uint8_t * payload, const uint32_t payload_size, uint32_t * out_size ) Parameters: link The IsoTpLink instance used to transceive data. payload A pointer to an area in memory where the raw data is copied from. payload_size The size of the received (raw) CAN data. out_size A reference to a variable which will contain the size of the actual (parsed) data. Returns: Possible return values: * ISOTP_RET_OK * ISOTP_RET_NO_DATA","title":"function isotp_receive"},{"location":"docs/group__isotp/#function-isotp_send","text":"Sends ISO-TP frames via CAN, using the ID set in the initialising function. int isotp_send ( IsoTpLink * link, const uint8_t payload, uint32_t size ) Single-frame messages will be sent immediately when calling this function. Multi-frame messages will be sent consecutively when calling isotp_poll. Parameters: link The IsoTpLink instance used for transceiving data. payload The payload to be sent. (Up to 4095 bytes). size The size of the payload to be sent. Returns: Possible return values: * ISOTP_RET_OVERFLOW ISOTP_RET_INPROGRESS ISOTP_RET_OK The return value of the user shim function isotp_user_send_can() .","title":"function isotp_send"},{"location":"docs/group__isotp/#function-isotp_send_with_id","text":"See isotp_send , with the exception that this function is used only for functional addressing. int isotp_send_with_id ( IsoTpLink * link, uint32_t id, const uint8_t payload, uint32_t size )","title":"function isotp_send_with_id"},{"location":"docs/structIsoTpLink/","text":"Struct IsoTpLink \u00b6 ClassList > IsoTpLink Link state for a single ISO-TP connection. More... #include <isotp.h> Public Attributes \u00b6 Type Name uint32_t receive_arbitration_id uint8_t receive_bs_count uint32_t receive_buf_size uint8_t * receive_buffer uint32_t receive_offset int receive_protocol_result uint32_t receive_size uint8_t receive_sn uint8_t receive_status uint32_t receive_timer_cr uint32_t send_arbitration_id uint32_t send_bs_remain uint32_t send_buf_size uint8_t * send_buffer uint32_t send_offset int32_t send_protocol_result uint32_t send_size uint8_t send_sn uint32_t send_st_min_us uint8_t send_status uint32_t send_timer_bs uint32_t send_timer_st uint8_t send_wtf_count Detailed Description \u00b6 The data stored in this struct is used internally and may be used by software programs using this library. Public Attributes Documentation \u00b6 variable receive_arbitration_id \u00b6 uint32_t IsoTpLink :: receive_arbitration_id ; Arbitration ID used for reception. variable receive_bs_count \u00b6 uint8_t IsoTpLink :: receive_bs_count ; Max number of FC.Wait frames to send. variable receive_buf_size \u00b6 uint32_t IsoTpLink :: receive_buf_size ; Receive buffer size in bytes. variable receive_buffer \u00b6 uint8_t * IsoTpLink :: receive_buffer ; Receive buffer base pointer. variable receive_offset \u00b6 uint32_t IsoTpLink :: receive_offset ; Current receive offset in bytes. variable receive_protocol_result \u00b6 int IsoTpLink :: receive_protocol_result ; Last protocol result code for receiver. variable receive_size \u00b6 uint32_t IsoTpLink :: receive_size ; Total received size in bytes. variable receive_sn \u00b6 uint8_t IsoTpLink :: receive_sn ; Expected sequence number. variable receive_status \u00b6 uint8_t IsoTpLink :: receive_status ; Receiver status. variable receive_timer_cr \u00b6 uint32_t IsoTpLink :: receive_timer_cr ; Timer until next ConsecutiveFrame is expected. variable send_arbitration_id \u00b6 uint32_t IsoTpLink :: send_arbitration_id ; Arbitration ID used for consecutive frames. variable send_bs_remain \u00b6 uint32_t IsoTpLink :: send_bs_remain ; Remaining block size. variable send_buf_size \u00b6 uint32_t IsoTpLink :: send_buf_size ; Send buffer size in bytes. variable send_buffer \u00b6 uint8_t * IsoTpLink :: send_buffer ; Send buffer base pointer. variable send_offset \u00b6 uint32_t IsoTpLink :: send_offset ; Current send offset in bytes. variable send_protocol_result \u00b6 int32_t IsoTpLink :: send_protocol_result ; Last protocol result code for sender. variable send_size \u00b6 uint32_t IsoTpLink :: send_size ; Total size to send in bytes. variable send_sn \u00b6 uint8_t IsoTpLink :: send_sn ; Current sequence number. variable send_st_min_us \u00b6 uint32_t IsoTpLink :: send_st_min_us ; Minimum separation time in microseconds. variable send_status \u00b6 uint8_t IsoTpLink :: send_status ; Sender status. variable send_timer_bs \u00b6 uint32_t IsoTpLink :: send_timer_bs ; Timer until next FlowControl is expected. variable send_timer_st \u00b6 uint32_t IsoTpLink :: send_timer_st ; Timestamp of last consecutive frame send. variable send_wtf_count \u00b6 uint8_t IsoTpLink :: send_wtf_count ; Max number of FC.Wait frames to send. The documentation for this class was generated from the following file isotp.h","title":"Struct IsoTpLink"},{"location":"docs/structIsoTpLink/#struct-isotplink","text":"ClassList > IsoTpLink Link state for a single ISO-TP connection. More... #include <isotp.h>","title":"Struct IsoTpLink"},{"location":"docs/structIsoTpLink/#public-attributes","text":"Type Name uint32_t receive_arbitration_id uint8_t receive_bs_count uint32_t receive_buf_size uint8_t * receive_buffer uint32_t receive_offset int receive_protocol_result uint32_t receive_size uint8_t receive_sn uint8_t receive_status uint32_t receive_timer_cr uint32_t send_arbitration_id uint32_t send_bs_remain uint32_t send_buf_size uint8_t * send_buffer uint32_t send_offset int32_t send_protocol_result uint32_t send_size uint8_t send_sn uint32_t send_st_min_us uint8_t send_status uint32_t send_timer_bs uint32_t send_timer_st uint8_t send_wtf_count","title":"Public Attributes"},{"location":"docs/structIsoTpLink/#detailed-description","text":"The data stored in this struct is used internally and may be used by software programs using this library.","title":"Detailed Description"},{"location":"docs/structIsoTpLink/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/structIsoTpLink/#variable-receive_arbitration_id","text":"uint32_t IsoTpLink :: receive_arbitration_id ; Arbitration ID used for reception.","title":"variable receive_arbitration_id"},{"location":"docs/structIsoTpLink/#variable-receive_bs_count","text":"uint8_t IsoTpLink :: receive_bs_count ; Max number of FC.Wait frames to send.","title":"variable receive_bs_count"},{"location":"docs/structIsoTpLink/#variable-receive_buf_size","text":"uint32_t IsoTpLink :: receive_buf_size ; Receive buffer size in bytes.","title":"variable receive_buf_size"},{"location":"docs/structIsoTpLink/#variable-receive_buffer","text":"uint8_t * IsoTpLink :: receive_buffer ; Receive buffer base pointer.","title":"variable receive_buffer"},{"location":"docs/structIsoTpLink/#variable-receive_offset","text":"uint32_t IsoTpLink :: receive_offset ; Current receive offset in bytes.","title":"variable receive_offset"},{"location":"docs/structIsoTpLink/#variable-receive_protocol_result","text":"int IsoTpLink :: receive_protocol_result ; Last protocol result code for receiver.","title":"variable receive_protocol_result"},{"location":"docs/structIsoTpLink/#variable-receive_size","text":"uint32_t IsoTpLink :: receive_size ; Total received size in bytes.","title":"variable receive_size"},{"location":"docs/structIsoTpLink/#variable-receive_sn","text":"uint8_t IsoTpLink :: receive_sn ; Expected sequence number.","title":"variable receive_sn"},{"location":"docs/structIsoTpLink/#variable-receive_status","text":"uint8_t IsoTpLink :: receive_status ; Receiver status.","title":"variable receive_status"},{"location":"docs/structIsoTpLink/#variable-receive_timer_cr","text":"uint32_t IsoTpLink :: receive_timer_cr ; Timer until next ConsecutiveFrame is expected.","title":"variable receive_timer_cr"},{"location":"docs/structIsoTpLink/#variable-send_arbitration_id","text":"uint32_t IsoTpLink :: send_arbitration_id ; Arbitration ID used for consecutive frames.","title":"variable send_arbitration_id"},{"location":"docs/structIsoTpLink/#variable-send_bs_remain","text":"uint32_t IsoTpLink :: send_bs_remain ; Remaining block size.","title":"variable send_bs_remain"},{"location":"docs/structIsoTpLink/#variable-send_buf_size","text":"uint32_t IsoTpLink :: send_buf_size ; Send buffer size in bytes.","title":"variable send_buf_size"},{"location":"docs/structIsoTpLink/#variable-send_buffer","text":"uint8_t * IsoTpLink :: send_buffer ; Send buffer base pointer.","title":"variable send_buffer"},{"location":"docs/structIsoTpLink/#variable-send_offset","text":"uint32_t IsoTpLink :: send_offset ; Current send offset in bytes.","title":"variable send_offset"},{"location":"docs/structIsoTpLink/#variable-send_protocol_result","text":"int32_t IsoTpLink :: send_protocol_result ; Last protocol result code for sender.","title":"variable send_protocol_result"},{"location":"docs/structIsoTpLink/#variable-send_size","text":"uint32_t IsoTpLink :: send_size ; Total size to send in bytes.","title":"variable send_size"},{"location":"docs/structIsoTpLink/#variable-send_sn","text":"uint8_t IsoTpLink :: send_sn ; Current sequence number.","title":"variable send_sn"},{"location":"docs/structIsoTpLink/#variable-send_st_min_us","text":"uint32_t IsoTpLink :: send_st_min_us ; Minimum separation time in microseconds.","title":"variable send_st_min_us"},{"location":"docs/structIsoTpLink/#variable-send_status","text":"uint8_t IsoTpLink :: send_status ; Sender status.","title":"variable send_status"},{"location":"docs/structIsoTpLink/#variable-send_timer_bs","text":"uint32_t IsoTpLink :: send_timer_bs ; Timer until next FlowControl is expected.","title":"variable send_timer_bs"},{"location":"docs/structIsoTpLink/#variable-send_timer_st","text":"uint32_t IsoTpLink :: send_timer_st ; Timestamp of last consecutive frame send.","title":"variable send_timer_st"},{"location":"docs/structIsoTpLink/#variable-send_wtf_count","text":"uint8_t IsoTpLink :: send_wtf_count ; Max number of FC.Wait frames to send. The documentation for this class was generated from the following file isotp.h","title":"variable send_wtf_count"},{"location":"docs/group__isotp__config/","text":"Group isotp_config \u00b6 Modules > isotp_config Build-time configuration for ISO-TP. More... Detailed Description \u00b6 Configuration parameters in this group control protocol behavior as exposed by the API in isotp.h and implemented in isotp.c. They cover limits and timing used when sending and receiving single- and multi-frame messages, including block size (BS), minimum separation time (ST_min), and response timeouts. They also enable optional features such as frame padding, an extra argument for isotp_user_send_can, and callbacks for transmit and receive completion. ** ** ISO_TP_DEFAULT_BLOCK_SIZE : default receiver block size (BS). ISO_TP_DEFAULT_ST_MIN_US : default minimum separation time (ST_min) in us. ISO_TP_MAX_WFT_NUMBER : maximum number of FC.Wait frames in a row. ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US : response timeout during multi-frame transfer. ISO_TP_FRAME_PADDING : enable frame padding for ISO-TP frames. ISO_TP_FRAME_PADDING_VALUE : padding byte value when padding is enabled. ISO_TP_USER_SEND_CAN_ARG : add a user argument to isotp_user_send_can . ISO_TP_TRANSMIT_COMPLETE_CALLBACK : enable transmit complete callback support. ISO_TP_RECEIVE_COMPLETE_CALLBACK: enable receive complete callback support.","title":"Group isotp_config"},{"location":"docs/group__isotp__config/#group-isotp_config","text":"Modules > isotp_config Build-time configuration for ISO-TP. More...","title":"Group isotp_config"},{"location":"docs/group__isotp__config/#detailed-description","text":"Configuration parameters in this group control protocol behavior as exposed by the API in isotp.h and implemented in isotp.c. They cover limits and timing used when sending and receiving single- and multi-frame messages, including block size (BS), minimum separation time (ST_min), and response timeouts. They also enable optional features such as frame padding, an extra argument for isotp_user_send_can, and callbacks for transmit and receive completion. ** ** ISO_TP_DEFAULT_BLOCK_SIZE : default receiver block size (BS). ISO_TP_DEFAULT_ST_MIN_US : default minimum separation time (ST_min) in us. ISO_TP_MAX_WFT_NUMBER : maximum number of FC.Wait frames in a row. ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US : response timeout during multi-frame transfer. ISO_TP_FRAME_PADDING : enable frame padding for ISO-TP frames. ISO_TP_FRAME_PADDING_VALUE : padding byte value when padding is enabled. ISO_TP_USER_SEND_CAN_ARG : add a user argument to isotp_user_send_can . ISO_TP_TRANSMIT_COMPLETE_CALLBACK : enable transmit complete callback support. ISO_TP_RECEIVE_COMPLETE_CALLBACK: enable receive complete callback support.","title":"Detailed Description"},{"location":"docs/group__isotp__defines/","text":"Group isotp_defines \u00b6 Modules > isotp_defines Internal protocol definitions and type structures. More... Detailed Description \u00b6 This group contains the low-level building blocks used by the ISO-TP core (frame layouts, PCI types, status codes, and timing helpers). These definitions describe how CAN frames are encoded/decoded and provide enums and constants that drive the state machine in isotp.c. ** ** Frame layout structs: IsoTpSingleFrame , IsoTpFirstFrameShort , IsoTpFirstFrameLong, IsoTpConsecutiveFrame , IsoTpFlowControl . Frame container: IsoTpCanMessage and IsoTpDataArray . PCI type and flow status enums: IsoTpProtocolControlInformation , IsoTpFlowStatus . Return codes and protocol result codes: ISOTP_RET_OK , ISOTP_RET_ERROR, ISOTP_RET_INPROGRESS, ISOTP_RET_OVERFLOW, ISOTP_RET_WRONG_SN, ISOTP_RET_NO_DATA, ISOTP_RET_TIMEOUT, ISOTP_RET_LENGTH, ISOTP_RET_NOSPACE, ISOTP_PROTOCOL_RESULT_OK , ISOTP_PROTOCOL_RESULT_TIMEOUT_A, ISOTP_PROTOCOL_RESULT_TIMEOUT_BS, ISOTP_PROTOCOL_RESULT_TIMEOUT_CR, ISOTP_PROTOCOL_RESULT_WRONG_SN, ISOTP_PROTOCOL_RESULT_INVALID_FS, ISOTP_PROTOCOL_RESULT_UNEXP_PDU, ISOTP_PROTOCOL_RESULT_WFT_OVRN, ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW, ISOTP_PROTOCOL_RESULT_ERROR. Byte order and packing helpers: ISOTP_BYTE_ORDER_LITTLE_ENDIAN, ISOTP_PACKED_STRUCT , LE32TOH . Status types and helpers: IsoTpSendStatusTypes , IsoTpReceiveStatusTypes , IsoTpTimeAfter , ISOTP_INVALID_BS , ISOTP_MAX_ERROR_MSG_SIZE .","title":"Group isotp_defines"},{"location":"docs/group__isotp__defines/#group-isotp_defines","text":"Modules > isotp_defines Internal protocol definitions and type structures. More...","title":"Group isotp_defines"},{"location":"docs/group__isotp__defines/#detailed-description","text":"This group contains the low-level building blocks used by the ISO-TP core (frame layouts, PCI types, status codes, and timing helpers). These definitions describe how CAN frames are encoded/decoded and provide enums and constants that drive the state machine in isotp.c. ** ** Frame layout structs: IsoTpSingleFrame , IsoTpFirstFrameShort , IsoTpFirstFrameLong, IsoTpConsecutiveFrame , IsoTpFlowControl . Frame container: IsoTpCanMessage and IsoTpDataArray . PCI type and flow status enums: IsoTpProtocolControlInformation , IsoTpFlowStatus . Return codes and protocol result codes: ISOTP_RET_OK , ISOTP_RET_ERROR, ISOTP_RET_INPROGRESS, ISOTP_RET_OVERFLOW, ISOTP_RET_WRONG_SN, ISOTP_RET_NO_DATA, ISOTP_RET_TIMEOUT, ISOTP_RET_LENGTH, ISOTP_RET_NOSPACE, ISOTP_PROTOCOL_RESULT_OK , ISOTP_PROTOCOL_RESULT_TIMEOUT_A, ISOTP_PROTOCOL_RESULT_TIMEOUT_BS, ISOTP_PROTOCOL_RESULT_TIMEOUT_CR, ISOTP_PROTOCOL_RESULT_WRONG_SN, ISOTP_PROTOCOL_RESULT_INVALID_FS, ISOTP_PROTOCOL_RESULT_UNEXP_PDU, ISOTP_PROTOCOL_RESULT_WFT_OVRN, ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW, ISOTP_PROTOCOL_RESULT_ERROR. Byte order and packing helpers: ISOTP_BYTE_ORDER_LITTLE_ENDIAN, ISOTP_PACKED_STRUCT , LE32TOH . Status types and helpers: IsoTpSendStatusTypes , IsoTpReceiveStatusTypes , IsoTpTimeAfter , ISOTP_INVALID_BS , ISOTP_MAX_ERROR_MSG_SIZE .","title":"Detailed Description"},{"location":"docs/group__isotp__user/","text":"Group isotp_user \u00b6 Modules > isotp_user User-implemented callbacks and platform hooks. More... Public Functions \u00b6 Type Name void isotp_user_debug (const char * message, ...) User implemented, print debug message. uint32_t isotp_user_get_us (void) User implemented, return a monotonically increasing timebase in microseconds. int isotp_user_send_can (const uint32_t arbitration_id, const uint8_t * data, const uint8_t size) User implemented, send CAN message. Detailed Description \u00b6 This group defines the platform abstraction points required by the ISO-TP core. Applications must provide these functions to integrate with their CAN driver, timing source, and optional debug output. ** ** Debug output hook: isotp_user_debug . CAN transmit hook: isotp_user_send_can (optionally with ISO_TP_USER_SEND_CAN_ARG). Time source hook: isotp_user_get_us . Public Functions Documentation \u00b6 function isotp_user_debug \u00b6 User implemented, print debug message. void isotp_user_debug ( const char * message, ... ) Parameters: message Debug message format string. User implemented, print debug message. Parameters: message The message to print. function isotp_user_get_us \u00b6 User implemented, return a monotonically increasing timebase in microseconds. uint32_t isotp_user_get_us ( void ) This function must provide a free-running timestamp in microseconds that increases monotonically over time. The ISO-TP core uses this value for timeout and delay calculations by performing arithmetic on the returned timestamp (for example, adding a timeout interval to it). Natural wrap-around of the 32-bit counter is allowed and will be handled by the ISO-TP core, but the value must not jump backwards except for such wrap-around. Returns: Current timebase value in microseconds. User implemented, return a monotonically increasing timebase in microseconds. Returns: uint32_t Current time in microseconds function isotp_user_send_can \u00b6 User implemented, send CAN message. int isotp_user_send_can ( const uint32_t arbitration_id, const uint8_t * data, const uint8_t size ) Should return ISOTP_RET_OK on success. Parameters: arbitration_id CAN message arbitration ID. data Pointer to message data buffer. size Size of message data in bytes. Returns: ISOTP_RET_OK on success, ISOTP_RET_NOSPACE if transfer should be retried later, or ISOTP_RET_ERROR on failure. User implemented, send CAN message. Parameters: arbitration_id The CAN ID to send with. data Pointer to the data buffer to send. size Size of the data buffer (max 8 bytes). Returns: int ISOTP_RET_OK on success, ISOTP_RET_ERROR on failure.","title":"Group isotp_user"},{"location":"docs/group__isotp__user/#group-isotp_user","text":"Modules > isotp_user User-implemented callbacks and platform hooks. More...","title":"Group isotp_user"},{"location":"docs/group__isotp__user/#public-functions","text":"Type Name void isotp_user_debug (const char * message, ...) User implemented, print debug message. uint32_t isotp_user_get_us (void) User implemented, return a monotonically increasing timebase in microseconds. int isotp_user_send_can (const uint32_t arbitration_id, const uint8_t * data, const uint8_t size) User implemented, send CAN message.","title":"Public Functions"},{"location":"docs/group__isotp__user/#detailed-description","text":"This group defines the platform abstraction points required by the ISO-TP core. Applications must provide these functions to integrate with their CAN driver, timing source, and optional debug output. ** ** Debug output hook: isotp_user_debug . CAN transmit hook: isotp_user_send_can (optionally with ISO_TP_USER_SEND_CAN_ARG). Time source hook: isotp_user_get_us .","title":"Detailed Description"},{"location":"docs/group__isotp__user/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/group__isotp__user/#function-isotp_user_debug","text":"User implemented, print debug message. void isotp_user_debug ( const char * message, ... ) Parameters: message Debug message format string. User implemented, print debug message. Parameters: message The message to print.","title":"function isotp_user_debug"},{"location":"docs/group__isotp__user/#function-isotp_user_get_us","text":"User implemented, return a monotonically increasing timebase in microseconds. uint32_t isotp_user_get_us ( void ) This function must provide a free-running timestamp in microseconds that increases monotonically over time. The ISO-TP core uses this value for timeout and delay calculations by performing arithmetic on the returned timestamp (for example, adding a timeout interval to it). Natural wrap-around of the 32-bit counter is allowed and will be handled by the ISO-TP core, but the value must not jump backwards except for such wrap-around. Returns: Current timebase value in microseconds. User implemented, return a monotonically increasing timebase in microseconds. Returns: uint32_t Current time in microseconds","title":"function isotp_user_get_us"},{"location":"docs/group__isotp__user/#function-isotp_user_send_can","text":"User implemented, send CAN message. int isotp_user_send_can ( const uint32_t arbitration_id, const uint8_t * data, const uint8_t size ) Should return ISOTP_RET_OK on success. Parameters: arbitration_id CAN message arbitration ID. data Pointer to message data buffer. size Size of message data in bytes. Returns: ISOTP_RET_OK on success, ISOTP_RET_NOSPACE if transfer should be retried later, or ISOTP_RET_ERROR on failure. User implemented, send CAN message. Parameters: arbitration_id The CAN ID to send with. data Pointer to the data buffer to send. size Size of the data buffer (max 8 bytes). Returns: int ISOTP_RET_OK on success, ISOTP_RET_ERROR on failure.","title":"function isotp_user_send_can"},{"location":"docs/dir_cfafba98a580ce4b62f8a6fa96d7cbb0/","text":"Dir example \u00b6 FileList > example Directories \u00b6 Type Name dir linux_socket The documentation for this class was generated from the following file example/","title":"Dir example"},{"location":"docs/dir_cfafba98a580ce4b62f8a6fa96d7cbb0/#dir-example","text":"FileList > example","title":"Dir example"},{"location":"docs/dir_cfafba98a580ce4b62f8a6fa96d7cbb0/#directories","text":"Type Name dir linux_socket The documentation for this class was generated from the following file example/","title":"Directories"},{"location":"docs/dir_c14c1b0e0eb041fc48b83316cb935ab5/","text":"Dir example/linux_socket \u00b6 FileList > example > linux_socket Files \u00b6 Type Name file linux_socket.c The documentation for this class was generated from the following file example/linux_socket/","title":"Dir example/linux_socket"},{"location":"docs/dir_c14c1b0e0eb041fc48b83316cb935ab5/#dir-examplelinux_socket","text":"FileList > example > linux_socket","title":"Dir example/linux_socket"},{"location":"docs/dir_c14c1b0e0eb041fc48b83316cb935ab5/#files","text":"Type Name file linux_socket.c The documentation for this class was generated from the following file example/linux_socket/","title":"Files"},{"location":"docs/linux__socket_8c/","text":"File linux_socket.c \u00b6 FileList > example > linux_socket > linux_socket.c Go to the source code of this file #include <stdio.h> #include <stdlib.h> #include <stdbool.h> #include <string.h> #include <unistd.h> #include <time.h> #include <stdarg.h> #include <net/if.h> #include <sys/ioctl.h> #include <sys/socket.h> #include <linux/can.h> #include <linux/can/raw.h> #include <isotp.h> Public Static Attributes \u00b6 Type Name int _socket SocketCAN file descriptor. uint8_t g_isotpRecvBuf uint8_t g_isotpSendBuf IsoTpLink g_link ISO-TP link instance, allocated statically in RAM. Public Functions \u00b6 Type Name int main (int argc, char ** argv) Macros \u00b6 Type Name define SEC_TO_US (sec) ((sec) \\* 1000000) Macro to convert seconds to microseconds. define _CAN_INTERFACE \"slcan0\" CAN interface to use (e.g., \"can0\", \"slcan0\", etc.) define _ISOTP_BUFSIZE (128) Buffer size for ISO-TP messages (must be >= 4095 for full ISO-TP support)/*#end#* /. define _ISOTP_CAN_ID (0x0C1) CAN ID to use for sending ISO-TP messages (must match the receiver's expected ID)/*#end#* /. Public Static Attributes Documentation \u00b6 variable _socket \u00b6 SocketCAN file descriptor. int _socket ; variable g_isotpRecvBuf \u00b6 uint8_t g_isotpRecvBuf [ _ISOTP_BUFSIZE ]; Buffer for receiving ISO-TP messages, allocated statically in RAM variable g_isotpSendBuf \u00b6 uint8_t g_isotpSendBuf [ _ISOTP_BUFSIZE ]; Buffer for sending ISO-TP messages, allocated statically in RAM variable g_link \u00b6 ISO-TP link instance, allocated statically in RAM. IsoTpLink g_link ; Public Functions Documentation \u00b6 function main \u00b6 int main ( int argc , char ** argv ) Macro Definition Documentation \u00b6 define SEC_TO_US \u00b6 Macro to convert seconds to microseconds. #define SEC_TO_US ( sec ) ` (( sec ) * 1000000 ) ` define _CAN_INTERFACE \u00b6 CAN interface to use (e.g., \"can0\", \"slcan0\", etc.) #define _CAN_INTERFACE `\"slcan0\"` define _ISOTP_BUFSIZE \u00b6 Buffer size for ISO-TP messages (must be >= 4095 for full ISO-TP support)/*#end#* /. #define _ISOTP_BUFSIZE `(128)` define _ISOTP_CAN_ID \u00b6 CAN ID to use for sending ISO-TP messages (must match the receiver's expected ID)/*#end#* /. #define _ISOTP_CAN_ID `(0x0C1)` The documentation for this class was generated from the following file example/linux_socket/linux_socket.c","title":"File linux_socket.c"},{"location":"docs/linux__socket_8c/#file-linux_socketc","text":"FileList > example > linux_socket > linux_socket.c Go to the source code of this file #include <stdio.h> #include <stdlib.h> #include <stdbool.h> #include <string.h> #include <unistd.h> #include <time.h> #include <stdarg.h> #include <net/if.h> #include <sys/ioctl.h> #include <sys/socket.h> #include <linux/can.h> #include <linux/can/raw.h> #include <isotp.h>","title":"File linux_socket.c"},{"location":"docs/linux__socket_8c/#public-static-attributes","text":"Type Name int _socket SocketCAN file descriptor. uint8_t g_isotpRecvBuf uint8_t g_isotpSendBuf IsoTpLink g_link ISO-TP link instance, allocated statically in RAM.","title":"Public Static Attributes"},{"location":"docs/linux__socket_8c/#public-functions","text":"Type Name int main (int argc, char ** argv)","title":"Public Functions"},{"location":"docs/linux__socket_8c/#macros","text":"Type Name define SEC_TO_US (sec) ((sec) \\* 1000000) Macro to convert seconds to microseconds. define _CAN_INTERFACE \"slcan0\" CAN interface to use (e.g., \"can0\", \"slcan0\", etc.) define _ISOTP_BUFSIZE (128) Buffer size for ISO-TP messages (must be >= 4095 for full ISO-TP support)/*#end#* /. define _ISOTP_CAN_ID (0x0C1) CAN ID to use for sending ISO-TP messages (must match the receiver's expected ID)/*#end#* /.","title":"Macros"},{"location":"docs/linux__socket_8c/#public-static-attributes-documentation","text":"","title":"Public Static Attributes Documentation"},{"location":"docs/linux__socket_8c/#variable-_socket","text":"SocketCAN file descriptor. int _socket ;","title":"variable _socket"},{"location":"docs/linux__socket_8c/#variable-g_isotprecvbuf","text":"uint8_t g_isotpRecvBuf [ _ISOTP_BUFSIZE ]; Buffer for receiving ISO-TP messages, allocated statically in RAM","title":"variable g_isotpRecvBuf"},{"location":"docs/linux__socket_8c/#variable-g_isotpsendbuf","text":"uint8_t g_isotpSendBuf [ _ISOTP_BUFSIZE ]; Buffer for sending ISO-TP messages, allocated statically in RAM","title":"variable g_isotpSendBuf"},{"location":"docs/linux__socket_8c/#variable-g_link","text":"ISO-TP link instance, allocated statically in RAM. IsoTpLink g_link ;","title":"variable g_link"},{"location":"docs/linux__socket_8c/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/linux__socket_8c/#function-main","text":"int main ( int argc , char ** argv )","title":"function main"},{"location":"docs/linux__socket_8c/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"docs/linux__socket_8c/#define-sec_to_us","text":"Macro to convert seconds to microseconds. #define SEC_TO_US ( sec ) ` (( sec ) * 1000000 ) `","title":"define SEC_TO_US"},{"location":"docs/linux__socket_8c/#define-_can_interface","text":"CAN interface to use (e.g., \"can0\", \"slcan0\", etc.) #define _CAN_INTERFACE `\"slcan0\"`","title":"define _CAN_INTERFACE"},{"location":"docs/linux__socket_8c/#define-_isotp_bufsize","text":"Buffer size for ISO-TP messages (must be >= 4095 for full ISO-TP support)/*#end#* /. #define _ISOTP_BUFSIZE `(128)`","title":"define _ISOTP_BUFSIZE"},{"location":"docs/linux__socket_8c/#define-_isotp_can_id","text":"CAN ID to use for sending ISO-TP messages (must match the receiver's expected ID)/*#end#* /. #define _ISOTP_CAN_ID `(0x0C1)` The documentation for this class was generated from the following file example/linux_socket/linux_socket.c","title":"define _ISOTP_CAN_ID"},{"location":"docs/linux__socket_8c_source/","text":"File linux_socket.c \u00b6 File List > example > linux_socket > linux_socket.c Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Example implementation of ISO-TP over Linux SocketCAN * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <stdio.h> #include <stdlib.h> #include <stdbool.h> #include <string.h> #include <unistd.h> #include <time.h> #include <stdarg.h> #include <net/if.h> #include <sys/ioctl.h> #include <sys/socket.h> #include <linux/can.h> #include <linux/can/raw.h> #include <isotp.h> /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ #define _CAN_INTERFACE \"slcan0\" #define _ISOTP_BUFSIZE \\ (128) #define _ISOTP_CAN_ID \\ (0x0C1) #define SEC_TO_US(sec) ((sec) * 1000000) /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Static type definitions local to this file */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ static IsoTpLink g_link ; static uint8_t g_isotpRecvBuf [ _ISOTP_BUFSIZE ]; static uint8_t g_isotpSendBuf [ _ISOTP_BUFSIZE ]; static int _socket ; /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ uint32_t isotp_user_get_us ( void ); void isotp_user_debug ( const char * message , ...); int isotp_user_send_can ( const uint32_t arbitration_id , const uint8_t * data , const uint8_t size #ifdef ISO_TP_USER_SEND_CAN_ARG , void * arg #endif ); /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ void isotp_user_debug ( const char * message , ...) { va_list args ; va_start ( args , message ); vfprintf ( stderr , message , args ); va_end ( args ); } int isotp_user_send_can ( const uint32_t arbitration_id , const uint8_t * data , const uint8_t size #ifdef ISO_TP_USER_SEND_CAN_ARG , void * arg #endif ) { int ret = ISOTP_RET_ERROR ; struct can_frame frame ; frame . can_id = arbitration_id | CAN_EFF_FLAG ; frame . can_dlc = size ; memcpy ( frame . data , data , size ); #ifdef ISO_TP_USER_SEND_CAN_ARG ( void ) arg ; #endif ssize_t ret_size = write ( _socket , & frame , sizeof ( struct can_frame )); if ( ret_size == sizeof ( struct can_frame )) { ret = ISOTP_RET_OK ; } return ret ; /* TODO: Check return value */ } uint32_t isotp_user_get_us ( void ) { uint64_t microsecond ; struct timespec ts ; if ( clock_gettime ( CLOCK_MONOTONIC , & ts ) != 0 ) { perror ( \"Failed to obtain monotonic timestamp.\" ); microsecond = UINT64_MAX ; // use this to indicate error } else { // `ts` now contains your timestamp in seconds and microseconds! To // convert the whole struct to microseconds, do this: microsecond = SEC_TO_US (( uint64_t ) ts . tv_sec ) + ( uint64_t ) ( ts . tv_nsec / 1000 ); } return ( uint32_t ) microsecond ; } /* ============================================================================== * PUBLIC FUNCTION IMPLEMENTATIONS * =============================================================================*/ int main ( int argc , char ** argv ) { int i ; int nbytes ; struct sockaddr_can addr ; struct ifreq ifr ; struct can_frame frame ; printf ( \"CAN Sockets Demo \\r\\n \" ); _socket = socket ( PF_CAN , SOCK_RAW , CAN_RAW ); if ( _socket < 0 ) { perror ( \"Socket\" ); return 1 ; } strcpy ( ifr . ifr_name , _CAN_INTERFACE ); ioctl ( _socket , SIOCGIFINDEX , & ifr ); memset ( & addr , 0 , sizeof ( addr )); addr . can_family = AF_CAN ; addr . can_ifindex = ifr . ifr_ifindex ; if ( bind ( _socket , ( struct sockaddr * ) & addr , sizeof ( addr )) < 0 ) { perror ( \"Bind\" ); return 1 ; } /* Init ISOTP lib */ /* Initialize link, ISOTP_CAN_ID is the CAN ID you send with */ isotp_init_link ( & g_link , _ISOTP_CAN_ID , g_isotpSendBuf , sizeof ( g_isotpSendBuf ), g_isotpRecvBuf , sizeof ( g_isotpRecvBuf )); while ( true ) { nbytes = read ( _socket , & frame , sizeof ( struct can_frame )); if ( nbytes < 0 ) { perror ( \"Read\" ); break ; } uint32_t arbitration_id = frame . can_id & CAN_EFF_MASK ; if ( arbitration_id != _ISOTP_CAN_ID ) { continue ; } isotp_on_can_message ( & g_link , frame . data , frame . can_dlc ); isotp_poll ( & g_link ); if ( g_link . receive_status == ISOTP_RECEIVE_STATUS_FULL ) { uint8_t payload [ _ISOTP_BUFSIZE ] = { 0 }; uint32_t out_size = 0 ; int ret = isotp_receive ( & g_link , payload , sizeof ( payload ), & out_size ); if ( ret == ISOTP_RET_OK ) { bool is_eff = ( frame . can_id & CAN_EFF_FLAG ) != 0U ; uint32_t can_id = frame . can_id & ( is_eff ? CAN_EFF_MASK : CAN_SFF_MASK ); if ( is_eff ) { printf ( \"0x%08X [%d] \" , can_id , out_size ); } else { printf ( \"0x%03X [%d] \" , can_id , out_size ); } for ( i = 0 ; i < out_size ; i ++ ) printf ( \"%02X \" , payload [ i ]); printf ( \" \\r\\n \" ); } } } isotp_destroy_link ( & g_link ); if ( close ( _socket ) < 0 ) { perror ( \"Close\" ); return 1 ; } return 0 ; }","title":"File linux_socket.c"},{"location":"docs/linux__socket_8c_source/#file-linux_socketc","text":"File List > example > linux_socket > linux_socket.c Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Example implementation of ISO-TP over Linux SocketCAN * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <stdio.h> #include <stdlib.h> #include <stdbool.h> #include <string.h> #include <unistd.h> #include <time.h> #include <stdarg.h> #include <net/if.h> #include <sys/ioctl.h> #include <sys/socket.h> #include <linux/can.h> #include <linux/can/raw.h> #include <isotp.h> /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ #define _CAN_INTERFACE \"slcan0\" #define _ISOTP_BUFSIZE \\ (128) #define _ISOTP_CAN_ID \\ (0x0C1) #define SEC_TO_US(sec) ((sec) * 1000000) /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Static type definitions local to this file */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ static IsoTpLink g_link ; static uint8_t g_isotpRecvBuf [ _ISOTP_BUFSIZE ]; static uint8_t g_isotpSendBuf [ _ISOTP_BUFSIZE ]; static int _socket ; /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ uint32_t isotp_user_get_us ( void ); void isotp_user_debug ( const char * message , ...); int isotp_user_send_can ( const uint32_t arbitration_id , const uint8_t * data , const uint8_t size #ifdef ISO_TP_USER_SEND_CAN_ARG , void * arg #endif ); /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ void isotp_user_debug ( const char * message , ...) { va_list args ; va_start ( args , message ); vfprintf ( stderr , message , args ); va_end ( args ); } int isotp_user_send_can ( const uint32_t arbitration_id , const uint8_t * data , const uint8_t size #ifdef ISO_TP_USER_SEND_CAN_ARG , void * arg #endif ) { int ret = ISOTP_RET_ERROR ; struct can_frame frame ; frame . can_id = arbitration_id | CAN_EFF_FLAG ; frame . can_dlc = size ; memcpy ( frame . data , data , size ); #ifdef ISO_TP_USER_SEND_CAN_ARG ( void ) arg ; #endif ssize_t ret_size = write ( _socket , & frame , sizeof ( struct can_frame )); if ( ret_size == sizeof ( struct can_frame )) { ret = ISOTP_RET_OK ; } return ret ; /* TODO: Check return value */ } uint32_t isotp_user_get_us ( void ) { uint64_t microsecond ; struct timespec ts ; if ( clock_gettime ( CLOCK_MONOTONIC , & ts ) != 0 ) { perror ( \"Failed to obtain monotonic timestamp.\" ); microsecond = UINT64_MAX ; // use this to indicate error } else { // `ts` now contains your timestamp in seconds and microseconds! To // convert the whole struct to microseconds, do this: microsecond = SEC_TO_US (( uint64_t ) ts . tv_sec ) + ( uint64_t ) ( ts . tv_nsec / 1000 ); } return ( uint32_t ) microsecond ; } /* ============================================================================== * PUBLIC FUNCTION IMPLEMENTATIONS * =============================================================================*/ int main ( int argc , char ** argv ) { int i ; int nbytes ; struct sockaddr_can addr ; struct ifreq ifr ; struct can_frame frame ; printf ( \"CAN Sockets Demo \\r\\n \" ); _socket = socket ( PF_CAN , SOCK_RAW , CAN_RAW ); if ( _socket < 0 ) { perror ( \"Socket\" ); return 1 ; } strcpy ( ifr . ifr_name , _CAN_INTERFACE ); ioctl ( _socket , SIOCGIFINDEX , & ifr ); memset ( & addr , 0 , sizeof ( addr )); addr . can_family = AF_CAN ; addr . can_ifindex = ifr . ifr_ifindex ; if ( bind ( _socket , ( struct sockaddr * ) & addr , sizeof ( addr )) < 0 ) { perror ( \"Bind\" ); return 1 ; } /* Init ISOTP lib */ /* Initialize link, ISOTP_CAN_ID is the CAN ID you send with */ isotp_init_link ( & g_link , _ISOTP_CAN_ID , g_isotpSendBuf , sizeof ( g_isotpSendBuf ), g_isotpRecvBuf , sizeof ( g_isotpRecvBuf )); while ( true ) { nbytes = read ( _socket , & frame , sizeof ( struct can_frame )); if ( nbytes < 0 ) { perror ( \"Read\" ); break ; } uint32_t arbitration_id = frame . can_id & CAN_EFF_MASK ; if ( arbitration_id != _ISOTP_CAN_ID ) { continue ; } isotp_on_can_message ( & g_link , frame . data , frame . can_dlc ); isotp_poll ( & g_link ); if ( g_link . receive_status == ISOTP_RECEIVE_STATUS_FULL ) { uint8_t payload [ _ISOTP_BUFSIZE ] = { 0 }; uint32_t out_size = 0 ; int ret = isotp_receive ( & g_link , payload , sizeof ( payload ), & out_size ); if ( ret == ISOTP_RET_OK ) { bool is_eff = ( frame . can_id & CAN_EFF_FLAG ) != 0U ; uint32_t can_id = frame . can_id & ( is_eff ? CAN_EFF_MASK : CAN_SFF_MASK ); if ( is_eff ) { printf ( \"0x%08X [%d] \" , can_id , out_size ); } else { printf ( \"0x%03X [%d] \" , can_id , out_size ); } for ( i = 0 ; i < out_size ; i ++ ) printf ( \"%02X \" , payload [ i ]); printf ( \" \\r\\n \" ); } } } isotp_destroy_link ( & g_link ); if ( close ( _socket ) < 0 ) { perror ( \"Close\" ); return 1 ; } return 0 ; }","title":"File linux_socket.c"},{"location":"docs/dir_bfccd401955b95cf8c75461437045ac0/","text":"Dir inc \u00b6 FileList > inc Files \u00b6 Type Name file isotp_config.h ISO-TP configuration parameters and feature toggles. file isotp_defines.h Internal protocol definitions and type structures for ISO-TP. file isotp_user.h User callback interfaces and platform abstraction layer. The documentation for this class was generated from the following file inc/","title":"Dir inc"},{"location":"docs/dir_bfccd401955b95cf8c75461437045ac0/#dir-inc","text":"FileList > inc","title":"Dir inc"},{"location":"docs/dir_bfccd401955b95cf8c75461437045ac0/#files","text":"Type Name file isotp_config.h ISO-TP configuration parameters and feature toggles. file isotp_defines.h Internal protocol definitions and type structures for ISO-TP. file isotp_user.h User callback interfaces and platform abstraction layer. The documentation for this class was generated from the following file inc/","title":"Files"},{"location":"docs/isotp__config_8h/","text":"File isotp_config.h \u00b6 FileList > inc > isotp_config.h Go to the source code of this file ISO-TP configuration parameters and feature toggles. More... Macros \u00b6 Type Name define ISO_TP_DEFAULT_BLOCK_SIZE (8) Max number of messages the receiver can receive at one time. define ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US (100000) Default timeout while waiting for a response during a multi-frame transfer. define ISO_TP_DEFAULT_ST_MIN_US (0) Minimum time gap allowed between consecutive frame N_PDUs. define ISO_TP_FRAME_PADDING_VALUE (0xAA) Padding byte value when ISO_TP_FRAME_PADDING is enabled. define ISO_TP_MAX_WFT_NUMBER (1) Number of FC N_PDU WTs that can be transmitted by the receiver in a row. Detailed Description \u00b6 Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization Author: Anton Vynohradov Email: avynohradov@systemfromscratch.com Copyright: Copyright (c) 2026 Anton Vynohradov @license MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. SPDX-License-Identifier: MIT Macro Definition Documentation \u00b6 define ISO_TP_DEFAULT_BLOCK_SIZE \u00b6 Max number of messages the receiver can receive at one time. #define ISO_TP_DEFAULT_BLOCK_SIZE `(8)` This value is affected by CAN driver queue length. define ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US \u00b6 Default timeout while waiting for a response during a multi-frame transfer. #define ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US `(100000)` define ISO_TP_DEFAULT_ST_MIN_US \u00b6 Minimum time gap allowed between consecutive frame N_PDUs. #define ISO_TP_DEFAULT_ST_MIN_US `(0)` define ISO_TP_FRAME_PADDING_VALUE \u00b6 Padding byte value when ISO_TP_FRAME_PADDING is enabled. #define ISO_TP_FRAME_PADDING_VALUE `(0xAA)` define ISO_TP_MAX_WFT_NUMBER \u00b6 Number of FC N_PDU WTs that can be transmitted by the receiver in a row. #define ISO_TP_MAX_WFT_NUMBER `(1)` The documentation for this class was generated from the following file inc/isotp_config.h","title":"File isotp_config.h"},{"location":"docs/isotp__config_8h/#file-isotp_configh","text":"FileList > inc > isotp_config.h Go to the source code of this file ISO-TP configuration parameters and feature toggles. More...","title":"File isotp_config.h"},{"location":"docs/isotp__config_8h/#macros","text":"Type Name define ISO_TP_DEFAULT_BLOCK_SIZE (8) Max number of messages the receiver can receive at one time. define ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US (100000) Default timeout while waiting for a response during a multi-frame transfer. define ISO_TP_DEFAULT_ST_MIN_US (0) Minimum time gap allowed between consecutive frame N_PDUs. define ISO_TP_FRAME_PADDING_VALUE (0xAA) Padding byte value when ISO_TP_FRAME_PADDING is enabled. define ISO_TP_MAX_WFT_NUMBER (1) Number of FC N_PDU WTs that can be transmitted by the receiver in a row.","title":"Macros"},{"location":"docs/isotp__config_8h/#detailed-description","text":"Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization Author: Anton Vynohradov Email: avynohradov@systemfromscratch.com Copyright: Copyright (c) 2026 Anton Vynohradov @license MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. SPDX-License-Identifier: MIT","title":"Detailed Description"},{"location":"docs/isotp__config_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"docs/isotp__config_8h/#define-iso_tp_default_block_size","text":"Max number of messages the receiver can receive at one time. #define ISO_TP_DEFAULT_BLOCK_SIZE `(8)` This value is affected by CAN driver queue length.","title":"define ISO_TP_DEFAULT_BLOCK_SIZE"},{"location":"docs/isotp__config_8h/#define-iso_tp_default_response_timeout_us","text":"Default timeout while waiting for a response during a multi-frame transfer. #define ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US `(100000)`","title":"define ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US"},{"location":"docs/isotp__config_8h/#define-iso_tp_default_st_min_us","text":"Minimum time gap allowed between consecutive frame N_PDUs. #define ISO_TP_DEFAULT_ST_MIN_US `(0)`","title":"define ISO_TP_DEFAULT_ST_MIN_US"},{"location":"docs/isotp__config_8h/#define-iso_tp_frame_padding_value","text":"Padding byte value when ISO_TP_FRAME_PADDING is enabled. #define ISO_TP_FRAME_PADDING_VALUE `(0xAA)`","title":"define ISO_TP_FRAME_PADDING_VALUE"},{"location":"docs/isotp__config_8h/#define-iso_tp_max_wft_number","text":"Number of FC N_PDU WTs that can be transmitted by the receiver in a row. #define ISO_TP_MAX_WFT_NUMBER `(1)` The documentation for this class was generated from the following file inc/isotp_config.h","title":"define ISO_TP_MAX_WFT_NUMBER"},{"location":"docs/isotp__config_8h_source/","text":"File isotp_config.h \u00b6 File List > inc > isotp_config.h Go to the documentation of this file #ifndef ISOTPC_CONFIG_H #define ISOTPC_CONFIG_H #ifndef ISO_TP_DEFAULT_BLOCK_SIZE #define ISO_TP_DEFAULT_BLOCK_SIZE (8) #endif #ifndef ISO_TP_DEFAULT_ST_MIN_US #define ISO_TP_DEFAULT_ST_MIN_US (0) #endif #ifndef ISO_TP_MAX_WFT_NUMBER #define ISO_TP_MAX_WFT_NUMBER (1) #endif #ifndef ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US #define ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US (100000) #endif /* #define ISO_TP_FRAME_PADDING */ #ifndef ISO_TP_FRAME_PADDING_VALUE #define ISO_TP_FRAME_PADDING_VALUE (0xAA) #endif /* #define ISO_TP_USER_SEND_CAN_ARG */ /* #define ISO_TP_TRANSMIT_COMPLETE_CALLBACK */ /* #define ISO_TP_RECEIVE_COMPLETE_CALLBACK */ #endif /* ISOTPC_CONFIG_H */","title":"File isotp_config.h"},{"location":"docs/isotp__config_8h_source/#file-isotp_configh","text":"File List > inc > isotp_config.h Go to the documentation of this file #ifndef ISOTPC_CONFIG_H #define ISOTPC_CONFIG_H #ifndef ISO_TP_DEFAULT_BLOCK_SIZE #define ISO_TP_DEFAULT_BLOCK_SIZE (8) #endif #ifndef ISO_TP_DEFAULT_ST_MIN_US #define ISO_TP_DEFAULT_ST_MIN_US (0) #endif #ifndef ISO_TP_MAX_WFT_NUMBER #define ISO_TP_MAX_WFT_NUMBER (1) #endif #ifndef ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US #define ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US (100000) #endif /* #define ISO_TP_FRAME_PADDING */ #ifndef ISO_TP_FRAME_PADDING_VALUE #define ISO_TP_FRAME_PADDING_VALUE (0xAA) #endif /* #define ISO_TP_USER_SEND_CAN_ARG */ /* #define ISO_TP_TRANSMIT_COMPLETE_CALLBACK */ /* #define ISO_TP_RECEIVE_COMPLETE_CALLBACK */ #endif /* ISOTPC_CONFIG_H */","title":"File isotp_config.h"},{"location":"docs/isotp__defines_8h/","text":"File isotp_defines.h \u00b6 FileList > inc > isotp_defines.h Go to the source code of this file Internal protocol definitions and type structures for ISO-TP. More... #include <stdint.h> Classes \u00b6 Type Name struct IsoTpCanMessage struct IsoTpConsecutiveFrame Consecutive frame layout. struct IsoTpDataArray struct IsoTpFirstFrameShort First frame (short) layout. struct IsoTpFlowControl Flow control frame layout. struct IsoTpPciType CAN frame definitions. struct IsoTpSingleFrame Single frame layout. Public Types \u00b6 Type Name enum IsoTpFlowStatus Protocol Control Information (PCI) flow control identifiers. enum IsoTpProtocolControlInformation Protocol-specific defines. enum IsoTpReceiveStatusTypes ISOTP receiver status. enum IsoTpSendStatusTypes ISOTP sender status. Public Functions \u00b6 Type Name ISOTP_PACKED_STRUCT ({ uint8_t set_to_zero_high :4;uint8_t type :4;uint8_t set_to_zero_low;uint32_t FF_DL;uint8_t data[2];} IsoTpFirstFrameLong) First frame (long) layout. Macros \u00b6 Type Name define ISOTP_INVALID_BS 0xFFFF Invalid block size marker. define ISOTP_MAX_ERROR_MSG_SIZE 128 Max number of characters allowed in an error message. define ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW -8 define ISOTP_PROTOCOL_RESULT_ERROR -9 define ISOTP_PROTOCOL_RESULT_INVALID_FS -5 define ISOTP_PROTOCOL_RESULT_OK 0 Network layer result codes. define ISOTP_PROTOCOL_RESULT_TIMEOUT_A -1 define ISOTP_PROTOCOL_RESULT_TIMEOUT_BS -2 define ISOTP_PROTOCOL_RESULT_TIMEOUT_CR -3 define ISOTP_PROTOCOL_RESULT_UNEXP_PDU -6 define ISOTP_PROTOCOL_RESULT_WFT_OVRN -7 define ISOTP_PROTOCOL_RESULT_WRONG_SN -4 define ISOTP_RET_ERROR -1 define ISOTP_RET_INPROGRESS -2 define ISOTP_RET_LENGTH -7 define ISOTP_RET_NOSPACE -8 define ISOTP_RET_NO_DATA -5 define ISOTP_RET_OK 0 Internal return codes. define ISOTP_RET_OVERFLOW -3 define ISOTP_RET_TIMEOUT -6 define ISOTP_RET_WRONG_SN -4 define IsoTpTimeAfter (a, b) ((int32\\_t) ((int32\\_t) (b) - (int32\\_t) (a)) &lt; 0) Returns true if time a is after time b . define LE32TOH (le) /* multi line expression */ Compiler-specific defines. Detailed Description \u00b6 Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization Author: Anton Vynohradov Email: avynohradov@systemfromscratch.com Copyright: Copyright (c) 2026 Anton Vynohradov @license MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. SPDX-License-Identifier: MIT Public Types Documentation \u00b6 enum IsoTpFlowStatus \u00b6 Protocol Control Information (PCI) flow control identifiers. enum IsoTpFlowStatus { PCI_FLOW_STATUS_CONTINUE = 0x0 , PCI_FLOW_STATUS_WAIT = 0x1 , PCI_FLOW_STATUS_OVERFLOW = 0x2 }; enum IsoTpProtocolControlInformation \u00b6 Protocol-specific defines. enum IsoTpProtocolControlInformation { ISOTP_PCI_TYPE_SINGLE = 0x0 , ISOTP_PCI_TYPE_FIRST_FRAME = 0x1 , TSOTP_PCI_TYPE_CONSECUTIVE_FRAME = 0x2 , ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME = 0x3 , ISOTP_PCI_TYPE_CONSECUTIVE_FRAME = 0x2 }; Protocol Control Information (PCI) types for identifying ISO-TP frames. enum IsoTpReceiveStatusTypes \u00b6 ISOTP receiver status. enum IsoTpReceiveStatusTypes { ISOTP_RECEIVE_STATUS_IDLE , ISOTP_RECEIVE_STATUS_INPROGRESS , ISOTP_RECEIVE_STATUS_FULL }; enum IsoTpSendStatusTypes \u00b6 ISOTP sender status. enum IsoTpSendStatusTypes { ISOTP_SEND_STATUS_IDLE , ISOTP_SEND_STATUS_INPROGRESS , ISOTP_SEND_STATUS_ERROR }; Public Functions Documentation \u00b6 function ISOTP_PACKED_STRUCT \u00b6 First frame (long) layout. ISOTP_PACKED_STRUCT ( { uint8_t set_to_zero_high : 4 ; uint8_t type : 4 ; uint8_t set_to_zero_low ; uint32_t FF_DL ; uint8_t data [ 2 ];} IsoTpFirstFrameLong ) +-------------------------+-----------------------+---------+---------+---------+---------+ | byte # 0 | byte # 1 | byte # 2 | byte # 3 | byte # 4 | byte # 5 | +-------------------------+-----------+-----------+---------+---------+---------+---------+ | nibble # 0 | nibble # 1 | nibble # 2 | nibble # 3 | ... | +-------------+-----------+-----------+-----------+---------------------------------------+ | PCIType = 1 | unused = 0 | escape sequence = 0 | FF_DL | +-------------+-----------+-----------------------+---------------------------------------+ Macro Definition Documentation \u00b6 define ISOTP_INVALID_BS \u00b6 Invalid block size marker. #define ISOTP_INVALID_BS `0xFFFF` define ISOTP_MAX_ERROR_MSG_SIZE \u00b6 Max number of characters allowed in an error message. #define ISOTP_MAX_ERROR_MSG_SIZE `128` define ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW \u00b6 #define ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW `-8` define ISOTP_PROTOCOL_RESULT_ERROR \u00b6 #define ISOTP_PROTOCOL_RESULT_ERROR `-9` define ISOTP_PROTOCOL_RESULT_INVALID_FS \u00b6 #define ISOTP_PROTOCOL_RESULT_INVALID_FS `-5` define ISOTP_PROTOCOL_RESULT_OK \u00b6 Network layer result codes. #define ISOTP_PROTOCOL_RESULT_OK `0` define ISOTP_PROTOCOL_RESULT_TIMEOUT_A \u00b6 #define ISOTP_PROTOCOL_RESULT_TIMEOUT_A `-1` define ISOTP_PROTOCOL_RESULT_TIMEOUT_BS \u00b6 #define ISOTP_PROTOCOL_RESULT_TIMEOUT_BS `-2` define ISOTP_PROTOCOL_RESULT_TIMEOUT_CR \u00b6 #define ISOTP_PROTOCOL_RESULT_TIMEOUT_CR `-3` define ISOTP_PROTOCOL_RESULT_UNEXP_PDU \u00b6 #define ISOTP_PROTOCOL_RESULT_UNEXP_PDU `-6` define ISOTP_PROTOCOL_RESULT_WFT_OVRN \u00b6 #define ISOTP_PROTOCOL_RESULT_WFT_OVRN `-7` define ISOTP_PROTOCOL_RESULT_WRONG_SN \u00b6 #define ISOTP_PROTOCOL_RESULT_WRONG_SN `-4` define ISOTP_RET_ERROR \u00b6 #define ISOTP_RET_ERROR `-1` define ISOTP_RET_INPROGRESS \u00b6 #define ISOTP_RET_INPROGRESS `-2` define ISOTP_RET_LENGTH \u00b6 #define ISOTP_RET_LENGTH `-7` define ISOTP_RET_NOSPACE \u00b6 #define ISOTP_RET_NOSPACE `-8` define ISOTP_RET_NO_DATA \u00b6 #define ISOTP_RET_NO_DATA `-5` define ISOTP_RET_OK \u00b6 Internal return codes. #define ISOTP_RET_OK `0` define ISOTP_RET_OVERFLOW \u00b6 #define ISOTP_RET_OVERFLOW `-3` define ISOTP_RET_TIMEOUT \u00b6 #define ISOTP_RET_TIMEOUT `-6` define ISOTP_RET_WRONG_SN \u00b6 #define ISOTP_RET_WRONG_SN `-4` define IsoTpTimeAfter \u00b6 Returns true if time a is after time b . #define IsoTpTimeAfter ( a , b ) ` (( int32_t ) (( int32_t ) ( b ) - ( int32_t ) ( a )) < 0 ) ` define LE32TOH \u00b6 Compiler-specific defines. #define LE32TOH ( le ) ` /* multi line expression */ ` OS-specific defines. Convert a 32-bit value from little-endian to host byte order. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"File isotp_defines.h"},{"location":"docs/isotp__defines_8h/#file-isotp_definesh","text":"FileList > inc > isotp_defines.h Go to the source code of this file Internal protocol definitions and type structures for ISO-TP. More... #include <stdint.h>","title":"File isotp_defines.h"},{"location":"docs/isotp__defines_8h/#classes","text":"Type Name struct IsoTpCanMessage struct IsoTpConsecutiveFrame Consecutive frame layout. struct IsoTpDataArray struct IsoTpFirstFrameShort First frame (short) layout. struct IsoTpFlowControl Flow control frame layout. struct IsoTpPciType CAN frame definitions. struct IsoTpSingleFrame Single frame layout.","title":"Classes"},{"location":"docs/isotp__defines_8h/#public-types","text":"Type Name enum IsoTpFlowStatus Protocol Control Information (PCI) flow control identifiers. enum IsoTpProtocolControlInformation Protocol-specific defines. enum IsoTpReceiveStatusTypes ISOTP receiver status. enum IsoTpSendStatusTypes ISOTP sender status.","title":"Public Types"},{"location":"docs/isotp__defines_8h/#public-functions","text":"Type Name ISOTP_PACKED_STRUCT ({ uint8_t set_to_zero_high :4;uint8_t type :4;uint8_t set_to_zero_low;uint32_t FF_DL;uint8_t data[2];} IsoTpFirstFrameLong) First frame (long) layout.","title":"Public Functions"},{"location":"docs/isotp__defines_8h/#macros","text":"Type Name define ISOTP_INVALID_BS 0xFFFF Invalid block size marker. define ISOTP_MAX_ERROR_MSG_SIZE 128 Max number of characters allowed in an error message. define ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW -8 define ISOTP_PROTOCOL_RESULT_ERROR -9 define ISOTP_PROTOCOL_RESULT_INVALID_FS -5 define ISOTP_PROTOCOL_RESULT_OK 0 Network layer result codes. define ISOTP_PROTOCOL_RESULT_TIMEOUT_A -1 define ISOTP_PROTOCOL_RESULT_TIMEOUT_BS -2 define ISOTP_PROTOCOL_RESULT_TIMEOUT_CR -3 define ISOTP_PROTOCOL_RESULT_UNEXP_PDU -6 define ISOTP_PROTOCOL_RESULT_WFT_OVRN -7 define ISOTP_PROTOCOL_RESULT_WRONG_SN -4 define ISOTP_RET_ERROR -1 define ISOTP_RET_INPROGRESS -2 define ISOTP_RET_LENGTH -7 define ISOTP_RET_NOSPACE -8 define ISOTP_RET_NO_DATA -5 define ISOTP_RET_OK 0 Internal return codes. define ISOTP_RET_OVERFLOW -3 define ISOTP_RET_TIMEOUT -6 define ISOTP_RET_WRONG_SN -4 define IsoTpTimeAfter (a, b) ((int32\\_t) ((int32\\_t) (b) - (int32\\_t) (a)) &lt; 0) Returns true if time a is after time b . define LE32TOH (le) /* multi line expression */ Compiler-specific defines.","title":"Macros"},{"location":"docs/isotp__defines_8h/#detailed-description","text":"Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization Author: Anton Vynohradov Email: avynohradov@systemfromscratch.com Copyright: Copyright (c) 2026 Anton Vynohradov @license MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. SPDX-License-Identifier: MIT","title":"Detailed Description"},{"location":"docs/isotp__defines_8h/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"docs/isotp__defines_8h/#enum-isotpflowstatus","text":"Protocol Control Information (PCI) flow control identifiers. enum IsoTpFlowStatus { PCI_FLOW_STATUS_CONTINUE = 0x0 , PCI_FLOW_STATUS_WAIT = 0x1 , PCI_FLOW_STATUS_OVERFLOW = 0x2 };","title":"enum IsoTpFlowStatus"},{"location":"docs/isotp__defines_8h/#enum-isotpprotocolcontrolinformation","text":"Protocol-specific defines. enum IsoTpProtocolControlInformation { ISOTP_PCI_TYPE_SINGLE = 0x0 , ISOTP_PCI_TYPE_FIRST_FRAME = 0x1 , TSOTP_PCI_TYPE_CONSECUTIVE_FRAME = 0x2 , ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME = 0x3 , ISOTP_PCI_TYPE_CONSECUTIVE_FRAME = 0x2 }; Protocol Control Information (PCI) types for identifying ISO-TP frames.","title":"enum IsoTpProtocolControlInformation"},{"location":"docs/isotp__defines_8h/#enum-isotpreceivestatustypes","text":"ISOTP receiver status. enum IsoTpReceiveStatusTypes { ISOTP_RECEIVE_STATUS_IDLE , ISOTP_RECEIVE_STATUS_INPROGRESS , ISOTP_RECEIVE_STATUS_FULL };","title":"enum IsoTpReceiveStatusTypes"},{"location":"docs/isotp__defines_8h/#enum-isotpsendstatustypes","text":"ISOTP sender status. enum IsoTpSendStatusTypes { ISOTP_SEND_STATUS_IDLE , ISOTP_SEND_STATUS_INPROGRESS , ISOTP_SEND_STATUS_ERROR };","title":"enum IsoTpSendStatusTypes"},{"location":"docs/isotp__defines_8h/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/isotp__defines_8h/#function-isotp_packed_struct","text":"First frame (long) layout. ISOTP_PACKED_STRUCT ( { uint8_t set_to_zero_high : 4 ; uint8_t type : 4 ; uint8_t set_to_zero_low ; uint32_t FF_DL ; uint8_t data [ 2 ];} IsoTpFirstFrameLong ) +-------------------------+-----------------------+---------+---------+---------+---------+ | byte # 0 | byte # 1 | byte # 2 | byte # 3 | byte # 4 | byte # 5 | +-------------------------+-----------+-----------+---------+---------+---------+---------+ | nibble # 0 | nibble # 1 | nibble # 2 | nibble # 3 | ... | +-------------+-----------+-----------+-----------+---------------------------------------+ | PCIType = 1 | unused = 0 | escape sequence = 0 | FF_DL | +-------------+-----------+-----------------------+---------------------------------------+","title":"function ISOTP_PACKED_STRUCT"},{"location":"docs/isotp__defines_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"docs/isotp__defines_8h/#define-isotp_invalid_bs","text":"Invalid block size marker. #define ISOTP_INVALID_BS `0xFFFF`","title":"define ISOTP_INVALID_BS"},{"location":"docs/isotp__defines_8h/#define-isotp_max_error_msg_size","text":"Max number of characters allowed in an error message. #define ISOTP_MAX_ERROR_MSG_SIZE `128`","title":"define ISOTP_MAX_ERROR_MSG_SIZE"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_buffer_ovflw","text":"#define ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW `-8`","title":"define ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_error","text":"#define ISOTP_PROTOCOL_RESULT_ERROR `-9`","title":"define ISOTP_PROTOCOL_RESULT_ERROR"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_invalid_fs","text":"#define ISOTP_PROTOCOL_RESULT_INVALID_FS `-5`","title":"define ISOTP_PROTOCOL_RESULT_INVALID_FS"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_ok","text":"Network layer result codes. #define ISOTP_PROTOCOL_RESULT_OK `0`","title":"define ISOTP_PROTOCOL_RESULT_OK"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_timeout_a","text":"#define ISOTP_PROTOCOL_RESULT_TIMEOUT_A `-1`","title":"define ISOTP_PROTOCOL_RESULT_TIMEOUT_A"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_timeout_bs","text":"#define ISOTP_PROTOCOL_RESULT_TIMEOUT_BS `-2`","title":"define ISOTP_PROTOCOL_RESULT_TIMEOUT_BS"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_timeout_cr","text":"#define ISOTP_PROTOCOL_RESULT_TIMEOUT_CR `-3`","title":"define ISOTP_PROTOCOL_RESULT_TIMEOUT_CR"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_unexp_pdu","text":"#define ISOTP_PROTOCOL_RESULT_UNEXP_PDU `-6`","title":"define ISOTP_PROTOCOL_RESULT_UNEXP_PDU"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_wft_ovrn","text":"#define ISOTP_PROTOCOL_RESULT_WFT_OVRN `-7`","title":"define ISOTP_PROTOCOL_RESULT_WFT_OVRN"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_wrong_sn","text":"#define ISOTP_PROTOCOL_RESULT_WRONG_SN `-4`","title":"define ISOTP_PROTOCOL_RESULT_WRONG_SN"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_error","text":"#define ISOTP_RET_ERROR `-1`","title":"define ISOTP_RET_ERROR"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_inprogress","text":"#define ISOTP_RET_INPROGRESS `-2`","title":"define ISOTP_RET_INPROGRESS"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_length","text":"#define ISOTP_RET_LENGTH `-7`","title":"define ISOTP_RET_LENGTH"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_nospace","text":"#define ISOTP_RET_NOSPACE `-8`","title":"define ISOTP_RET_NOSPACE"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_no_data","text":"#define ISOTP_RET_NO_DATA `-5`","title":"define ISOTP_RET_NO_DATA"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_ok","text":"Internal return codes. #define ISOTP_RET_OK `0`","title":"define ISOTP_RET_OK"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_overflow","text":"#define ISOTP_RET_OVERFLOW `-3`","title":"define ISOTP_RET_OVERFLOW"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_timeout","text":"#define ISOTP_RET_TIMEOUT `-6`","title":"define ISOTP_RET_TIMEOUT"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_wrong_sn","text":"#define ISOTP_RET_WRONG_SN `-4`","title":"define ISOTP_RET_WRONG_SN"},{"location":"docs/isotp__defines_8h/#define-isotptimeafter","text":"Returns true if time a is after time b . #define IsoTpTimeAfter ( a , b ) ` (( int32_t ) (( int32_t ) ( b ) - ( int32_t ) ( a )) < 0 ) `","title":"define IsoTpTimeAfter"},{"location":"docs/isotp__defines_8h/#define-le32toh","text":"Compiler-specific defines. #define LE32TOH ( le ) ` /* multi line expression */ ` OS-specific defines. Convert a 32-bit value from little-endian to host byte order. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"define LE32TOH"},{"location":"docs/isotp__defines_8h_source/","text":"File isotp_defines.h \u00b6 File List > inc > isotp_defines.h Go to the documentation of this file #ifndef ISOTPC_USER_DEFINITIONS_H #define ISOTPC_USER_DEFINITIONS_H #include <stdint.h> #ifdef __GNUC__ #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ #define ISOTP_BYTE_ORDER_LITTLE_ENDIAN #elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ #else #error \"unsupported byte ordering\" #endif #define ISOTP_PACKED_STRUCT(content) typedef struct __attribute__((packed)) content #endif #ifdef _MSC_VER #define ISOTP_PACKED_STRUCT(content) \\ __pragma(pack(push, 1)) typedef struct content __pragma(pack(pop)) #define snprintf _snprintf #include <windows.h> #define ISOTP_BYTE_ORDER_LITTLE_ENDIAN #define __builtin_bswap8 _byteswap_uint8 #define __builtin_bswap16 _byteswap_uint16 #define __builtin_bswap32 _byteswap_uint32 #define __builtin_bswap64 _byteswap_uint64 #endif #define LE32TOH(le) \\ ((uint32_t) (((le) << 24) | (((le) & 0x0000FF00) << 8) | (((le) & 0x00FF0000) >> 8) \\ | ((le) >> 24))) #define ISOTP_RET_OK 0 #define ISOTP_RET_ERROR -1 #define ISOTP_RET_INPROGRESS -2 #define ISOTP_RET_OVERFLOW -3 #define ISOTP_RET_WRONG_SN -4 #define ISOTP_RET_NO_DATA -5 #define ISOTP_RET_TIMEOUT -6 #define ISOTP_RET_LENGTH -7 #define ISOTP_RET_NOSPACE -8 #define IsoTpTimeAfter(a, b) ((int32_t) ((int32_t) (b) - (int32_t) (a)) < 0) #define ISOTP_INVALID_BS 0xFFFF #define ISOTP_MAX_ERROR_MSG_SIZE 128 typedef enum { ISOTP_SEND_STATUS_IDLE , ISOTP_SEND_STATUS_INPROGRESS , ISOTP_SEND_STATUS_ERROR , } IsoTpSendStatusTypes ; typedef enum { ISOTP_RECEIVE_STATUS_IDLE , ISOTP_RECEIVE_STATUS_INPROGRESS , ISOTP_RECEIVE_STATUS_FULL , } IsoTpReceiveStatusTypes ; #if defined(ISOTP_BYTE_ORDER_LITTLE_ENDIAN) typedef struct { uint8_t reserve_1 : 4 ; uint8_t type : 4 ; uint8_t reserve_2 [ 7 ]; } IsoTpPciType ; typedef struct { uint8_t SF_DL : 4 ; uint8_t type : 4 ; uint8_t data [ 7 ]; } IsoTpSingleFrame ; typedef struct { uint8_t FF_DL_high : 4 ; uint8_t type : 4 ; uint8_t FF_DL_low ; uint8_t data [ 6 ]; } IsoTpFirstFrameShort ; ISOTP_PACKED_STRUCT ({ uint8_t set_to_zero_high : 4 ; uint8_t type : 4 ; uint8_t set_to_zero_low ; uint32_t FF_DL ; uint8_t data [ 2 ]; } IsoTpFirstFrameLong ); typedef struct { uint8_t SN : 4 ; uint8_t type : 4 ; uint8_t data [ 7 ]; } IsoTpConsecutiveFrame ; typedef struct { uint8_t FS : 4 ; uint8_t type : 4 ; uint8_t BS ; uint8_t STmin ; uint8_t reserve [ 5 ]; } IsoTpFlowControl ; #else typedef struct { uint8_t type : 4 ; uint8_t reserve_1 : 4 ; uint8_t reserve_2 [ 7 ]; } IsoTpPciType ; typedef struct { uint8_t type : 4 ; uint8_t SF_DL : 4 ; uint8_t data [ 7 ]; } IsoTpSingleFrame ; typedef struct { uint8_t FF_DL_high : 4 ; uint8_t type : 4 ; uint8_t FF_DL_low ; uint8_t data [ 6 ]; } IsoTpFirstFrameShort ; ISOTP_PACKED_STRUCT ({ uint8_t set_to_zero_high : 4 ; uint8_t type : 4 ; uint8_t set_to_zero_low ; uint32_t FF_DL ; uint8_t data [ 2 ]; } IsoTpFirstFrameLong ); typedef struct { uint8_t type : 4 ; uint8_t SN : 4 ; uint8_t data [ 7 ]; } IsoTpConsecutiveFrame ; typedef struct { uint8_t type : 4 ; uint8_t FS : 4 ; uint8_t BS ; uint8_t STmin ; uint8_t reserve [ 5 ]; } IsoTpFlowControl ; #endif typedef struct { uint8_t ptr [ 8 ]; } IsoTpDataArray ; typedef struct { union { IsoTpPciType common ; IsoTpSingleFrame single_frame ; IsoTpFirstFrameShort first_frame_short ; IsoTpFirstFrameLong first_frame_long ; IsoTpConsecutiveFrame consecutive_frame ; IsoTpFlowControl flow_control ; IsoTpDataArray data_array ; } as ; } IsoTpCanMessage ; #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK typedef void ( * isotp_tx_done_cb )( void * link , uint32_t tx_size , void * user_arg ); #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK typedef void ( * isotp_rx_done_cb )( void * link , const uint8_t * data , uint32_t size , void * user_arg ); #endif typedef enum { ISOTP_PCI_TYPE_SINGLE = 0x0 , ISOTP_PCI_TYPE_FIRST_FRAME = 0x1 , TSOTP_PCI_TYPE_CONSECUTIVE_FRAME = 0x2 , ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME = 0x3 , ISOTP_PCI_TYPE_CONSECUTIVE_FRAME = 0x2 , } IsoTpProtocolControlInformation ; typedef enum { PCI_FLOW_STATUS_CONTINUE = 0x0 , PCI_FLOW_STATUS_WAIT = 0x1 , PCI_FLOW_STATUS_OVERFLOW = 0x2 } IsoTpFlowStatus ; #define ISOTP_PROTOCOL_RESULT_OK 0 #define ISOTP_PROTOCOL_RESULT_TIMEOUT_A -1 #define ISOTP_PROTOCOL_RESULT_TIMEOUT_BS -2 #define ISOTP_PROTOCOL_RESULT_TIMEOUT_CR -3 #define ISOTP_PROTOCOL_RESULT_WRONG_SN -4 #define ISOTP_PROTOCOL_RESULT_INVALID_FS -5 #define ISOTP_PROTOCOL_RESULT_UNEXP_PDU -6 #define ISOTP_PROTOCOL_RESULT_WFT_OVRN -7 #define ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW -8 #define ISOTP_PROTOCOL_RESULT_ERROR -9 #endif /* ISOTPC_USER_DEFINITIONS_H */","title":"File isotp_defines.h"},{"location":"docs/isotp__defines_8h_source/#file-isotp_definesh","text":"File List > inc > isotp_defines.h Go to the documentation of this file #ifndef ISOTPC_USER_DEFINITIONS_H #define ISOTPC_USER_DEFINITIONS_H #include <stdint.h> #ifdef __GNUC__ #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ #define ISOTP_BYTE_ORDER_LITTLE_ENDIAN #elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ #else #error \"unsupported byte ordering\" #endif #define ISOTP_PACKED_STRUCT(content) typedef struct __attribute__((packed)) content #endif #ifdef _MSC_VER #define ISOTP_PACKED_STRUCT(content) \\ __pragma(pack(push, 1)) typedef struct content __pragma(pack(pop)) #define snprintf _snprintf #include <windows.h> #define ISOTP_BYTE_ORDER_LITTLE_ENDIAN #define __builtin_bswap8 _byteswap_uint8 #define __builtin_bswap16 _byteswap_uint16 #define __builtin_bswap32 _byteswap_uint32 #define __builtin_bswap64 _byteswap_uint64 #endif #define LE32TOH(le) \\ ((uint32_t) (((le) << 24) | (((le) & 0x0000FF00) << 8) | (((le) & 0x00FF0000) >> 8) \\ | ((le) >> 24))) #define ISOTP_RET_OK 0 #define ISOTP_RET_ERROR -1 #define ISOTP_RET_INPROGRESS -2 #define ISOTP_RET_OVERFLOW -3 #define ISOTP_RET_WRONG_SN -4 #define ISOTP_RET_NO_DATA -5 #define ISOTP_RET_TIMEOUT -6 #define ISOTP_RET_LENGTH -7 #define ISOTP_RET_NOSPACE -8 #define IsoTpTimeAfter(a, b) ((int32_t) ((int32_t) (b) - (int32_t) (a)) < 0) #define ISOTP_INVALID_BS 0xFFFF #define ISOTP_MAX_ERROR_MSG_SIZE 128 typedef enum { ISOTP_SEND_STATUS_IDLE , ISOTP_SEND_STATUS_INPROGRESS , ISOTP_SEND_STATUS_ERROR , } IsoTpSendStatusTypes ; typedef enum { ISOTP_RECEIVE_STATUS_IDLE , ISOTP_RECEIVE_STATUS_INPROGRESS , ISOTP_RECEIVE_STATUS_FULL , } IsoTpReceiveStatusTypes ; #if defined(ISOTP_BYTE_ORDER_LITTLE_ENDIAN) typedef struct { uint8_t reserve_1 : 4 ; uint8_t type : 4 ; uint8_t reserve_2 [ 7 ]; } IsoTpPciType ; typedef struct { uint8_t SF_DL : 4 ; uint8_t type : 4 ; uint8_t data [ 7 ]; } IsoTpSingleFrame ; typedef struct { uint8_t FF_DL_high : 4 ; uint8_t type : 4 ; uint8_t FF_DL_low ; uint8_t data [ 6 ]; } IsoTpFirstFrameShort ; ISOTP_PACKED_STRUCT ({ uint8_t set_to_zero_high : 4 ; uint8_t type : 4 ; uint8_t set_to_zero_low ; uint32_t FF_DL ; uint8_t data [ 2 ]; } IsoTpFirstFrameLong ); typedef struct { uint8_t SN : 4 ; uint8_t type : 4 ; uint8_t data [ 7 ]; } IsoTpConsecutiveFrame ; typedef struct { uint8_t FS : 4 ; uint8_t type : 4 ; uint8_t BS ; uint8_t STmin ; uint8_t reserve [ 5 ]; } IsoTpFlowControl ; #else typedef struct { uint8_t type : 4 ; uint8_t reserve_1 : 4 ; uint8_t reserve_2 [ 7 ]; } IsoTpPciType ; typedef struct { uint8_t type : 4 ; uint8_t SF_DL : 4 ; uint8_t data [ 7 ]; } IsoTpSingleFrame ; typedef struct { uint8_t FF_DL_high : 4 ; uint8_t type : 4 ; uint8_t FF_DL_low ; uint8_t data [ 6 ]; } IsoTpFirstFrameShort ; ISOTP_PACKED_STRUCT ({ uint8_t set_to_zero_high : 4 ; uint8_t type : 4 ; uint8_t set_to_zero_low ; uint32_t FF_DL ; uint8_t data [ 2 ]; } IsoTpFirstFrameLong ); typedef struct { uint8_t type : 4 ; uint8_t SN : 4 ; uint8_t data [ 7 ]; } IsoTpConsecutiveFrame ; typedef struct { uint8_t type : 4 ; uint8_t FS : 4 ; uint8_t BS ; uint8_t STmin ; uint8_t reserve [ 5 ]; } IsoTpFlowControl ; #endif typedef struct { uint8_t ptr [ 8 ]; } IsoTpDataArray ; typedef struct { union { IsoTpPciType common ; IsoTpSingleFrame single_frame ; IsoTpFirstFrameShort first_frame_short ; IsoTpFirstFrameLong first_frame_long ; IsoTpConsecutiveFrame consecutive_frame ; IsoTpFlowControl flow_control ; IsoTpDataArray data_array ; } as ; } IsoTpCanMessage ; #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK typedef void ( * isotp_tx_done_cb )( void * link , uint32_t tx_size , void * user_arg ); #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK typedef void ( * isotp_rx_done_cb )( void * link , const uint8_t * data , uint32_t size , void * user_arg ); #endif typedef enum { ISOTP_PCI_TYPE_SINGLE = 0x0 , ISOTP_PCI_TYPE_FIRST_FRAME = 0x1 , TSOTP_PCI_TYPE_CONSECUTIVE_FRAME = 0x2 , ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME = 0x3 , ISOTP_PCI_TYPE_CONSECUTIVE_FRAME = 0x2 , } IsoTpProtocolControlInformation ; typedef enum { PCI_FLOW_STATUS_CONTINUE = 0x0 , PCI_FLOW_STATUS_WAIT = 0x1 , PCI_FLOW_STATUS_OVERFLOW = 0x2 } IsoTpFlowStatus ; #define ISOTP_PROTOCOL_RESULT_OK 0 #define ISOTP_PROTOCOL_RESULT_TIMEOUT_A -1 #define ISOTP_PROTOCOL_RESULT_TIMEOUT_BS -2 #define ISOTP_PROTOCOL_RESULT_TIMEOUT_CR -3 #define ISOTP_PROTOCOL_RESULT_WRONG_SN -4 #define ISOTP_PROTOCOL_RESULT_INVALID_FS -5 #define ISOTP_PROTOCOL_RESULT_UNEXP_PDU -6 #define ISOTP_PROTOCOL_RESULT_WFT_OVRN -7 #define ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW -8 #define ISOTP_PROTOCOL_RESULT_ERROR -9 #endif /* ISOTPC_USER_DEFINITIONS_H */","title":"File isotp_defines.h"},{"location":"docs/isotp__user_8h/","text":"File isotp_user.h \u00b6 FileList > inc > isotp_user.h Go to the source code of this file User callback interfaces and platform abstraction layer. More... #include <stdint.h> Detailed Description \u00b6 Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization Author: Anton Vynohradov Email: avynohradov@systemfromscratch.com Copyright: Copyright (c) 2026 Anton Vynohradov @license MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. SPDX-License-Identifier: MIT The documentation for this class was generated from the following file inc/isotp_user.h","title":"File isotp_user.h"},{"location":"docs/isotp__user_8h/#file-isotp_userh","text":"FileList > inc > isotp_user.h Go to the source code of this file User callback interfaces and platform abstraction layer. More... #include <stdint.h>","title":"File isotp_user.h"},{"location":"docs/isotp__user_8h/#detailed-description","text":"Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization Author: Anton Vynohradov Email: avynohradov@systemfromscratch.com Copyright: Copyright (c) 2026 Anton Vynohradov @license MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. SPDX-License-Identifier: MIT The documentation for this class was generated from the following file inc/isotp_user.h","title":"Detailed Description"},{"location":"docs/isotp__user_8h_source/","text":"File isotp_user.h \u00b6 File List > inc > isotp_user.h Go to the documentation of this file #ifndef ISOTPC_USER_H #define ISOTPC_USER_H #include <stdint.h> #ifdef __cplusplus extern \"C\" { #endif void isotp_user_debug ( const char * message , ...); int isotp_user_send_can ( const uint32_t arbitration_id , const uint8_t * data , const uint8_t size #ifdef ISO_TP_USER_SEND_CAN_ARG , void * arg #endif ); uint32_t isotp_user_get_us ( void ); #ifdef __cplusplus } #endif #endif /* ISOTPC_USER_H */","title":"File isotp_user.h"},{"location":"docs/isotp__user_8h_source/#file-isotp_userh","text":"File List > inc > isotp_user.h Go to the documentation of this file #ifndef ISOTPC_USER_H #define ISOTPC_USER_H #include <stdint.h> #ifdef __cplusplus extern \"C\" { #endif void isotp_user_debug ( const char * message , ...); int isotp_user_send_can ( const uint32_t arbitration_id , const uint8_t * data , const uint8_t size #ifdef ISO_TP_USER_SEND_CAN_ARG , void * arg #endif ); uint32_t isotp_user_get_us ( void ); #ifdef __cplusplus } #endif #endif /* ISOTPC_USER_H */","title":"File isotp_user.h"},{"location":"docs/isotp_8h/","text":"File isotp.h \u00b6 FileList > isotp.h Go to the source code of this file Core ISO-TP protocol API with link management and message handling. More... #include <stdint.h> #include <stdbool.h> #include <stddef.h> #include <stdio.h> #include <string.h> #include \"isotp_config.h\" #include \"isotp_defines.h\" #include \"isotp_user.h\" Classes \u00b6 Type Name struct IsoTpLink Link state for a single ISO-TP connection. Detailed Description \u00b6 Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization Author: Anton Vynohradov Email: avynohradov@systemfromscratch.com Copyright: Copyright (c) 2026 Anton Vynohradov @license MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. SPDX-License-Identifier: MIT The documentation for this class was generated from the following file isotp.h","title":"File isotp.h"},{"location":"docs/isotp_8h/#file-isotph","text":"FileList > isotp.h Go to the source code of this file Core ISO-TP protocol API with link management and message handling. More... #include <stdint.h> #include <stdbool.h> #include <stddef.h> #include <stdio.h> #include <string.h> #include \"isotp_config.h\" #include \"isotp_defines.h\" #include \"isotp_user.h\"","title":"File isotp.h"},{"location":"docs/isotp_8h/#classes","text":"Type Name struct IsoTpLink Link state for a single ISO-TP connection.","title":"Classes"},{"location":"docs/isotp_8h/#detailed-description","text":"Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization Author: Anton Vynohradov Email: avynohradov@systemfromscratch.com Copyright: Copyright (c) 2026 Anton Vynohradov @license MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. SPDX-License-Identifier: MIT The documentation for this class was generated from the following file isotp.h","title":"Detailed Description"},{"location":"docs/isotp_8h_source/","text":"File isotp.h \u00b6 File List > isotp.h Go to the documentation of this file #ifndef ISOTPC_H #define ISOTPC_H #include <stdint.h> #include <stdbool.h> #include <stddef.h> #include <stdio.h> #include <string.h> #ifdef __cplusplus extern \"C\" { #endif #include \"isotp_config.h\" #include \"isotp_defines.h\" #include \"isotp_user.h\" typedef struct IsoTpLink { /* sender parameters */ uint32_t send_arbitration_id ; /* message buffer */ uint8_t * send_buffer ; uint32_t send_buf_size ; uint32_t send_size ; uint32_t send_offset ; /* multi-frame flags */ uint8_t send_sn ; uint32_t send_bs_remain ; uint32_t send_st_min_us ; uint8_t send_wtf_count ; uint32_t send_timer_st ; uint32_t send_timer_bs ; int32_t send_protocol_result ; uint8_t send_status ; /* receiver parameters */ uint32_t receive_arbitration_id ; /* message buffer */ uint8_t * receive_buffer ; uint32_t receive_buf_size ; uint32_t receive_size ; uint32_t receive_offset ; /* multi-frame control */ uint8_t receive_sn ; uint8_t receive_bs_count ; uint32_t receive_timer_cr ; int receive_protocol_result ; uint8_t receive_status ; #if defined(ISO_TP_USER_SEND_CAN_ARG) void * user_send_can_arg ; #endif #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK isotp_tx_done_cb tx_done_cb ; void * tx_done_cb_arg ; #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK isotp_rx_done_cb rx_done_cb ; void * rx_done_cb_arg ; #endif } IsoTpLink ; void isotp_init_link ( IsoTpLink * link , uint32_t sendid , uint8_t * sendbuf , uint32_t sendbufsize , uint8_t * recvbuf , uint32_t recvbufsize ); void isotp_destroy_link ( IsoTpLink * link ); void isotp_poll ( IsoTpLink * link ); void isotp_on_can_message ( IsoTpLink * link , const uint8_t * data , uint8_t len ); int isotp_send ( IsoTpLink * link , const uint8_t payload [], uint32_t size ); int isotp_send_with_id ( IsoTpLink * link , uint32_t id , const uint8_t payload [], uint32_t size ); int isotp_receive ( IsoTpLink * link , uint8_t * payload , const uint32_t payload_size , uint32_t * out_size ); #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK void isotp_set_tx_done_cb ( IsoTpLink * link , isotp_tx_done_cb cb , void * arg ); #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK void isotp_set_rx_done_cb ( IsoTpLink * link , isotp_rx_done_cb cb , void * arg ); #endif #ifdef __cplusplus } #endif #endif /* ISOTPC_H */","title":"File isotp.h"},{"location":"docs/isotp_8h_source/#file-isotph","text":"File List > isotp.h Go to the documentation of this file #ifndef ISOTPC_H #define ISOTPC_H #include <stdint.h> #include <stdbool.h> #include <stddef.h> #include <stdio.h> #include <string.h> #ifdef __cplusplus extern \"C\" { #endif #include \"isotp_config.h\" #include \"isotp_defines.h\" #include \"isotp_user.h\" typedef struct IsoTpLink { /* sender parameters */ uint32_t send_arbitration_id ; /* message buffer */ uint8_t * send_buffer ; uint32_t send_buf_size ; uint32_t send_size ; uint32_t send_offset ; /* multi-frame flags */ uint8_t send_sn ; uint32_t send_bs_remain ; uint32_t send_st_min_us ; uint8_t send_wtf_count ; uint32_t send_timer_st ; uint32_t send_timer_bs ; int32_t send_protocol_result ; uint8_t send_status ; /* receiver parameters */ uint32_t receive_arbitration_id ; /* message buffer */ uint8_t * receive_buffer ; uint32_t receive_buf_size ; uint32_t receive_size ; uint32_t receive_offset ; /* multi-frame control */ uint8_t receive_sn ; uint8_t receive_bs_count ; uint32_t receive_timer_cr ; int receive_protocol_result ; uint8_t receive_status ; #if defined(ISO_TP_USER_SEND_CAN_ARG) void * user_send_can_arg ; #endif #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK isotp_tx_done_cb tx_done_cb ; void * tx_done_cb_arg ; #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK isotp_rx_done_cb rx_done_cb ; void * rx_done_cb_arg ; #endif } IsoTpLink ; void isotp_init_link ( IsoTpLink * link , uint32_t sendid , uint8_t * sendbuf , uint32_t sendbufsize , uint8_t * recvbuf , uint32_t recvbufsize ); void isotp_destroy_link ( IsoTpLink * link ); void isotp_poll ( IsoTpLink * link ); void isotp_on_can_message ( IsoTpLink * link , const uint8_t * data , uint8_t len ); int isotp_send ( IsoTpLink * link , const uint8_t payload [], uint32_t size ); int isotp_send_with_id ( IsoTpLink * link , uint32_t id , const uint8_t payload [], uint32_t size ); int isotp_receive ( IsoTpLink * link , uint8_t * payload , const uint32_t payload_size , uint32_t * out_size ); #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK void isotp_set_tx_done_cb ( IsoTpLink * link , isotp_tx_done_cb cb , void * arg ); #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK void isotp_set_rx_done_cb ( IsoTpLink * link , isotp_rx_done_cb cb , void * arg ); #endif #ifdef __cplusplus } #endif #endif /* ISOTPC_H */","title":"File isotp.h"},{"location":"docs/dir_68267d1309a1af8e8297ef4c3efbcdba/","text":"Dir src \u00b6 FileList > src Files \u00b6 Type Name file isotp.c The documentation for this class was generated from the following file src/","title":"Dir src"},{"location":"docs/dir_68267d1309a1af8e8297ef4c3efbcdba/#dir-src","text":"FileList > src","title":"Dir src"},{"location":"docs/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","text":"Type Name file isotp.c The documentation for this class was generated from the following file src/","title":"Files"},{"location":"docs/isotp_8c/","text":"File isotp.c \u00b6 FileList > src > isotp.c Go to the source code of this file #include <assert.h> #include <stdint.h> #include \"isotp.h\" Public Static Functions \u00b6 Type Name int isotp_receive_consecutive_frame ( IsoTpLink * link, const IsoTpCanMessage * message, uint8_t len) Receive ISO-TP consecutive frame. int isotp_receive_first_frame ( IsoTpLink * link, IsoTpCanMessage * message, uint8_t len) Receive ISO-TP first frame of multi-frame message. int isotp_receive_flow_control_frame ( IsoTpLink * link, IsoTpCanMessage * message, uint8_t len) Receive ISO-TP flow control frame. int isotp_receive_single_frame ( IsoTpLink * link, const IsoTpCanMessage * message, uint8_t len) Receive ISO-TP single frame. int isotp_send_consecutive_frame ( IsoTpLink * link) Send ISO-TP consecutive frame. int isotp_send_first_frame ( IsoTpLink * link, uint32_t id) Send ISO-TP first frame of multi-frame message. int isotp_send_flow_control (const IsoTpLink * link, uint8_t flow_status, uint8_t block_size, uint32_t st_min_us) Send ISO-TP flow control frame. int isotp_send_single_frame (const IsoTpLink * link, uint32_t id) Send ISO-TP single frame. uint32_t isotp_st_min_to_us (uint8_t st_min) Convert ST_min encoding format to microseconds. uint8_t isotp_us_to_st_min (uint32_t us) Convert microseconds to ST_min encoding format. Public Static Functions Documentation \u00b6 function isotp_receive_consecutive_frame \u00b6 Receive ISO-TP consecutive frame. static int isotp_receive_consecutive_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ) Parameters: link - ISO-TP link instance message - Received CAN message len - Message length in bytes Returns: ISOTP_RET_OK on success, error code on failure function isotp_receive_first_frame \u00b6 Receive ISO-TP first frame of multi-frame message. static int isotp_receive_first_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ) Parameters: link - ISO-TP link instance message - Received CAN message len - Message length in bytes Returns: ISOTP_RET_OK on success, error code on failure function isotp_receive_flow_control_frame \u00b6 Receive ISO-TP flow control frame. static int isotp_receive_flow_control_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ) Parameters: link - ISO-TP link instance message - Received CAN message len - Message length in bytes Returns: ISOTP_RET_OK on success, error code on failure function isotp_receive_single_frame \u00b6 Receive ISO-TP single frame. static int isotp_receive_single_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ) Parameters: link - ISO-TP link instance message - Received CAN message len - Message length in bytes Returns: ISOTP_RET_OK on success, error code on failure function isotp_send_consecutive_frame \u00b6 Send ISO-TP consecutive frame. static int isotp_send_consecutive_frame ( IsoTpLink * link ) Parameters: link - ISO-TP link instance Returns: ISOTP_RET_OK on success, error code on failure function isotp_send_first_frame \u00b6 Send ISO-TP first frame of multi-frame message. static int isotp_send_first_frame ( IsoTpLink * link , uint32_t id ) Parameters: link - ISO-TP link instance id - CAN arbitration ID Returns: ISOTP_RET_OK on success, error code on failure function isotp_send_flow_control \u00b6 Send ISO-TP flow control frame. static int isotp_send_flow_control ( const IsoTpLink * link , uint8_t flow_status , uint8_t block_size , uint32_t st_min_us ) Parameters: link - ISO-TP link instance flow_status - Flow control status block_size - Block size for flow control st_min_us - Minimum separation time in microseconds Returns: ISOTP_RET_OK on success, error code on failure function isotp_send_single_frame \u00b6 Send ISO-TP single frame. static int isotp_send_single_frame ( const IsoTpLink * link , uint32_t id ) Parameters: link - ISO-TP link instance id - CAN arbitration ID Returns: ISOTP_RET_OK on success, error code on failure function isotp_st_min_to_us \u00b6 Convert ST_min encoding format to microseconds. static uint32_t isotp_st_min_to_us ( uint8_t st_min ) Parameters: st_min - Encoded ST_min value Returns: Time in microseconds function isotp_us_to_st_min \u00b6 Convert microseconds to ST_min encoding format. static uint8_t isotp_us_to_st_min ( uint32_t us ) Parameters: us - Time in microseconds Returns: Encoded ST_min value The documentation for this class was generated from the following file src/isotp.c","title":"File isotp.c"},{"location":"docs/isotp_8c/#file-isotpc","text":"FileList > src > isotp.c Go to the source code of this file #include <assert.h> #include <stdint.h> #include \"isotp.h\"","title":"File isotp.c"},{"location":"docs/isotp_8c/#public-static-functions","text":"Type Name int isotp_receive_consecutive_frame ( IsoTpLink * link, const IsoTpCanMessage * message, uint8_t len) Receive ISO-TP consecutive frame. int isotp_receive_first_frame ( IsoTpLink * link, IsoTpCanMessage * message, uint8_t len) Receive ISO-TP first frame of multi-frame message. int isotp_receive_flow_control_frame ( IsoTpLink * link, IsoTpCanMessage * message, uint8_t len) Receive ISO-TP flow control frame. int isotp_receive_single_frame ( IsoTpLink * link, const IsoTpCanMessage * message, uint8_t len) Receive ISO-TP single frame. int isotp_send_consecutive_frame ( IsoTpLink * link) Send ISO-TP consecutive frame. int isotp_send_first_frame ( IsoTpLink * link, uint32_t id) Send ISO-TP first frame of multi-frame message. int isotp_send_flow_control (const IsoTpLink * link, uint8_t flow_status, uint8_t block_size, uint32_t st_min_us) Send ISO-TP flow control frame. int isotp_send_single_frame (const IsoTpLink * link, uint32_t id) Send ISO-TP single frame. uint32_t isotp_st_min_to_us (uint8_t st_min) Convert ST_min encoding format to microseconds. uint8_t isotp_us_to_st_min (uint32_t us) Convert microseconds to ST_min encoding format.","title":"Public Static Functions"},{"location":"docs/isotp_8c/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"docs/isotp_8c/#function-isotp_receive_consecutive_frame","text":"Receive ISO-TP consecutive frame. static int isotp_receive_consecutive_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ) Parameters: link - ISO-TP link instance message - Received CAN message len - Message length in bytes Returns: ISOTP_RET_OK on success, error code on failure","title":"function isotp_receive_consecutive_frame"},{"location":"docs/isotp_8c/#function-isotp_receive_first_frame","text":"Receive ISO-TP first frame of multi-frame message. static int isotp_receive_first_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ) Parameters: link - ISO-TP link instance message - Received CAN message len - Message length in bytes Returns: ISOTP_RET_OK on success, error code on failure","title":"function isotp_receive_first_frame"},{"location":"docs/isotp_8c/#function-isotp_receive_flow_control_frame","text":"Receive ISO-TP flow control frame. static int isotp_receive_flow_control_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ) Parameters: link - ISO-TP link instance message - Received CAN message len - Message length in bytes Returns: ISOTP_RET_OK on success, error code on failure","title":"function isotp_receive_flow_control_frame"},{"location":"docs/isotp_8c/#function-isotp_receive_single_frame","text":"Receive ISO-TP single frame. static int isotp_receive_single_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ) Parameters: link - ISO-TP link instance message - Received CAN message len - Message length in bytes Returns: ISOTP_RET_OK on success, error code on failure","title":"function isotp_receive_single_frame"},{"location":"docs/isotp_8c/#function-isotp_send_consecutive_frame","text":"Send ISO-TP consecutive frame. static int isotp_send_consecutive_frame ( IsoTpLink * link ) Parameters: link - ISO-TP link instance Returns: ISOTP_RET_OK on success, error code on failure","title":"function isotp_send_consecutive_frame"},{"location":"docs/isotp_8c/#function-isotp_send_first_frame","text":"Send ISO-TP first frame of multi-frame message. static int isotp_send_first_frame ( IsoTpLink * link , uint32_t id ) Parameters: link - ISO-TP link instance id - CAN arbitration ID Returns: ISOTP_RET_OK on success, error code on failure","title":"function isotp_send_first_frame"},{"location":"docs/isotp_8c/#function-isotp_send_flow_control","text":"Send ISO-TP flow control frame. static int isotp_send_flow_control ( const IsoTpLink * link , uint8_t flow_status , uint8_t block_size , uint32_t st_min_us ) Parameters: link - ISO-TP link instance flow_status - Flow control status block_size - Block size for flow control st_min_us - Minimum separation time in microseconds Returns: ISOTP_RET_OK on success, error code on failure","title":"function isotp_send_flow_control"},{"location":"docs/isotp_8c/#function-isotp_send_single_frame","text":"Send ISO-TP single frame. static int isotp_send_single_frame ( const IsoTpLink * link , uint32_t id ) Parameters: link - ISO-TP link instance id - CAN arbitration ID Returns: ISOTP_RET_OK on success, error code on failure","title":"function isotp_send_single_frame"},{"location":"docs/isotp_8c/#function-isotp_st_min_to_us","text":"Convert ST_min encoding format to microseconds. static uint32_t isotp_st_min_to_us ( uint8_t st_min ) Parameters: st_min - Encoded ST_min value Returns: Time in microseconds","title":"function isotp_st_min_to_us"},{"location":"docs/isotp_8c/#function-isotp_us_to_st_min","text":"Convert microseconds to ST_min encoding format. static uint8_t isotp_us_to_st_min ( uint32_t us ) Parameters: us - Time in microseconds Returns: Encoded ST_min value The documentation for this class was generated from the following file src/isotp.c","title":"function isotp_us_to_st_min"},{"location":"docs/isotp_8c_source/","text":"File isotp.c \u00b6 File List > src > isotp.c Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Core ISO-TP protocol implementation with multi-frame support * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <assert.h> #include <stdint.h> #include \"isotp.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ static uint8_t isotp_us_to_st_min ( uint32_t us ); static uint32_t isotp_st_min_to_us ( uint8_t st_min ); static int isotp_send_flow_control ( const IsoTpLink * link , uint8_t flow_status , uint8_t block_size , uint32_t st_min_us ); static int isotp_send_single_frame ( const IsoTpLink * link , uint32_t id ); static int isotp_send_first_frame ( IsoTpLink * link , uint32_t id ); static int isotp_send_consecutive_frame ( IsoTpLink * link ); static int isotp_receive_single_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ); static int isotp_receive_first_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ); static int isotp_receive_consecutive_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ); static int isotp_receive_flow_control_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ); /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* st_min to microsecond */ static uint8_t isotp_us_to_st_min ( uint32_t us ) { // ISO 15765-2:2016 defines STmin encoding: // 0x00..0x7F: value in milliseconds (0..127 ms) // 0xF1..0xF9: value in 100 microsecond steps (100..900 us) const uint32_t STMIN_MS_MAX = 127000 ; // 127 ms in us const uint32_t STMIN_US_MIN = 100 ; // 100 us const uint32_t STMIN_US_MAX = 900 ; // 900 us const uint8_t STMIN_US_BASE = 0xF0 ; // base for 100us steps if ( us <= STMIN_MS_MAX ) { if ( us >= STMIN_US_MIN && us <= STMIN_US_MAX ) { return ( uint8_t ) ( STMIN_US_BASE + ( us / 100 )); } else { return ( uint8_t ) ( us / 1000u ); } } return 0 ; } /* st_min to usec */ static uint32_t isotp_st_min_to_us ( uint8_t st_min ) { // ISO 15765-2:2016 defines STmin encoding: // 0x00..0x7F: value in milliseconds (0..127 ms) // 0xF1..0xF9: value in 100 microsecond steps (100..900 us) const uint8_t STMIN_MS_MAX = 0x7F ; // 127 ms const uint8_t STMIN_US_MIN_CODE = 0xF1 ; // 100 us const uint8_t STMIN_US_MAX_CODE = 0xF9 ; // 900 us const uint8_t STMIN_US_BASE = 0xF0 ; // base for 100us steps const uint32_t US_PER_MS = 1000 ; const uint32_t US_STEP = 100 ; if ( st_min <= STMIN_MS_MAX ) { return st_min * US_PER_MS ; } else if ( st_min >= STMIN_US_MIN_CODE && st_min <= STMIN_US_MAX_CODE ) { return ( st_min - STMIN_US_BASE ) * US_STEP ; } return 0 ; } static int isotp_send_flow_control ( const IsoTpLink * link , uint8_t flow_status , uint8_t block_size , uint32_t st_min_us ) { IsoTpCanMessage message ; ( void ) memset ( & message , 0 , sizeof ( message )); int ret ; uint8_t size = 0 ; /* setup message */ message . as . flow_control . type = ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME ; message . as . flow_control . FS = flow_status ; message . as . flow_control . BS = block_size ; message . as . flow_control . STmin = isotp_us_to_st_min ( st_min_us ); /* send message */ #ifdef ISO_TP_FRAME_PADDING ( void ) memset ( message . as . flow_control . reserve , ISO_TP_FRAME_PADDING_VALUE , sizeof ( message . as . flow_control . reserve )); size = sizeof ( message ); #else size = 3 ; #endif ret = isotp_user_send_can ( link -> send_arbitration_id , message . as . data_array . ptr , size #if defined(ISO_TP_USER_SEND_CAN_ARG) , link -> user_send_can_arg #endif ); return ret ; } static int isotp_send_single_frame ( const IsoTpLink * link , uint32_t id ) { ( void ) id ; // Prevent unused variable warning IsoTpCanMessage message ; int ret ; uint8_t size = 0 ; /* multi frame message length must greater than 7 */ assert ( link -> send_size <= 7 ); /* setup message */ message . as . single_frame . type = ISOTP_PCI_TYPE_SINGLE ; message . as . single_frame . SF_DL = ( uint8_t ) link -> send_size ; ( void ) memcpy ( message . as . single_frame . data , link -> send_buffer , link -> send_size ); /* send message */ #ifdef ISO_TP_FRAME_PADDING ( void ) memset ( message . as . single_frame . data + link -> send_size , ISO_TP_FRAME_PADDING_VALUE , sizeof ( message . as . single_frame . data ) - link -> send_size ); size = sizeof ( message ); #else size = link -> send_size + ( uint8_t ) 1 ; #endif ret = isotp_user_send_can ( link -> send_arbitration_id , message . as . data_array . ptr , size #if defined(ISO_TP_USER_SEND_CAN_ARG) , link -> user_send_can_arg #endif ); return ret ; } static int isotp_send_first_frame ( IsoTpLink * link , uint32_t id ) { IsoTpCanMessage message = { 0 }; int ret = 0 ; /* multi frame message length must greater than 7 */ assert ( link -> send_size > 7 ); if ( link -> send_size <= 4095 ) { /* setup 'short' message */ message . as . first_frame_short . type = ISOTP_PCI_TYPE_FIRST_FRAME ; message . as . first_frame_short . FF_DL_low = ( uint8_t ) link -> send_size ; message . as . first_frame_short . FF_DL_high = ( uint8_t ) ( 0x0F & ( link -> send_size >> 8 )); ( void ) memcpy ( message . as . first_frame_short . data , link -> send_buffer , sizeof ( message . as . first_frame_short . data )); /* send 'short' message */ ret = isotp_user_send_can ( id , message . as . data_array . ptr , sizeof ( message ) #if defined(ISO_TP_USER_SEND_CAN_ARG) , link -> user_send_can_arg #endif ); if ( ISOTP_RET_OK == ret ) { link -> send_offset += sizeof ( message . as . first_frame_short . data ); } } else { // ISO15765-2:2016 /* setup 'long' message */ message . as . first_frame_long . set_to_zero_high = 0 ; message . as . first_frame_long . set_to_zero_low = 0 ; message . as . first_frame_long . type = ISOTP_PCI_TYPE_FIRST_FRAME ; message . as . first_frame_long . FF_DL = LE32TOH ( link -> send_size ); ( void ) memcpy ( message . as . first_frame_long . data , link -> send_buffer , sizeof ( message . as . first_frame_long . data )); /* send 'long' message */ ret = isotp_user_send_can ( id , message . as . data_array . ptr , sizeof ( message ) #if defined(ISO_TP_USER_SEND_CAN_ARG) , link -> user_send_can_arg #endif ); if ( ISOTP_RET_OK == ret ) { link -> send_offset += sizeof ( message . as . first_frame_long . data ); } } link -> send_sn = 1 ; return ret ; } static int isotp_send_consecutive_frame ( IsoTpLink * link ) { IsoTpCanMessage message ; uint32_t data_length ; int ret ; uint8_t size = 0 ; /* multi frame message length must greater than 7 */ assert ( link -> send_size > 7 ); /* setup message */ message . as . consecutive_frame . type = ISOTP_PCI_TYPE_CONSECUTIVE_FRAME ; message . as . consecutive_frame . SN = link -> send_sn ; data_length = link -> send_size - link -> send_offset ; if ( data_length > sizeof ( message . as . consecutive_frame . data )) { data_length = sizeof ( message . as . consecutive_frame . data ); } ( void ) memcpy ( message . as . consecutive_frame . data , link -> send_buffer + link -> send_offset , data_length ); /* send message */ #ifdef ISO_TP_FRAME_PADDING ( void ) memset ( message . as . consecutive_frame . data + data_length , ISO_TP_FRAME_PADDING_VALUE , sizeof ( message . as . consecutive_frame . data ) - data_length ); size = sizeof ( message ); #else size = data_length + 1 ; #endif ret = isotp_user_send_can ( link -> send_arbitration_id , message . as . data_array . ptr , size #if defined(ISO_TP_USER_SEND_CAN_ARG) , link -> user_send_can_arg #endif ); if ( ISOTP_RET_OK == ret ) { link -> send_offset += data_length ; if ( ++ ( link -> send_sn ) > 0x0F ) { link -> send_sn = 0 ; } } return ret ; } static int isotp_receive_single_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ) { /* check data length */ if (( 0 == message -> as . single_frame . SF_DL ) || ( message -> as . single_frame . SF_DL > ( len - 1 ))) { isotp_user_debug ( \"Single-frame length too small.\" ); return ISOTP_RET_LENGTH ; } /* copying data */ ( void ) memcpy ( link -> receive_buffer , message -> as . single_frame . data , message -> as . single_frame . SF_DL ); link -> receive_size = message -> as . single_frame . SF_DL ; return ISOTP_RET_OK ; } static int isotp_receive_first_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ) { uint8_t is_long_packet = 0 ; uint32_t payload_length ; if ( 8 != len ) { isotp_user_debug ( \"First frame should be 8 bytes in length.\" ); return ISOTP_RET_LENGTH ; } /* check data length */ payload_length = message -> as . first_frame_short . FF_DL_high ; payload_length = ( payload_length << 8 ) + message -> as . first_frame_short . FF_DL_low ; /* if length is ZERO we get a long message > 4095bytes of payload */ if ( payload_length == 0 ) { is_long_packet = 1 ; payload_length = LE32TOH ( message -> as . first_frame_long . FF_DL ); } /* should not use multiple frame transmition */ if ( payload_length <= 7 ) { isotp_user_debug ( \"Should not use multiple frame transmission.\" ); return ISOTP_RET_LENGTH ; } if ( payload_length > link -> receive_buf_size ) { isotp_user_debug ( \"Multi-frame response too large for receiving buffer.\" ); return ISOTP_RET_OVERFLOW ; } /* copying data */ if ( is_long_packet ) { ( void ) memcpy ( link -> receive_buffer , message -> as . first_frame_long . data , sizeof ( message -> as . first_frame_long . data )); link -> receive_offset = sizeof ( message -> as . first_frame_long . data ); } else { ( void ) memcpy ( link -> receive_buffer , message -> as . first_frame_short . data , sizeof ( message -> as . first_frame_short . data )); link -> receive_offset = sizeof ( message -> as . first_frame_short . data ); } link -> receive_size = payload_length ; link -> receive_sn = 1 ; return ISOTP_RET_OK ; } static int isotp_receive_consecutive_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ) { uint32_t remaining_bytes ; /* check sn */ if ( link -> receive_sn != message -> as . consecutive_frame . SN ) { return ISOTP_RET_WRONG_SN ; } /* check data length */ remaining_bytes = link -> receive_size - link -> receive_offset ; if ( remaining_bytes > sizeof ( message -> as . consecutive_frame . data )) { remaining_bytes = sizeof ( message -> as . consecutive_frame . data ); } if ( remaining_bytes > ( uint32_t ) ( len - 1 )) { isotp_user_debug ( \"Consecutive frame too short.\" ); return ISOTP_RET_LENGTH ; } /* copying data */ ( void ) memcpy ( link -> receive_buffer + link -> receive_offset , message -> as . consecutive_frame . data , remaining_bytes ); link -> receive_offset += remaining_bytes ; if ( ++ ( link -> receive_sn ) > 0x0F ) { link -> receive_sn = 0 ; } return ISOTP_RET_OK ; } static int isotp_receive_flow_control_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ) { /* unused args */ ( void ) link ; ( void ) message ; /* check message length */ if ( len < 3 ) { isotp_user_debug ( \"Flow control frame too short.\" ); return ISOTP_RET_LENGTH ; } return ISOTP_RET_OK ; } /* ============================================================================== * PUBLIC FUNCTION IMPLEMENTATIONS * =============================================================================*/ int isotp_send ( IsoTpLink * link , const uint8_t payload [], uint32_t size ) { return isotp_send_with_id ( link , link -> send_arbitration_id , payload , size ); } int isotp_send_with_id ( IsoTpLink * link , uint32_t id , const uint8_t payload [], uint32_t size ) { int ret ; if ( link == 0x0 ) { isotp_user_debug ( \"Link is null!\" ); return ISOTP_RET_ERROR ; } if ( size > link -> send_buf_size ) { isotp_user_debug ( \"Message size too large. Increase ISO_TP_MAX_MESSAGE_SIZE to set \" \"a larger buffer \\n \" ); char message [ ISOTP_MAX_ERROR_MSG_SIZE ] = { 0 }; int32_t writtenChars = snprintf ( & message [ 0 ], ISOTP_MAX_ERROR_MSG_SIZE , \"Attempted to send %u bytes; max size is %u! \\n \" , ( unsigned int ) size , ( unsigned int ) link -> send_buf_size ); assert ( writtenChars <= ISOTP_MAX_ERROR_MSG_SIZE ); ( void ) writtenChars ; isotp_user_debug ( message ); return ISOTP_RET_OVERFLOW ; } if ( ISOTP_SEND_STATUS_INPROGRESS == link -> send_status ) { isotp_user_debug ( \"Abort previous message, transmission in progress. \\n \" ); return ISOTP_RET_INPROGRESS ; } /* copy into local buffer */ link -> send_size = size ; link -> send_offset = 0 ; ( void ) memcpy ( link -> send_buffer , payload , size ); if ( link -> send_size < 8 ) { /* send single frame */ ret = isotp_send_single_frame ( link , id ); #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK if ( ret == ISOTP_RET_OK && link -> tx_done_cb ) { link -> tx_done_cb ( link , link -> send_size , link -> tx_done_cb_arg ); } #endif } else { /* send multi-frame */ ret = isotp_send_first_frame ( link , id ); /* init multi-frame control flags */ if ( ISOTP_RET_OK == ret ) { link -> send_bs_remain = 0 ; link -> send_st_min_us = 0 ; link -> send_wtf_count = 0 ; link -> send_timer_st = isotp_user_get_us (); link -> send_timer_bs = isotp_user_get_us () + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ; link -> send_protocol_result = ISOTP_PROTOCOL_RESULT_OK ; link -> send_status = ISOTP_SEND_STATUS_INPROGRESS ; } } return ret ; } void isotp_on_can_message ( IsoTpLink * link , const uint8_t * data , uint8_t len ) { IsoTpCanMessage message ; int ret ; if ( len < 2 || len > 8 ) { return ; } memcpy ( message . as . data_array . ptr , data , len ); memset ( message . as . data_array . ptr + len , 0 , sizeof ( message . as . data_array . ptr ) - len ); switch ( message . as . common . type ) { case ISOTP_PCI_TYPE_SINGLE : { /* update protocol result */ if ( ISOTP_RECEIVE_STATUS_INPROGRESS == link -> receive_status ) { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_UNEXP_PDU ; } else { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_OK ; } /* handle message */ ret = isotp_receive_single_frame ( link , & message , len ); if ( ISOTP_RET_OK == ret ) { /* change status */ link -> receive_status = ISOTP_RECEIVE_STATUS_FULL ; } break ; } case ISOTP_PCI_TYPE_FIRST_FRAME : { /* update protocol result */ if ( ISOTP_RECEIVE_STATUS_INPROGRESS == link -> receive_status ) { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_UNEXP_PDU ; } else { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_OK ; } /* handle message */ ret = isotp_receive_first_frame ( link , & message , len ); /* if overflow happened */ if ( ISOTP_RET_OVERFLOW == ret ) { /* update protocol result */ link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW ; /* change status */ link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; /* send error message */ isotp_send_flow_control ( link , PCI_FLOW_STATUS_OVERFLOW , 0 , 0 ); break ; } /* if receive successful */ if ( ISOTP_RET_OK == ret ) { /* change status */ link -> receive_status = ISOTP_RECEIVE_STATUS_INPROGRESS ; /* send fc frame */ link -> receive_bs_count = ISO_TP_DEFAULT_BLOCK_SIZE ; isotp_send_flow_control ( link , PCI_FLOW_STATUS_CONTINUE , link -> receive_bs_count , ISO_TP_DEFAULT_ST_MIN_US ); /* refresh timer cs */ link -> receive_timer_cr = isotp_user_get_us () + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ; } break ; } case ISOTP_PCI_TYPE_CONSECUTIVE_FRAME : { /* check if in receiving status */ if ( ISOTP_RECEIVE_STATUS_INPROGRESS != link -> receive_status ) { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_UNEXP_PDU ; break ; } /* handle message */ ret = isotp_receive_consecutive_frame ( link , & message , len ); /* if wrong sn */ if ( ISOTP_RET_WRONG_SN == ret ) { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_WRONG_SN ; link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; break ; } /* if success */ if ( ISOTP_RET_OK == ret ) { /* refresh timer cs */ link -> receive_timer_cr = isotp_user_get_us () + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ; /* receive finished */ if ( link -> receive_offset >= link -> receive_size ) { link -> receive_status = ISOTP_RECEIVE_STATUS_FULL ; } else { /* send fc when bs reaches limit */ if ( 0 == -- link -> receive_bs_count ) { link -> receive_bs_count = ISO_TP_DEFAULT_BLOCK_SIZE ; isotp_send_flow_control ( link , PCI_FLOW_STATUS_CONTINUE , link -> receive_bs_count , ISO_TP_DEFAULT_ST_MIN_US ); } } } break ; } case ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME : /* handle fc frame only when sending in progress */ if ( ISOTP_SEND_STATUS_INPROGRESS != link -> send_status ) { break ; } /* handle message */ ret = isotp_receive_flow_control_frame ( link , & message , len ); if ( ISOTP_RET_OK == ret ) { /* refresh bs timer */ link -> send_timer_bs = isotp_user_get_us () + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ; /* overflow */ if ( PCI_FLOW_STATUS_OVERFLOW == message . as . flow_control . FS ) { link -> send_protocol_result = ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW ; link -> send_status = ISOTP_SEND_STATUS_ERROR ; } /* wait */ else if ( PCI_FLOW_STATUS_WAIT == message . as . flow_control . FS ) { link -> send_wtf_count += 1 ; /* wait exceed allowed count */ if ( link -> send_wtf_count > ISO_TP_MAX_WFT_NUMBER ) { link -> send_protocol_result = ISOTP_PROTOCOL_RESULT_WFT_OVRN ; link -> send_status = ISOTP_SEND_STATUS_ERROR ; } } /* permit send */ else if ( PCI_FLOW_STATUS_CONTINUE == message . as . flow_control . FS ) { if ( 0 == message . as . flow_control . BS ) { link -> send_bs_remain = ISOTP_INVALID_BS ; } else { link -> send_bs_remain = message . as . flow_control . BS ; } uint32_t message_st_min_us = isotp_st_min_to_us ( message . as . flow_control . STmin ); link -> send_st_min_us = message_st_min_us > ISO_TP_DEFAULT_ST_MIN_US ? message_st_min_us : ISO_TP_DEFAULT_ST_MIN_US ; // prefer as much st_min as possible // for stability? link -> send_wtf_count = 0 ; } } break ; default : break ; }; #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK /* Notify user via callback if registered */ if ( link -> receive_status == ISOTP_RECEIVE_STATUS_FULL && link -> rx_done_cb != NULL ) { link -> rx_done_cb ( link , link -> receive_buffer , link -> receive_size , link -> rx_done_cb_arg ); link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; } #endif return ; } int isotp_receive ( IsoTpLink * link , uint8_t * payload , const uint32_t payload_size , uint32_t * out_size ) { uint32_t copylen ; #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK /* If callback is registered, isotp_receive should not be used */ if ( link -> rx_done_cb != NULL ) { return ISOTP_RET_ERROR ; /* Callback mode active, use callback instead */ } #endif if ( ISOTP_RECEIVE_STATUS_FULL != link -> receive_status ) { return ISOTP_RET_NO_DATA ; } copylen = link -> receive_size ; if ( copylen > payload_size ) { copylen = payload_size ; } memcpy ( payload , link -> receive_buffer , copylen ); * out_size = copylen ; link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; return ISOTP_RET_OK ; } void isotp_init_link ( IsoTpLink * link , uint32_t sendid , uint8_t * sendbuf , uint32_t sendbufsize , uint8_t * recvbuf , uint32_t recvbufsize ) { memset ( link , 0 , sizeof ( * link )); link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; link -> send_status = ISOTP_SEND_STATUS_IDLE ; link -> send_arbitration_id = sendid ; link -> send_buffer = sendbuf ; link -> send_buf_size = sendbufsize ; link -> receive_buffer = recvbuf ; link -> receive_buf_size = recvbufsize ; #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK link -> tx_done_cb = NULL ; link -> tx_done_cb_arg = NULL ; #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK link -> rx_done_cb = NULL ; link -> rx_done_cb_arg = NULL ; #endif return ; } void isotp_destroy_link ( IsoTpLink * link ) { if ( link == NULL ) { return ; } // Clear callbacks #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK link -> tx_done_cb = NULL ; link -> tx_done_cb_arg = NULL ; #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK link -> rx_done_cb = NULL ; link -> rx_done_cb_arg = NULL ; #endif // Reset link state (optional, but good practice) memset ( link , 0 , sizeof ( IsoTpLink )); } void isotp_poll ( IsoTpLink * link ) { int ret = 0 ; /* only polling when operation in progress */ if ( ISOTP_SEND_STATUS_INPROGRESS == link -> send_status ) { /* continue send data */ if ( /* send data if bs_remain is invalid or bs_remain large than zero */ ( ISOTP_INVALID_BS == link -> send_bs_remain || link -> send_bs_remain > 0 ) && /* and if st_min is zero or go beyond interval time */ ( 0 == link -> send_st_min_us || IsoTpTimeAfter ( isotp_user_get_us (), link -> send_timer_st ))) { ret = isotp_send_consecutive_frame ( link ); if ( ISOTP_RET_OK == ret ) { if ( ISOTP_INVALID_BS != link -> send_bs_remain ) { link -> send_bs_remain -= 1 ; } link -> send_timer_bs = isotp_user_get_us () + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ; link -> send_timer_st = isotp_user_get_us () + link -> send_st_min_us ; /* check if send finish */ if ( link -> send_offset >= link -> send_size ) { link -> send_status = ISOTP_SEND_STATUS_IDLE ; #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK if ( link -> tx_done_cb != NULL ) { link -> tx_done_cb ( link , link -> send_size , link -> tx_done_cb_arg ); } #endif } } else if ( ISOTP_RET_NOSPACE == ret ) { /* shim reported that it isn't able to send a frame at present, retry on * next call */ } else { link -> send_status = ISOTP_SEND_STATUS_ERROR ; } } /* check timeout */ if ( IsoTpTimeAfter ( isotp_user_get_us (), link -> send_timer_bs )) { link -> send_protocol_result = ISOTP_PROTOCOL_RESULT_TIMEOUT_BS ; link -> send_status = ISOTP_SEND_STATUS_ERROR ; } } /* only polling when operation in progress */ if ( ISOTP_RECEIVE_STATUS_INPROGRESS == link -> receive_status ) { /* check timeout */ if (( link -> receive_timer_cr > 0 ) && IsoTpTimeAfter ( isotp_user_get_us (), link -> receive_timer_cr )) { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_TIMEOUT_CR ; link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; } } return ; } #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK void isotp_set_tx_done_cb ( IsoTpLink * link , isotp_tx_done_cb cb , void * arg ) { if ( link != NULL ) { link -> tx_done_cb = cb ; link -> tx_done_cb_arg = arg ; } } #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK void isotp_set_rx_done_cb ( IsoTpLink * link , isotp_rx_done_cb cb , void * arg ) { if ( link != NULL ) { link -> rx_done_cb = cb ; link -> rx_done_cb_arg = arg ; } } #endif","title":"File isotp.c"},{"location":"docs/isotp_8c_source/#file-isotpc","text":"File List > src > isotp.c Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Core ISO-TP protocol implementation with multi-frame support * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <assert.h> #include <stdint.h> #include \"isotp.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ static uint8_t isotp_us_to_st_min ( uint32_t us ); static uint32_t isotp_st_min_to_us ( uint8_t st_min ); static int isotp_send_flow_control ( const IsoTpLink * link , uint8_t flow_status , uint8_t block_size , uint32_t st_min_us ); static int isotp_send_single_frame ( const IsoTpLink * link , uint32_t id ); static int isotp_send_first_frame ( IsoTpLink * link , uint32_t id ); static int isotp_send_consecutive_frame ( IsoTpLink * link ); static int isotp_receive_single_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ); static int isotp_receive_first_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ); static int isotp_receive_consecutive_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ); static int isotp_receive_flow_control_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ); /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* st_min to microsecond */ static uint8_t isotp_us_to_st_min ( uint32_t us ) { // ISO 15765-2:2016 defines STmin encoding: // 0x00..0x7F: value in milliseconds (0..127 ms) // 0xF1..0xF9: value in 100 microsecond steps (100..900 us) const uint32_t STMIN_MS_MAX = 127000 ; // 127 ms in us const uint32_t STMIN_US_MIN = 100 ; // 100 us const uint32_t STMIN_US_MAX = 900 ; // 900 us const uint8_t STMIN_US_BASE = 0xF0 ; // base for 100us steps if ( us <= STMIN_MS_MAX ) { if ( us >= STMIN_US_MIN && us <= STMIN_US_MAX ) { return ( uint8_t ) ( STMIN_US_BASE + ( us / 100 )); } else { return ( uint8_t ) ( us / 1000u ); } } return 0 ; } /* st_min to usec */ static uint32_t isotp_st_min_to_us ( uint8_t st_min ) { // ISO 15765-2:2016 defines STmin encoding: // 0x00..0x7F: value in milliseconds (0..127 ms) // 0xF1..0xF9: value in 100 microsecond steps (100..900 us) const uint8_t STMIN_MS_MAX = 0x7F ; // 127 ms const uint8_t STMIN_US_MIN_CODE = 0xF1 ; // 100 us const uint8_t STMIN_US_MAX_CODE = 0xF9 ; // 900 us const uint8_t STMIN_US_BASE = 0xF0 ; // base for 100us steps const uint32_t US_PER_MS = 1000 ; const uint32_t US_STEP = 100 ; if ( st_min <= STMIN_MS_MAX ) { return st_min * US_PER_MS ; } else if ( st_min >= STMIN_US_MIN_CODE && st_min <= STMIN_US_MAX_CODE ) { return ( st_min - STMIN_US_BASE ) * US_STEP ; } return 0 ; } static int isotp_send_flow_control ( const IsoTpLink * link , uint8_t flow_status , uint8_t block_size , uint32_t st_min_us ) { IsoTpCanMessage message ; ( void ) memset ( & message , 0 , sizeof ( message )); int ret ; uint8_t size = 0 ; /* setup message */ message . as . flow_control . type = ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME ; message . as . flow_control . FS = flow_status ; message . as . flow_control . BS = block_size ; message . as . flow_control . STmin = isotp_us_to_st_min ( st_min_us ); /* send message */ #ifdef ISO_TP_FRAME_PADDING ( void ) memset ( message . as . flow_control . reserve , ISO_TP_FRAME_PADDING_VALUE , sizeof ( message . as . flow_control . reserve )); size = sizeof ( message ); #else size = 3 ; #endif ret = isotp_user_send_can ( link -> send_arbitration_id , message . as . data_array . ptr , size #if defined(ISO_TP_USER_SEND_CAN_ARG) , link -> user_send_can_arg #endif ); return ret ; } static int isotp_send_single_frame ( const IsoTpLink * link , uint32_t id ) { ( void ) id ; // Prevent unused variable warning IsoTpCanMessage message ; int ret ; uint8_t size = 0 ; /* multi frame message length must greater than 7 */ assert ( link -> send_size <= 7 ); /* setup message */ message . as . single_frame . type = ISOTP_PCI_TYPE_SINGLE ; message . as . single_frame . SF_DL = ( uint8_t ) link -> send_size ; ( void ) memcpy ( message . as . single_frame . data , link -> send_buffer , link -> send_size ); /* send message */ #ifdef ISO_TP_FRAME_PADDING ( void ) memset ( message . as . single_frame . data + link -> send_size , ISO_TP_FRAME_PADDING_VALUE , sizeof ( message . as . single_frame . data ) - link -> send_size ); size = sizeof ( message ); #else size = link -> send_size + ( uint8_t ) 1 ; #endif ret = isotp_user_send_can ( link -> send_arbitration_id , message . as . data_array . ptr , size #if defined(ISO_TP_USER_SEND_CAN_ARG) , link -> user_send_can_arg #endif ); return ret ; } static int isotp_send_first_frame ( IsoTpLink * link , uint32_t id ) { IsoTpCanMessage message = { 0 }; int ret = 0 ; /* multi frame message length must greater than 7 */ assert ( link -> send_size > 7 ); if ( link -> send_size <= 4095 ) { /* setup 'short' message */ message . as . first_frame_short . type = ISOTP_PCI_TYPE_FIRST_FRAME ; message . as . first_frame_short . FF_DL_low = ( uint8_t ) link -> send_size ; message . as . first_frame_short . FF_DL_high = ( uint8_t ) ( 0x0F & ( link -> send_size >> 8 )); ( void ) memcpy ( message . as . first_frame_short . data , link -> send_buffer , sizeof ( message . as . first_frame_short . data )); /* send 'short' message */ ret = isotp_user_send_can ( id , message . as . data_array . ptr , sizeof ( message ) #if defined(ISO_TP_USER_SEND_CAN_ARG) , link -> user_send_can_arg #endif ); if ( ISOTP_RET_OK == ret ) { link -> send_offset += sizeof ( message . as . first_frame_short . data ); } } else { // ISO15765-2:2016 /* setup 'long' message */ message . as . first_frame_long . set_to_zero_high = 0 ; message . as . first_frame_long . set_to_zero_low = 0 ; message . as . first_frame_long . type = ISOTP_PCI_TYPE_FIRST_FRAME ; message . as . first_frame_long . FF_DL = LE32TOH ( link -> send_size ); ( void ) memcpy ( message . as . first_frame_long . data , link -> send_buffer , sizeof ( message . as . first_frame_long . data )); /* send 'long' message */ ret = isotp_user_send_can ( id , message . as . data_array . ptr , sizeof ( message ) #if defined(ISO_TP_USER_SEND_CAN_ARG) , link -> user_send_can_arg #endif ); if ( ISOTP_RET_OK == ret ) { link -> send_offset += sizeof ( message . as . first_frame_long . data ); } } link -> send_sn = 1 ; return ret ; } static int isotp_send_consecutive_frame ( IsoTpLink * link ) { IsoTpCanMessage message ; uint32_t data_length ; int ret ; uint8_t size = 0 ; /* multi frame message length must greater than 7 */ assert ( link -> send_size > 7 ); /* setup message */ message . as . consecutive_frame . type = ISOTP_PCI_TYPE_CONSECUTIVE_FRAME ; message . as . consecutive_frame . SN = link -> send_sn ; data_length = link -> send_size - link -> send_offset ; if ( data_length > sizeof ( message . as . consecutive_frame . data )) { data_length = sizeof ( message . as . consecutive_frame . data ); } ( void ) memcpy ( message . as . consecutive_frame . data , link -> send_buffer + link -> send_offset , data_length ); /* send message */ #ifdef ISO_TP_FRAME_PADDING ( void ) memset ( message . as . consecutive_frame . data + data_length , ISO_TP_FRAME_PADDING_VALUE , sizeof ( message . as . consecutive_frame . data ) - data_length ); size = sizeof ( message ); #else size = data_length + 1 ; #endif ret = isotp_user_send_can ( link -> send_arbitration_id , message . as . data_array . ptr , size #if defined(ISO_TP_USER_SEND_CAN_ARG) , link -> user_send_can_arg #endif ); if ( ISOTP_RET_OK == ret ) { link -> send_offset += data_length ; if ( ++ ( link -> send_sn ) > 0x0F ) { link -> send_sn = 0 ; } } return ret ; } static int isotp_receive_single_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ) { /* check data length */ if (( 0 == message -> as . single_frame . SF_DL ) || ( message -> as . single_frame . SF_DL > ( len - 1 ))) { isotp_user_debug ( \"Single-frame length too small.\" ); return ISOTP_RET_LENGTH ; } /* copying data */ ( void ) memcpy ( link -> receive_buffer , message -> as . single_frame . data , message -> as . single_frame . SF_DL ); link -> receive_size = message -> as . single_frame . SF_DL ; return ISOTP_RET_OK ; } static int isotp_receive_first_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ) { uint8_t is_long_packet = 0 ; uint32_t payload_length ; if ( 8 != len ) { isotp_user_debug ( \"First frame should be 8 bytes in length.\" ); return ISOTP_RET_LENGTH ; } /* check data length */ payload_length = message -> as . first_frame_short . FF_DL_high ; payload_length = ( payload_length << 8 ) + message -> as . first_frame_short . FF_DL_low ; /* if length is ZERO we get a long message > 4095bytes of payload */ if ( payload_length == 0 ) { is_long_packet = 1 ; payload_length = LE32TOH ( message -> as . first_frame_long . FF_DL ); } /* should not use multiple frame transmition */ if ( payload_length <= 7 ) { isotp_user_debug ( \"Should not use multiple frame transmission.\" ); return ISOTP_RET_LENGTH ; } if ( payload_length > link -> receive_buf_size ) { isotp_user_debug ( \"Multi-frame response too large for receiving buffer.\" ); return ISOTP_RET_OVERFLOW ; } /* copying data */ if ( is_long_packet ) { ( void ) memcpy ( link -> receive_buffer , message -> as . first_frame_long . data , sizeof ( message -> as . first_frame_long . data )); link -> receive_offset = sizeof ( message -> as . first_frame_long . data ); } else { ( void ) memcpy ( link -> receive_buffer , message -> as . first_frame_short . data , sizeof ( message -> as . first_frame_short . data )); link -> receive_offset = sizeof ( message -> as . first_frame_short . data ); } link -> receive_size = payload_length ; link -> receive_sn = 1 ; return ISOTP_RET_OK ; } static int isotp_receive_consecutive_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ) { uint32_t remaining_bytes ; /* check sn */ if ( link -> receive_sn != message -> as . consecutive_frame . SN ) { return ISOTP_RET_WRONG_SN ; } /* check data length */ remaining_bytes = link -> receive_size - link -> receive_offset ; if ( remaining_bytes > sizeof ( message -> as . consecutive_frame . data )) { remaining_bytes = sizeof ( message -> as . consecutive_frame . data ); } if ( remaining_bytes > ( uint32_t ) ( len - 1 )) { isotp_user_debug ( \"Consecutive frame too short.\" ); return ISOTP_RET_LENGTH ; } /* copying data */ ( void ) memcpy ( link -> receive_buffer + link -> receive_offset , message -> as . consecutive_frame . data , remaining_bytes ); link -> receive_offset += remaining_bytes ; if ( ++ ( link -> receive_sn ) > 0x0F ) { link -> receive_sn = 0 ; } return ISOTP_RET_OK ; } static int isotp_receive_flow_control_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ) { /* unused args */ ( void ) link ; ( void ) message ; /* check message length */ if ( len < 3 ) { isotp_user_debug ( \"Flow control frame too short.\" ); return ISOTP_RET_LENGTH ; } return ISOTP_RET_OK ; } /* ============================================================================== * PUBLIC FUNCTION IMPLEMENTATIONS * =============================================================================*/ int isotp_send ( IsoTpLink * link , const uint8_t payload [], uint32_t size ) { return isotp_send_with_id ( link , link -> send_arbitration_id , payload , size ); } int isotp_send_with_id ( IsoTpLink * link , uint32_t id , const uint8_t payload [], uint32_t size ) { int ret ; if ( link == 0x0 ) { isotp_user_debug ( \"Link is null!\" ); return ISOTP_RET_ERROR ; } if ( size > link -> send_buf_size ) { isotp_user_debug ( \"Message size too large. Increase ISO_TP_MAX_MESSAGE_SIZE to set \" \"a larger buffer \\n \" ); char message [ ISOTP_MAX_ERROR_MSG_SIZE ] = { 0 }; int32_t writtenChars = snprintf ( & message [ 0 ], ISOTP_MAX_ERROR_MSG_SIZE , \"Attempted to send %u bytes; max size is %u! \\n \" , ( unsigned int ) size , ( unsigned int ) link -> send_buf_size ); assert ( writtenChars <= ISOTP_MAX_ERROR_MSG_SIZE ); ( void ) writtenChars ; isotp_user_debug ( message ); return ISOTP_RET_OVERFLOW ; } if ( ISOTP_SEND_STATUS_INPROGRESS == link -> send_status ) { isotp_user_debug ( \"Abort previous message, transmission in progress. \\n \" ); return ISOTP_RET_INPROGRESS ; } /* copy into local buffer */ link -> send_size = size ; link -> send_offset = 0 ; ( void ) memcpy ( link -> send_buffer , payload , size ); if ( link -> send_size < 8 ) { /* send single frame */ ret = isotp_send_single_frame ( link , id ); #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK if ( ret == ISOTP_RET_OK && link -> tx_done_cb ) { link -> tx_done_cb ( link , link -> send_size , link -> tx_done_cb_arg ); } #endif } else { /* send multi-frame */ ret = isotp_send_first_frame ( link , id ); /* init multi-frame control flags */ if ( ISOTP_RET_OK == ret ) { link -> send_bs_remain = 0 ; link -> send_st_min_us = 0 ; link -> send_wtf_count = 0 ; link -> send_timer_st = isotp_user_get_us (); link -> send_timer_bs = isotp_user_get_us () + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ; link -> send_protocol_result = ISOTP_PROTOCOL_RESULT_OK ; link -> send_status = ISOTP_SEND_STATUS_INPROGRESS ; } } return ret ; } void isotp_on_can_message ( IsoTpLink * link , const uint8_t * data , uint8_t len ) { IsoTpCanMessage message ; int ret ; if ( len < 2 || len > 8 ) { return ; } memcpy ( message . as . data_array . ptr , data , len ); memset ( message . as . data_array . ptr + len , 0 , sizeof ( message . as . data_array . ptr ) - len ); switch ( message . as . common . type ) { case ISOTP_PCI_TYPE_SINGLE : { /* update protocol result */ if ( ISOTP_RECEIVE_STATUS_INPROGRESS == link -> receive_status ) { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_UNEXP_PDU ; } else { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_OK ; } /* handle message */ ret = isotp_receive_single_frame ( link , & message , len ); if ( ISOTP_RET_OK == ret ) { /* change status */ link -> receive_status = ISOTP_RECEIVE_STATUS_FULL ; } break ; } case ISOTP_PCI_TYPE_FIRST_FRAME : { /* update protocol result */ if ( ISOTP_RECEIVE_STATUS_INPROGRESS == link -> receive_status ) { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_UNEXP_PDU ; } else { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_OK ; } /* handle message */ ret = isotp_receive_first_frame ( link , & message , len ); /* if overflow happened */ if ( ISOTP_RET_OVERFLOW == ret ) { /* update protocol result */ link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW ; /* change status */ link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; /* send error message */ isotp_send_flow_control ( link , PCI_FLOW_STATUS_OVERFLOW , 0 , 0 ); break ; } /* if receive successful */ if ( ISOTP_RET_OK == ret ) { /* change status */ link -> receive_status = ISOTP_RECEIVE_STATUS_INPROGRESS ; /* send fc frame */ link -> receive_bs_count = ISO_TP_DEFAULT_BLOCK_SIZE ; isotp_send_flow_control ( link , PCI_FLOW_STATUS_CONTINUE , link -> receive_bs_count , ISO_TP_DEFAULT_ST_MIN_US ); /* refresh timer cs */ link -> receive_timer_cr = isotp_user_get_us () + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ; } break ; } case ISOTP_PCI_TYPE_CONSECUTIVE_FRAME : { /* check if in receiving status */ if ( ISOTP_RECEIVE_STATUS_INPROGRESS != link -> receive_status ) { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_UNEXP_PDU ; break ; } /* handle message */ ret = isotp_receive_consecutive_frame ( link , & message , len ); /* if wrong sn */ if ( ISOTP_RET_WRONG_SN == ret ) { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_WRONG_SN ; link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; break ; } /* if success */ if ( ISOTP_RET_OK == ret ) { /* refresh timer cs */ link -> receive_timer_cr = isotp_user_get_us () + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ; /* receive finished */ if ( link -> receive_offset >= link -> receive_size ) { link -> receive_status = ISOTP_RECEIVE_STATUS_FULL ; } else { /* send fc when bs reaches limit */ if ( 0 == -- link -> receive_bs_count ) { link -> receive_bs_count = ISO_TP_DEFAULT_BLOCK_SIZE ; isotp_send_flow_control ( link , PCI_FLOW_STATUS_CONTINUE , link -> receive_bs_count , ISO_TP_DEFAULT_ST_MIN_US ); } } } break ; } case ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME : /* handle fc frame only when sending in progress */ if ( ISOTP_SEND_STATUS_INPROGRESS != link -> send_status ) { break ; } /* handle message */ ret = isotp_receive_flow_control_frame ( link , & message , len ); if ( ISOTP_RET_OK == ret ) { /* refresh bs timer */ link -> send_timer_bs = isotp_user_get_us () + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ; /* overflow */ if ( PCI_FLOW_STATUS_OVERFLOW == message . as . flow_control . FS ) { link -> send_protocol_result = ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW ; link -> send_status = ISOTP_SEND_STATUS_ERROR ; } /* wait */ else if ( PCI_FLOW_STATUS_WAIT == message . as . flow_control . FS ) { link -> send_wtf_count += 1 ; /* wait exceed allowed count */ if ( link -> send_wtf_count > ISO_TP_MAX_WFT_NUMBER ) { link -> send_protocol_result = ISOTP_PROTOCOL_RESULT_WFT_OVRN ; link -> send_status = ISOTP_SEND_STATUS_ERROR ; } } /* permit send */ else if ( PCI_FLOW_STATUS_CONTINUE == message . as . flow_control . FS ) { if ( 0 == message . as . flow_control . BS ) { link -> send_bs_remain = ISOTP_INVALID_BS ; } else { link -> send_bs_remain = message . as . flow_control . BS ; } uint32_t message_st_min_us = isotp_st_min_to_us ( message . as . flow_control . STmin ); link -> send_st_min_us = message_st_min_us > ISO_TP_DEFAULT_ST_MIN_US ? message_st_min_us : ISO_TP_DEFAULT_ST_MIN_US ; // prefer as much st_min as possible // for stability? link -> send_wtf_count = 0 ; } } break ; default : break ; }; #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK /* Notify user via callback if registered */ if ( link -> receive_status == ISOTP_RECEIVE_STATUS_FULL && link -> rx_done_cb != NULL ) { link -> rx_done_cb ( link , link -> receive_buffer , link -> receive_size , link -> rx_done_cb_arg ); link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; } #endif return ; } int isotp_receive ( IsoTpLink * link , uint8_t * payload , const uint32_t payload_size , uint32_t * out_size ) { uint32_t copylen ; #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK /* If callback is registered, isotp_receive should not be used */ if ( link -> rx_done_cb != NULL ) { return ISOTP_RET_ERROR ; /* Callback mode active, use callback instead */ } #endif if ( ISOTP_RECEIVE_STATUS_FULL != link -> receive_status ) { return ISOTP_RET_NO_DATA ; } copylen = link -> receive_size ; if ( copylen > payload_size ) { copylen = payload_size ; } memcpy ( payload , link -> receive_buffer , copylen ); * out_size = copylen ; link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; return ISOTP_RET_OK ; } void isotp_init_link ( IsoTpLink * link , uint32_t sendid , uint8_t * sendbuf , uint32_t sendbufsize , uint8_t * recvbuf , uint32_t recvbufsize ) { memset ( link , 0 , sizeof ( * link )); link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; link -> send_status = ISOTP_SEND_STATUS_IDLE ; link -> send_arbitration_id = sendid ; link -> send_buffer = sendbuf ; link -> send_buf_size = sendbufsize ; link -> receive_buffer = recvbuf ; link -> receive_buf_size = recvbufsize ; #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK link -> tx_done_cb = NULL ; link -> tx_done_cb_arg = NULL ; #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK link -> rx_done_cb = NULL ; link -> rx_done_cb_arg = NULL ; #endif return ; } void isotp_destroy_link ( IsoTpLink * link ) { if ( link == NULL ) { return ; } // Clear callbacks #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK link -> tx_done_cb = NULL ; link -> tx_done_cb_arg = NULL ; #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK link -> rx_done_cb = NULL ; link -> rx_done_cb_arg = NULL ; #endif // Reset link state (optional, but good practice) memset ( link , 0 , sizeof ( IsoTpLink )); } void isotp_poll ( IsoTpLink * link ) { int ret = 0 ; /* only polling when operation in progress */ if ( ISOTP_SEND_STATUS_INPROGRESS == link -> send_status ) { /* continue send data */ if ( /* send data if bs_remain is invalid or bs_remain large than zero */ ( ISOTP_INVALID_BS == link -> send_bs_remain || link -> send_bs_remain > 0 ) && /* and if st_min is zero or go beyond interval time */ ( 0 == link -> send_st_min_us || IsoTpTimeAfter ( isotp_user_get_us (), link -> send_timer_st ))) { ret = isotp_send_consecutive_frame ( link ); if ( ISOTP_RET_OK == ret ) { if ( ISOTP_INVALID_BS != link -> send_bs_remain ) { link -> send_bs_remain -= 1 ; } link -> send_timer_bs = isotp_user_get_us () + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ; link -> send_timer_st = isotp_user_get_us () + link -> send_st_min_us ; /* check if send finish */ if ( link -> send_offset >= link -> send_size ) { link -> send_status = ISOTP_SEND_STATUS_IDLE ; #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK if ( link -> tx_done_cb != NULL ) { link -> tx_done_cb ( link , link -> send_size , link -> tx_done_cb_arg ); } #endif } } else if ( ISOTP_RET_NOSPACE == ret ) { /* shim reported that it isn't able to send a frame at present, retry on * next call */ } else { link -> send_status = ISOTP_SEND_STATUS_ERROR ; } } /* check timeout */ if ( IsoTpTimeAfter ( isotp_user_get_us (), link -> send_timer_bs )) { link -> send_protocol_result = ISOTP_PROTOCOL_RESULT_TIMEOUT_BS ; link -> send_status = ISOTP_SEND_STATUS_ERROR ; } } /* only polling when operation in progress */ if ( ISOTP_RECEIVE_STATUS_INPROGRESS == link -> receive_status ) { /* check timeout */ if (( link -> receive_timer_cr > 0 ) && IsoTpTimeAfter ( isotp_user_get_us (), link -> receive_timer_cr )) { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_TIMEOUT_CR ; link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; } } return ; } #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK void isotp_set_tx_done_cb ( IsoTpLink * link , isotp_tx_done_cb cb , void * arg ) { if ( link != NULL ) { link -> tx_done_cb = cb ; link -> tx_done_cb_arg = arg ; } } #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK void isotp_set_rx_done_cb ( IsoTpLink * link , isotp_rx_done_cb cb , void * arg ) { if ( link != NULL ) { link -> rx_done_cb = cb ; link -> rx_done_cb_arg = arg ; } } #endif","title":"File isotp.c"},{"location":"docs/dir_59425e443f801f1f2fd8bbe4959a3ccf/","text":"Dir tests \u00b6 FileList > tests Files \u00b6 Type Name file isotp_test_support.h The documentation for this class was generated from the following file tests/","title":"Dir tests"},{"location":"docs/dir_59425e443f801f1f2fd8bbe4959a3ccf/#dir-tests","text":"FileList > tests","title":"Dir tests"},{"location":"docs/dir_59425e443f801f1f2fd8bbe4959a3ccf/#files","text":"Type Name file isotp_test_support.h The documentation for this class was generated from the following file tests/","title":"Files"},{"location":"docs/isotp__test__support_8h/","text":"File isotp_test_support.h \u00b6 FileList > tests > isotp_test_support.h Go to the source code of this file #include <cstdint> #include <cstddef> #include <cstring> #include \"isotp.h\" Classes \u00b6 Type Name struct MockCanState Mock CAN state structure for testing purposes. Public Attributes \u00b6 Type Name MockCanState g_can_state Global state for CAN send mock. int g_debug_call_count Global state for counting debug calls. uint32_t g_now_us Global state for current time in microseconds. Public Functions \u00b6 Type Name void reset_mocks () Reset all mock state to initial values, should be called before each test. Public Attributes Documentation \u00b6 variable g_can_state \u00b6 Global state for CAN send mock. MockCanState g_can_state ; variable g_debug_call_count \u00b6 Global state for counting debug calls. int g_debug_call_count ; variable g_now_us \u00b6 Global state for current time in microseconds. uint32_t g_now_us ; Public Functions Documentation \u00b6 function reset_mocks \u00b6 Reset all mock state to initial values, should be called before each test. void reset_mocks () The documentation for this class was generated from the following file tests/isotp_test_support.h","title":"File isotp_test_support.h"},{"location":"docs/isotp__test__support_8h/#file-isotp_test_supporth","text":"FileList > tests > isotp_test_support.h Go to the source code of this file #include <cstdint> #include <cstddef> #include <cstring> #include \"isotp.h\"","title":"File isotp_test_support.h"},{"location":"docs/isotp__test__support_8h/#classes","text":"Type Name struct MockCanState Mock CAN state structure for testing purposes.","title":"Classes"},{"location":"docs/isotp__test__support_8h/#public-attributes","text":"Type Name MockCanState g_can_state Global state for CAN send mock. int g_debug_call_count Global state for counting debug calls. uint32_t g_now_us Global state for current time in microseconds.","title":"Public Attributes"},{"location":"docs/isotp__test__support_8h/#public-functions","text":"Type Name void reset_mocks () Reset all mock state to initial values, should be called before each test.","title":"Public Functions"},{"location":"docs/isotp__test__support_8h/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/isotp__test__support_8h/#variable-g_can_state","text":"Global state for CAN send mock. MockCanState g_can_state ;","title":"variable g_can_state"},{"location":"docs/isotp__test__support_8h/#variable-g_debug_call_count","text":"Global state for counting debug calls. int g_debug_call_count ;","title":"variable g_debug_call_count"},{"location":"docs/isotp__test__support_8h/#variable-g_now_us","text":"Global state for current time in microseconds. uint32_t g_now_us ;","title":"variable g_now_us"},{"location":"docs/isotp__test__support_8h/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/isotp__test__support_8h/#function-reset_mocks","text":"Reset all mock state to initial values, should be called before each test. void reset_mocks () The documentation for this class was generated from the following file tests/isotp_test_support.h","title":"function reset_mocks"},{"location":"docs/isotp__test__support_8h_source/","text":"File isotp_test_support.h \u00b6 File List > tests > isotp_test_support.h Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Test support utilities and mocks. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ #ifndef ISOTP_TEST_SUPPORT_H #define ISOTP_TEST_SUPPORT_H /* ============================================================================== * INCLUDES * =============================================================================*/ #include <cstdint> #include <cstddef> #include <cstring> extern \"C\" { #include \"isotp.h\" } /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* ============================================================================== * TYPE DEFINITIONS * =============================================================================*/ struct MockCanState { uint32_t last_id ; uint8_t last_data [ 8 ]; uint8_t last_size ; int return_value ; int call_count ; }; /* ============================================================================== * GLOBAL VARIABLES (extern declarations) * =============================================================================*/ extern MockCanState g_can_state ; extern uint32_t g_now_us ; extern int g_debug_call_count ; /* ============================================================================== * PUBLIC FUNCTION DECLARATIONS * =============================================================================*/ void reset_mocks (); #endif // ISOTP_TEST_SUPPORT_H","title":"File isotp_test_support.h"},{"location":"docs/isotp__test__support_8h_source/#file-isotp_test_supporth","text":"File List > tests > isotp_test_support.h Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Test support utilities and mocks. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ #ifndef ISOTP_TEST_SUPPORT_H #define ISOTP_TEST_SUPPORT_H /* ============================================================================== * INCLUDES * =============================================================================*/ #include <cstdint> #include <cstddef> #include <cstring> extern \"C\" { #include \"isotp.h\" } /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* ============================================================================== * TYPE DEFINITIONS * =============================================================================*/ struct MockCanState { uint32_t last_id ; uint8_t last_data [ 8 ]; uint8_t last_size ; int return_value ; int call_count ; }; /* ============================================================================== * GLOBAL VARIABLES (extern declarations) * =============================================================================*/ extern MockCanState g_can_state ; extern uint32_t g_now_us ; extern int g_debug_call_count ; /* ============================================================================== * PUBLIC FUNCTION DECLARATIONS * =============================================================================*/ void reset_mocks (); #endif // ISOTP_TEST_SUPPORT_H","title":"File isotp_test_support.h"},{"location":"docs/namespaces/","text":"Namespace List \u00b6 Here is a list of all namespaces with brief descriptions:","title":"Namespace List"},{"location":"docs/namespaces/#namespace-list","text":"Here is a list of all namespaces with brief descriptions:","title":"Namespace List"},{"location":"docs/classes/","text":"Class Index \u00b6 i \u00b6 IsoTpCanMessage IsoTpConsecutiveFrame IsoTpDataArray IsoTpFirstFrameShort IsoTpFlowControl IsoTpLink IsoTpPciType IsoTpSingleFrame m \u00b6 MockCanState","title":"Class Index"},{"location":"docs/classes/#class-index","text":"","title":"Class Index"},{"location":"docs/classes/#i","text":"IsoTpCanMessage IsoTpConsecutiveFrame IsoTpDataArray IsoTpFirstFrameShort IsoTpFlowControl IsoTpLink IsoTpPciType IsoTpSingleFrame","title":"i"},{"location":"docs/classes/#m","text":"MockCanState","title":"m"},{"location":"docs/hierarchy/","text":"Class Hierarchy \u00b6 This inheritance list is sorted roughly, but not completely, alphabetically: struct IsoTpCanMessage struct IsoTpConsecutiveFrame Consecutive frame layout. struct IsoTpDataArray struct IsoTpFirstFrameShort First frame (short) layout. struct IsoTpFlowControl Flow control frame layout. struct IsoTpLink Link state for a single ISO-TP connection. struct IsoTpPciType CAN frame definitions. struct IsoTpSingleFrame Single frame layout. struct MockCanState Mock CAN state structure for testing purposes.","title":"Class Hierarchy"},{"location":"docs/hierarchy/#class-hierarchy","text":"This inheritance list is sorted roughly, but not completely, alphabetically: struct IsoTpCanMessage struct IsoTpConsecutiveFrame Consecutive frame layout. struct IsoTpDataArray struct IsoTpFirstFrameShort First frame (short) layout. struct IsoTpFlowControl Flow control frame layout. struct IsoTpLink Link state for a single ISO-TP connection. struct IsoTpPciType CAN frame definitions. struct IsoTpSingleFrame Single frame layout. struct MockCanState Mock CAN state structure for testing purposes.","title":"Class Hierarchy"},{"location":"docs/modules/","text":"Modules \u00b6 Here is a list of all modules: ISO-TP API Public API for ISO-TP link management and message handling. Configuration Build-time configuration for ISO-TP. Protocol definitions Internal protocol definitions and type structures. User hooks User-implemented callbacks and platform hooks.","title":"Modules"},{"location":"docs/modules/#modules","text":"Here is a list of all modules: ISO-TP API Public API for ISO-TP link management and message handling. Configuration Build-time configuration for ISO-TP. Protocol definitions Internal protocol definitions and type structures. User hooks User-implemented callbacks and platform hooks.","title":"Modules"},{"location":"docs/pages/","text":"Related Pages \u00b6 Here is a list of all related documentation pages:","title":"Related Pages"},{"location":"docs/pages/#related-pages","text":"Here is a list of all related documentation pages:","title":"Related Pages"},{"location":"docs/class_members/","text":"Class Members \u00b6 a \u00b6 as ( IsoTpCanMessage ) b \u00b6 BS ( IsoTpFlowControl ) c \u00b6 common ( IsoTpCanMessage ) consecutive_frame ( IsoTpCanMessage ) call_count ( MockCanState ) d \u00b6 data_array ( IsoTpCanMessage ) data ( IsoTpConsecutiveFrame , IsoTpFirstFrameShort , IsoTpSingleFrame ) f \u00b6 first_frame_long ( IsoTpCanMessage ) first_frame_short ( IsoTpCanMessage ) flow_control ( IsoTpCanMessage ) FF_DL_high ( IsoTpFirstFrameShort ) FF_DL_low ( IsoTpFirstFrameShort ) FS ( IsoTpFlowControl ) l \u00b6 last_data ( MockCanState ) last_id ( MockCanState ) last_size ( MockCanState ) p \u00b6 ptr ( IsoTpDataArray ) r \u00b6 reserve ( IsoTpFlowControl ) receive_arbitration_id ( IsoTpLink ) receive_bs_count ( IsoTpLink ) receive_buf_size ( IsoTpLink ) receive_buffer ( IsoTpLink ) receive_offset ( IsoTpLink ) receive_protocol_result ( IsoTpLink ) receive_size ( IsoTpLink ) receive_sn ( IsoTpLink ) receive_status ( IsoTpLink ) receive_timer_cr ( IsoTpLink ) reserve_1 ( IsoTpPciType ) reserve_2 ( IsoTpPciType ) return_value ( MockCanState ) s \u00b6 single_frame ( IsoTpCanMessage ) SN ( IsoTpConsecutiveFrame ) STmin ( IsoTpFlowControl ) send_arbitration_id ( IsoTpLink ) send_bs_remain ( IsoTpLink ) send_buf_size ( IsoTpLink ) send_buffer ( IsoTpLink ) send_offset ( IsoTpLink ) send_protocol_result ( IsoTpLink ) send_size ( IsoTpLink ) send_sn ( IsoTpLink ) send_st_min_us ( IsoTpLink ) send_status ( IsoTpLink ) send_timer_bs ( IsoTpLink ) send_timer_st ( IsoTpLink ) send_wtf_count ( IsoTpLink ) SF_DL ( IsoTpSingleFrame ) t \u00b6 type ( IsoTpConsecutiveFrame , IsoTpFirstFrameShort , IsoTpFlowControl , IsoTpPciType , IsoTpSingleFrame )","title":"Class Members"},{"location":"docs/class_members/#class-members","text":"","title":"Class Members"},{"location":"docs/class_members/#a","text":"as ( IsoTpCanMessage )","title":"a"},{"location":"docs/class_members/#b","text":"BS ( IsoTpFlowControl )","title":"b"},{"location":"docs/class_members/#c","text":"common ( IsoTpCanMessage ) consecutive_frame ( IsoTpCanMessage ) call_count ( MockCanState )","title":"c"},{"location":"docs/class_members/#d","text":"data_array ( IsoTpCanMessage ) data ( IsoTpConsecutiveFrame , IsoTpFirstFrameShort , IsoTpSingleFrame )","title":"d"},{"location":"docs/class_members/#f","text":"first_frame_long ( IsoTpCanMessage ) first_frame_short ( IsoTpCanMessage ) flow_control ( IsoTpCanMessage ) FF_DL_high ( IsoTpFirstFrameShort ) FF_DL_low ( IsoTpFirstFrameShort ) FS ( IsoTpFlowControl )","title":"f"},{"location":"docs/class_members/#l","text":"last_data ( MockCanState ) last_id ( MockCanState ) last_size ( MockCanState )","title":"l"},{"location":"docs/class_members/#p","text":"ptr ( IsoTpDataArray )","title":"p"},{"location":"docs/class_members/#r","text":"reserve ( IsoTpFlowControl ) receive_arbitration_id ( IsoTpLink ) receive_bs_count ( IsoTpLink ) receive_buf_size ( IsoTpLink ) receive_buffer ( IsoTpLink ) receive_offset ( IsoTpLink ) receive_protocol_result ( IsoTpLink ) receive_size ( IsoTpLink ) receive_sn ( IsoTpLink ) receive_status ( IsoTpLink ) receive_timer_cr ( IsoTpLink ) reserve_1 ( IsoTpPciType ) reserve_2 ( IsoTpPciType ) return_value ( MockCanState )","title":"r"},{"location":"docs/class_members/#s","text":"single_frame ( IsoTpCanMessage ) SN ( IsoTpConsecutiveFrame ) STmin ( IsoTpFlowControl ) send_arbitration_id ( IsoTpLink ) send_bs_remain ( IsoTpLink ) send_buf_size ( IsoTpLink ) send_buffer ( IsoTpLink ) send_offset ( IsoTpLink ) send_protocol_result ( IsoTpLink ) send_size ( IsoTpLink ) send_sn ( IsoTpLink ) send_st_min_us ( IsoTpLink ) send_status ( IsoTpLink ) send_timer_bs ( IsoTpLink ) send_timer_st ( IsoTpLink ) send_wtf_count ( IsoTpLink ) SF_DL ( IsoTpSingleFrame )","title":"s"},{"location":"docs/class_members/#t","text":"type ( IsoTpConsecutiveFrame , IsoTpFirstFrameShort , IsoTpFlowControl , IsoTpPciType , IsoTpSingleFrame )","title":"t"},{"location":"docs/class_member_functions/","text":"Class Member Functions \u00b6 Nothing related to Class Member Functions found.","title":"Class Member Functions"},{"location":"docs/class_member_functions/#class-member-functions","text":"Nothing related to Class Member Functions found.","title":"Class Member Functions"},{"location":"docs/class_member_variables/","text":"Class Member Variables \u00b6 a \u00b6 as ( IsoTpCanMessage ) b \u00b6 BS ( IsoTpFlowControl ) c \u00b6 common ( IsoTpCanMessage ) consecutive_frame ( IsoTpCanMessage ) call_count ( MockCanState ) d \u00b6 data_array ( IsoTpCanMessage ) data ( IsoTpConsecutiveFrame , IsoTpFirstFrameShort , IsoTpSingleFrame ) f \u00b6 first_frame_long ( IsoTpCanMessage ) first_frame_short ( IsoTpCanMessage ) flow_control ( IsoTpCanMessage ) FF_DL_high ( IsoTpFirstFrameShort ) FF_DL_low ( IsoTpFirstFrameShort ) FS ( IsoTpFlowControl ) l \u00b6 last_data ( MockCanState ) last_id ( MockCanState ) last_size ( MockCanState ) p \u00b6 ptr ( IsoTpDataArray ) r \u00b6 reserve ( IsoTpFlowControl ) receive_arbitration_id ( IsoTpLink ) receive_bs_count ( IsoTpLink ) receive_buf_size ( IsoTpLink ) receive_buffer ( IsoTpLink ) receive_offset ( IsoTpLink ) receive_protocol_result ( IsoTpLink ) receive_size ( IsoTpLink ) receive_sn ( IsoTpLink ) receive_status ( IsoTpLink ) receive_timer_cr ( IsoTpLink ) reserve_1 ( IsoTpPciType ) reserve_2 ( IsoTpPciType ) return_value ( MockCanState ) s \u00b6 single_frame ( IsoTpCanMessage ) SN ( IsoTpConsecutiveFrame ) STmin ( IsoTpFlowControl ) send_arbitration_id ( IsoTpLink ) send_bs_remain ( IsoTpLink ) send_buf_size ( IsoTpLink ) send_buffer ( IsoTpLink ) send_offset ( IsoTpLink ) send_protocol_result ( IsoTpLink ) send_size ( IsoTpLink ) send_sn ( IsoTpLink ) send_st_min_us ( IsoTpLink ) send_status ( IsoTpLink ) send_timer_bs ( IsoTpLink ) send_timer_st ( IsoTpLink ) send_wtf_count ( IsoTpLink ) SF_DL ( IsoTpSingleFrame ) t \u00b6 type ( IsoTpConsecutiveFrame , IsoTpFirstFrameShort , IsoTpFlowControl , IsoTpPciType , IsoTpSingleFrame )","title":"Class Member Variables"},{"location":"docs/class_member_variables/#class-member-variables","text":"","title":"Class Member Variables"},{"location":"docs/class_member_variables/#a","text":"as ( IsoTpCanMessage )","title":"a"},{"location":"docs/class_member_variables/#b","text":"BS ( IsoTpFlowControl )","title":"b"},{"location":"docs/class_member_variables/#c","text":"common ( IsoTpCanMessage ) consecutive_frame ( IsoTpCanMessage ) call_count ( MockCanState )","title":"c"},{"location":"docs/class_member_variables/#d","text":"data_array ( IsoTpCanMessage ) data ( IsoTpConsecutiveFrame , IsoTpFirstFrameShort , IsoTpSingleFrame )","title":"d"},{"location":"docs/class_member_variables/#f","text":"first_frame_long ( IsoTpCanMessage ) first_frame_short ( IsoTpCanMessage ) flow_control ( IsoTpCanMessage ) FF_DL_high ( IsoTpFirstFrameShort ) FF_DL_low ( IsoTpFirstFrameShort ) FS ( IsoTpFlowControl )","title":"f"},{"location":"docs/class_member_variables/#l","text":"last_data ( MockCanState ) last_id ( MockCanState ) last_size ( MockCanState )","title":"l"},{"location":"docs/class_member_variables/#p","text":"ptr ( IsoTpDataArray )","title":"p"},{"location":"docs/class_member_variables/#r","text":"reserve ( IsoTpFlowControl ) receive_arbitration_id ( IsoTpLink ) receive_bs_count ( IsoTpLink ) receive_buf_size ( IsoTpLink ) receive_buffer ( IsoTpLink ) receive_offset ( IsoTpLink ) receive_protocol_result ( IsoTpLink ) receive_size ( IsoTpLink ) receive_sn ( IsoTpLink ) receive_status ( IsoTpLink ) receive_timer_cr ( IsoTpLink ) reserve_1 ( IsoTpPciType ) reserve_2 ( IsoTpPciType ) return_value ( MockCanState )","title":"r"},{"location":"docs/class_member_variables/#s","text":"single_frame ( IsoTpCanMessage ) SN ( IsoTpConsecutiveFrame ) STmin ( IsoTpFlowControl ) send_arbitration_id ( IsoTpLink ) send_bs_remain ( IsoTpLink ) send_buf_size ( IsoTpLink ) send_buffer ( IsoTpLink ) send_offset ( IsoTpLink ) send_protocol_result ( IsoTpLink ) send_size ( IsoTpLink ) send_sn ( IsoTpLink ) send_st_min_us ( IsoTpLink ) send_status ( IsoTpLink ) send_timer_bs ( IsoTpLink ) send_timer_st ( IsoTpLink ) send_wtf_count ( IsoTpLink ) SF_DL ( IsoTpSingleFrame )","title":"s"},{"location":"docs/class_member_variables/#t","text":"type ( IsoTpConsecutiveFrame , IsoTpFirstFrameShort , IsoTpFlowControl , IsoTpPciType , IsoTpSingleFrame )","title":"t"},{"location":"docs/class_member_typedefs/","text":"Class Member Typedefs \u00b6 Nothing related to Class Member Typedefs found.","title":"Class Member Typedefs"},{"location":"docs/class_member_typedefs/#class-member-typedefs","text":"Nothing related to Class Member Typedefs found.","title":"Class Member Typedefs"},{"location":"docs/class_member_enums/","text":"Class Member Enums \u00b6 Nothing related to Class Member Enums found.","title":"Class Member Enums"},{"location":"docs/class_member_enums/#class-member-enums","text":"Nothing related to Class Member Enums found.","title":"Class Member Enums"},{"location":"docs/namespace_members/","text":"Namespace Members \u00b6 Nothing related to Namespace Members found.","title":"Namespace Members"},{"location":"docs/namespace_members/#namespace-members","text":"Nothing related to Namespace Members found.","title":"Namespace Members"},{"location":"docs/namespace_member_functions/","text":"Namespace Member Functions \u00b6 Nothing related to Namespace Member Functions found.","title":"Namespace Member Functions"},{"location":"docs/namespace_member_functions/#namespace-member-functions","text":"Nothing related to Namespace Member Functions found.","title":"Namespace Member Functions"},{"location":"docs/namespace_member_variables/","text":"Namespace Member Variables \u00b6 Nothing related to Namespace Member Variables found.","title":"Namespace Member Variables"},{"location":"docs/namespace_member_variables/#namespace-member-variables","text":"Nothing related to Namespace Member Variables found.","title":"Namespace Member Variables"},{"location":"docs/namespace_member_typedefs/","text":"Namespace Member Typedefs \u00b6 Nothing related to Namespace Member Typedefs found.","title":"Namespace Member Typedefs"},{"location":"docs/namespace_member_typedefs/#namespace-member-typedefs","text":"Nothing related to Namespace Member Typedefs found.","title":"Namespace Member Typedefs"},{"location":"docs/namespace_member_enums/","text":"Namespace Member Enums \u00b6 Nothing related to Namespace Member Enums found.","title":"Namespace Member Enums"},{"location":"docs/namespace_member_enums/#namespace-member-enums","text":"Nothing related to Namespace Member Enums found.","title":"Namespace Member Enums"},{"location":"docs/functions/","text":"Functions \u00b6 i \u00b6 ISOTP_PACKED_STRUCT ( isotp_defines.h ) isotp_receive_consecutive_frame ( isotp.c ) isotp_receive_first_frame ( isotp.c ) isotp_receive_flow_control_frame ( isotp.c ) isotp_receive_single_frame ( isotp.c ) isotp_send_consecutive_frame ( isotp.c ) isotp_send_first_frame ( isotp.c ) isotp_send_flow_control ( isotp.c ) isotp_send_single_frame ( isotp.c ) isotp_st_min_to_us ( isotp.c ) isotp_us_to_st_min ( isotp.c ) m \u00b6 main ( linux_socket.c ) r \u00b6 reset_mocks ( isotp_test_support.h )","title":"Functions"},{"location":"docs/functions/#functions","text":"","title":"Functions"},{"location":"docs/functions/#i","text":"ISOTP_PACKED_STRUCT ( isotp_defines.h ) isotp_receive_consecutive_frame ( isotp.c ) isotp_receive_first_frame ( isotp.c ) isotp_receive_flow_control_frame ( isotp.c ) isotp_receive_single_frame ( isotp.c ) isotp_send_consecutive_frame ( isotp.c ) isotp_send_first_frame ( isotp.c ) isotp_send_flow_control ( isotp.c ) isotp_send_single_frame ( isotp.c ) isotp_st_min_to_us ( isotp.c ) isotp_us_to_st_min ( isotp.c )","title":"i"},{"location":"docs/functions/#m","text":"main ( linux_socket.c )","title":"m"},{"location":"docs/functions/#r","text":"reset_mocks ( isotp_test_support.h )","title":"r"},{"location":"docs/macros/","text":"Macros \u00b6 i \u00b6 ISO_TP_DEFAULT_BLOCK_SIZE ( isotp_config.h ) ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ( isotp_config.h ) ISO_TP_DEFAULT_ST_MIN_US ( isotp_config.h ) ISO_TP_FRAME_PADDING_VALUE ( isotp_config.h ) ISO_TP_MAX_WFT_NUMBER ( isotp_config.h ) ISOTP_INVALID_BS ( isotp_defines.h ) ISOTP_MAX_ERROR_MSG_SIZE ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_ERROR ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_INVALID_FS ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_OK ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_TIMEOUT_A ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_TIMEOUT_BS ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_TIMEOUT_CR ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_UNEXP_PDU ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_WFT_OVRN ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_WRONG_SN ( isotp_defines.h ) ISOTP_RET_ERROR ( isotp_defines.h ) ISOTP_RET_INPROGRESS ( isotp_defines.h ) ISOTP_RET_LENGTH ( isotp_defines.h ) ISOTP_RET_NOSPACE ( isotp_defines.h ) ISOTP_RET_NO_DATA ( isotp_defines.h ) ISOTP_RET_OK ( isotp_defines.h ) ISOTP_RET_OVERFLOW ( isotp_defines.h ) ISOTP_RET_TIMEOUT ( isotp_defines.h ) ISOTP_RET_WRONG_SN ( isotp_defines.h ) IsoTpTimeAfter ( isotp_defines.h ) l \u00b6 LE32TOH ( isotp_defines.h ) s \u00b6 SEC_TO_US ( linux_socket.c ) _ \u00b6 _CAN_INTERFACE ( linux_socket.c ) _ISOTP_BUFSIZE ( linux_socket.c ) _ISOTP_CAN_ID ( linux_socket.c )","title":"Macros"},{"location":"docs/macros/#macros","text":"","title":"Macros"},{"location":"docs/macros/#i","text":"ISO_TP_DEFAULT_BLOCK_SIZE ( isotp_config.h ) ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ( isotp_config.h ) ISO_TP_DEFAULT_ST_MIN_US ( isotp_config.h ) ISO_TP_FRAME_PADDING_VALUE ( isotp_config.h ) ISO_TP_MAX_WFT_NUMBER ( isotp_config.h ) ISOTP_INVALID_BS ( isotp_defines.h ) ISOTP_MAX_ERROR_MSG_SIZE ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_ERROR ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_INVALID_FS ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_OK ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_TIMEOUT_A ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_TIMEOUT_BS ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_TIMEOUT_CR ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_UNEXP_PDU ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_WFT_OVRN ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_WRONG_SN ( isotp_defines.h ) ISOTP_RET_ERROR ( isotp_defines.h ) ISOTP_RET_INPROGRESS ( isotp_defines.h ) ISOTP_RET_LENGTH ( isotp_defines.h ) ISOTP_RET_NOSPACE ( isotp_defines.h ) ISOTP_RET_NO_DATA ( isotp_defines.h ) ISOTP_RET_OK ( isotp_defines.h ) ISOTP_RET_OVERFLOW ( isotp_defines.h ) ISOTP_RET_TIMEOUT ( isotp_defines.h ) ISOTP_RET_WRONG_SN ( isotp_defines.h ) IsoTpTimeAfter ( isotp_defines.h )","title":"i"},{"location":"docs/macros/#l","text":"LE32TOH ( isotp_defines.h )","title":"l"},{"location":"docs/macros/#s","text":"SEC_TO_US ( linux_socket.c )","title":"s"},{"location":"docs/macros/#_","text":"_CAN_INTERFACE ( linux_socket.c ) _ISOTP_BUFSIZE ( linux_socket.c ) _ISOTP_CAN_ID ( linux_socket.c )","title":"_"},{"location":"docs/variables/","text":"Variables \u00b6 g \u00b6 g_isotpRecvBuf ( linux_socket.c ) g_isotpSendBuf ( linux_socket.c ) g_link ( linux_socket.c ) g_can_state ( isotp_test_support.h ) g_debug_call_count ( isotp_test_support.h ) g_now_us ( isotp_test_support.h ) i \u00b6 IsoTpFlowStatus ( isotp_defines.h ) IsoTpProtocolControlInformation ( isotp_defines.h ) IsoTpReceiveStatusTypes ( isotp_defines.h ) IsoTpSendStatusTypes ( isotp_defines.h ) _ \u00b6 _socket ( linux_socket.c )","title":"Variables"},{"location":"docs/variables/#variables","text":"","title":"Variables"},{"location":"docs/variables/#g","text":"g_isotpRecvBuf ( linux_socket.c ) g_isotpSendBuf ( linux_socket.c ) g_link ( linux_socket.c ) g_can_state ( isotp_test_support.h ) g_debug_call_count ( isotp_test_support.h ) g_now_us ( isotp_test_support.h )","title":"g"},{"location":"docs/variables/#i","text":"IsoTpFlowStatus ( isotp_defines.h ) IsoTpProtocolControlInformation ( isotp_defines.h ) IsoTpReceiveStatusTypes ( isotp_defines.h ) IsoTpSendStatusTypes ( isotp_defines.h )","title":"i"},{"location":"docs/variables/#_","text":"_socket ( linux_socket.c )","title":"_"},{"location":"docs/links/","text":"Related Pages Modules Class List Namespace ListNamespace List Namespace Members Namespace Member Functions Namespace Member Variables Namespace Member Typedefs Namespace Member Enumerations Class Index Class Hierarchy Class Members Class Member Functions Class Member Variables Class Member Typedefs Class Member Enumerations Files File Variables File Functions File Macros","title":"Links"}]}