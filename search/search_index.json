{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ISO-TP C Implementation \u00b6 ISO-TP (ISO 15765-2) protocol implementation in C for CAN communication. This library implements ISO-TP frame fragmentation and reassembly and provides a simple interface for sending and receiving messages longer than 8 bytes. Key features \u00b6 Full ISO-TP support (Single, First, Consecutive, Flow Control) Configurable timing parameters and buffer sizes Minimal dependencies and easy integration in embedded systems Main-loop (polling) operation, no mandatory OS required Optional callbacks for TX and RX completion Intended use \u00b6 The library is intended for embedded systems and CAN applications where deterministic behavior, small memory footprint, and simple integration are required. Quick start \u00b6 Build (CMake) \u00b6 This project uses CMake presets. You can build with the default generator or use the provided presets for Debug, Release, and Unit Tests. Quick local build: cmake -B build cmake --build build Build with presets: cmake --preset \"ISO-TP[Debug]\" -B \"build/ISO-TP[Debug]\" cmake --build \"build/ISO-TP[Debug]\" cmake --preset \"ISO-TP[Release]\" -B \"build/ISO-TP[Release]\" cmake --build \"build/ISO-TP[Release]\" Unit tests (requires Google Test): cmake --preset \"ISO-TP[UnitTests]\" -B \"build/ISO-TP[UnitTests]\" cmake --build \"build/ISO-TP[UnitTests]\" ctest --test-dir \"build/ISO-TP[UnitTests]\" --output-on-failure Integration \u00b6 Add the header and configure user functions in isotp_user.h : #include \"isotp.h\" static uint8_t tx_buffer [ 4095 ]; static uint8_t rx_buffer [ 4095 ]; static IsoTpLink link ; isotp_init_link ( & link , 0x7E0 , tx_buffer , sizeof ( tx_buffer ), rx_buffer , sizeof ( rx_buffer )); In the application loop: isotp_on_can_message ( & link , can_data , can_len ); isotp_poll ( & link ); uint8_t payload [ 4095 ]; uint32_t payload_len = 0 ; if ( isotp_receive ( & link , payload , sizeof ( payload ), & payload_len ) == ISOTP_RET_OK ) { /* process payload */ } Core API \u00b6 Key public functions (see API Reference ): isotp_init_link() - link initialization isotp_destroy_link() - release link resources isotp_send() / isotp_send_with_id() - send ISO-TP messages isotp_on_can_message() - handle incoming CAN frames isotp_poll() - handle timeouts and send consecutive frames isotp_receive() - fetch reassembled payload Configuration \u00b6 Configuration is done statically via files in inc/ : inc/isotp_config.h - timing parameters, sizes, enable/disable options inc/isotp_user.h - user functions (CAN send, time, debug) inc/isotp_defines.h - protocol definitions and error codes More details in Configuration Guide . Usage model \u00b6 The library does not manage the CAN bus; it expects a CAN send function and delivery of received frames via isotp_on_can_message() . The isotp_poll() function must be called periodically in the main loop (or in a thread/RTOS) at an appropriate frequency. Examples \u00b6 The Linux SocketCAN example is in example/linux_socket/linux_socket.c . Tests \u00b6 Unit tests are located in the tests/ directory. Details are in the project documentation and the test files. To run unit tests locally (requires Google Test): cmake --preset \"ISO-TP[UnitTests]\" -B \"build/ISO-TP[UnitTests]\" cmake --build \"build/ISO-TP[UnitTests]\" ctest --test-dir \"build/ISO-TP[UnitTests]\" --output-on-failure Install Google Test on Ubuntu/Debian: sudo apt-get update sudo apt-get install -y libgtest-dev Limitations and notes \u00b6 The maximum payload length depends on configuration and buffers. Provide sufficiently large TX/RX buffers (typically 4095 bytes for full ISO-TP). For realtime systems, adjust timeouts and polling frequency. Documentation \u00b6 API Reference Configuration Guide Getting Started License \u00b6 Details in LICENSE .","title":"Home"},{"location":"#iso-tp-c-implementation","text":"ISO-TP (ISO 15765-2) protocol implementation in C for CAN communication. This library implements ISO-TP frame fragmentation and reassembly and provides a simple interface for sending and receiving messages longer than 8 bytes.","title":"ISO-TP C Implementation"},{"location":"#key-features","text":"Full ISO-TP support (Single, First, Consecutive, Flow Control) Configurable timing parameters and buffer sizes Minimal dependencies and easy integration in embedded systems Main-loop (polling) operation, no mandatory OS required Optional callbacks for TX and RX completion","title":"Key features"},{"location":"#intended-use","text":"The library is intended for embedded systems and CAN applications where deterministic behavior, small memory footprint, and simple integration are required.","title":"Intended use"},{"location":"#quick-start","text":"","title":"Quick start"},{"location":"#build-cmake","text":"This project uses CMake presets. You can build with the default generator or use the provided presets for Debug, Release, and Unit Tests. Quick local build: cmake -B build cmake --build build Build with presets: cmake --preset \"ISO-TP[Debug]\" -B \"build/ISO-TP[Debug]\" cmake --build \"build/ISO-TP[Debug]\" cmake --preset \"ISO-TP[Release]\" -B \"build/ISO-TP[Release]\" cmake --build \"build/ISO-TP[Release]\" Unit tests (requires Google Test): cmake --preset \"ISO-TP[UnitTests]\" -B \"build/ISO-TP[UnitTests]\" cmake --build \"build/ISO-TP[UnitTests]\" ctest --test-dir \"build/ISO-TP[UnitTests]\" --output-on-failure","title":"Build (CMake)"},{"location":"#integration","text":"Add the header and configure user functions in isotp_user.h : #include \"isotp.h\" static uint8_t tx_buffer [ 4095 ]; static uint8_t rx_buffer [ 4095 ]; static IsoTpLink link ; isotp_init_link ( & link , 0x7E0 , tx_buffer , sizeof ( tx_buffer ), rx_buffer , sizeof ( rx_buffer )); In the application loop: isotp_on_can_message ( & link , can_data , can_len ); isotp_poll ( & link ); uint8_t payload [ 4095 ]; uint32_t payload_len = 0 ; if ( isotp_receive ( & link , payload , sizeof ( payload ), & payload_len ) == ISOTP_RET_OK ) { /* process payload */ }","title":"Integration"},{"location":"#core-api","text":"Key public functions (see API Reference ): isotp_init_link() - link initialization isotp_destroy_link() - release link resources isotp_send() / isotp_send_with_id() - send ISO-TP messages isotp_on_can_message() - handle incoming CAN frames isotp_poll() - handle timeouts and send consecutive frames isotp_receive() - fetch reassembled payload","title":"Core API"},{"location":"#configuration","text":"Configuration is done statically via files in inc/ : inc/isotp_config.h - timing parameters, sizes, enable/disable options inc/isotp_user.h - user functions (CAN send, time, debug) inc/isotp_defines.h - protocol definitions and error codes More details in Configuration Guide .","title":"Configuration"},{"location":"#usage-model","text":"The library does not manage the CAN bus; it expects a CAN send function and delivery of received frames via isotp_on_can_message() . The isotp_poll() function must be called periodically in the main loop (or in a thread/RTOS) at an appropriate frequency.","title":"Usage model"},{"location":"#examples","text":"The Linux SocketCAN example is in example/linux_socket/linux_socket.c .","title":"Examples"},{"location":"#tests","text":"Unit tests are located in the tests/ directory. Details are in the project documentation and the test files. To run unit tests locally (requires Google Test): cmake --preset \"ISO-TP[UnitTests]\" -B \"build/ISO-TP[UnitTests]\" cmake --build \"build/ISO-TP[UnitTests]\" ctest --test-dir \"build/ISO-TP[UnitTests]\" --output-on-failure Install Google Test on Ubuntu/Debian: sudo apt-get update sudo apt-get install -y libgtest-dev","title":"Tests"},{"location":"#limitations-and-notes","text":"The maximum payload length depends on configuration and buffers. Provide sufficiently large TX/RX buffers (typically 4095 bytes for full ISO-TP). For realtime systems, adjust timeouts and polling frequency.","title":"Limitations and notes"},{"location":"#documentation","text":"API Reference Configuration Guide Getting Started","title":"Documentation"},{"location":"#license","text":"Details in LICENSE .","title":"License"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2019-2024 Li Shen & Co-Operators Copyright (c) 2024 Simon Cahill & Contributors. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"api/","text":"API Reference \u00b6 This API reference is generated from the source code with Doxygen and mirrors the public headers and their supporting modules. Main Components \u00b6 isotp.h - Public ISO-TP API: link lifecycle, send/receive, and polling. isotp_config.h - Build-time configuration parameters and feature toggles. isotp_user.h - User hooks for CAN transmit, timing, and debug output. isotp_defines.h - Internal protocol definitions, frame layouts, and enums. Tests \u00b6 isotp_test_support.h - Test utilities used by unit tests. Examples \u00b6 linux_socket.c - Linux SocketCAN example showing end-to-end usage. Modules and Functions \u00b6 Browse the modules overview for a grouped view of public interfaces, configuration, and user hooks. Each module page links to the relevant functions and data structures. Data Structures \u00b6 Core ISO-TP structures, such as the link state and frame types, are documented in the generated API pages referenced above. For more details on protocol behavior, see ISO 15765-2.","title":"API Reference"},{"location":"api/#api-reference","text":"This API reference is generated from the source code with Doxygen and mirrors the public headers and their supporting modules.","title":"API Reference"},{"location":"api/#main-components","text":"isotp.h - Public ISO-TP API: link lifecycle, send/receive, and polling. isotp_config.h - Build-time configuration parameters and feature toggles. isotp_user.h - User hooks for CAN transmit, timing, and debug output. isotp_defines.h - Internal protocol definitions, frame layouts, and enums.","title":"Main Components"},{"location":"api/#tests","text":"isotp_test_support.h - Test utilities used by unit tests.","title":"Tests"},{"location":"api/#examples","text":"linux_socket.c - Linux SocketCAN example showing end-to-end usage.","title":"Examples"},{"location":"api/#modules-and-functions","text":"Browse the modules overview for a grouped view of public interfaces, configuration, and user hooks. Each module page links to the relevant functions and data structures.","title":"Modules and Functions"},{"location":"api/#data-structures","text":"Core ISO-TP structures, such as the link state and frame types, are documented in the generated API pages referenced above. For more details on protocol behavior, see ISO 15765-2.","title":"Data Structures"},{"location":"configuration/","text":"Configuration Guide \u00b6 isotp_config.h \u00b6 The isotp_config.h file defines compile-time configuration options that control ISO-TP timing, limits, and optional features. These settings are applied at build time and affect both send and receive behavior for single- and multi-frame traffic. Key Configuration Options \u00b6 ISO_TP_DEFAULT_BLOCK_SIZE - Default receiver block size (BS). This limits how many consecutive frames can be sent before the receiver responds with Flow Control. ISO_TP_DEFAULT_ST_MIN_US - Default minimum separation time (ST_min) in microseconds between consecutive frames. ISO_TP_MAX_WFT_NUMBER - Maximum number of consecutive Flow Control Wait frames the receiver may send. ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US - Default response timeout (microseconds) while waiting for Flow Control during a multi-frame transfer. ISO_TP_FRAME_PADDING - Enable ISO-TP frame padding by default. ISO_TP_FRAME_PADDING_VALUE - Padding byte value used when padding is enabled. ISO_TP_USER_SEND_CAN_ARG - Adds an extra user argument to isotp_user_send_can() . ISO_TP_TRANSMIT_COMPLETE_CALLBACK - Enable transmission complete callback support. ISO_TP_RECEIVE_COMPLETE_CALLBACK - Enable receive complete callback support. User Callbacks \u00b6 Define user callbacks in isotp_user.h for: - CAN frame transmission - Timing source access (microsecond timebase) - Optional debug output - Optional transmit/receive completion hooks (when enabled) More Information \u00b6 See inc/isotp_config.h for detailed configuration parameters and inline documentation for each option.","title":"Configuration"},{"location":"configuration/#configuration-guide","text":"","title":"Configuration Guide"},{"location":"configuration/#isotp_configh","text":"The isotp_config.h file defines compile-time configuration options that control ISO-TP timing, limits, and optional features. These settings are applied at build time and affect both send and receive behavior for single- and multi-frame traffic.","title":"isotp_config.h"},{"location":"configuration/#key-configuration-options","text":"ISO_TP_DEFAULT_BLOCK_SIZE - Default receiver block size (BS). This limits how many consecutive frames can be sent before the receiver responds with Flow Control. ISO_TP_DEFAULT_ST_MIN_US - Default minimum separation time (ST_min) in microseconds between consecutive frames. ISO_TP_MAX_WFT_NUMBER - Maximum number of consecutive Flow Control Wait frames the receiver may send. ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US - Default response timeout (microseconds) while waiting for Flow Control during a multi-frame transfer. ISO_TP_FRAME_PADDING - Enable ISO-TP frame padding by default. ISO_TP_FRAME_PADDING_VALUE - Padding byte value used when padding is enabled. ISO_TP_USER_SEND_CAN_ARG - Adds an extra user argument to isotp_user_send_can() . ISO_TP_TRANSMIT_COMPLETE_CALLBACK - Enable transmission complete callback support. ISO_TP_RECEIVE_COMPLETE_CALLBACK - Enable receive complete callback support.","title":"Key Configuration Options"},{"location":"configuration/#user-callbacks","text":"Define user callbacks in isotp_user.h for: - CAN frame transmission - Timing source access (microsecond timebase) - Optional debug output - Optional transmit/receive completion hooks (when enabled)","title":"User Callbacks"},{"location":"configuration/#more-information","text":"See inc/isotp_config.h for detailed configuration parameters and inline documentation for each option.","title":"More Information"},{"location":"guide/","text":"Getting Started \u00b6 This guide shows how to initialize an ISO-TP link, send and receive payloads, and integrate the polling model into your main loop. For full definitions and return codes, see the API Reference . Initialization \u00b6 Create a link and provide dedicated TX/RX buffers. The link tracks protocol state and owns the buffers you pass in. #include \"isotp.h\" static uint8_t tx_buffer [ 4095 ]; static uint8_t rx_buffer [ 4095 ]; static IsoTpLink link ; isotp_init_link ( & link , 0x7E0 , tx_buffer , sizeof ( tx_buffer ), rx_buffer , sizeof ( rx_buffer )); The sendid you pass to isotp_init_link() is used for transmissions. Make sure the receiver expects this ID. Sending Data \u00b6 Single-frame payloads are sent immediately. Multi-frame payloads are queued and sent by isotp_poll() . uint8_t data [] = { 0x01 , 0x02 , 0x03 }; int ret = isotp_send ( & link , data , sizeof ( data )); if ( ret == ISOTP_RET_OK || ret == ISOTP_RET_INPROGRESS ) { /* OK: in progress or already sent */ } Use isotp_send_with_id() for functional addressing or when you need to send with a different arbitration ID. Receiving Data \u00b6 Deliver each incoming CAN frame to the ISO-TP handler and poll periodically. When a complete payload is available, call isotp_receive() to copy it out. isotp_on_can_message ( & link , can_data , can_len ); isotp_poll ( & link ); uint8_t payload [ 4095 ]; uint32_t payload_len = 0 ; if ( isotp_receive ( & link , payload , sizeof ( payload ), & payload_len ) == ISOTP_RET_OK ) { /* process payload */ } Polling Model \u00b6 ISO-TP timing is managed by isotp_poll() . Call it from the main loop or a dedicated thread with a consistent period that matches your timing needs. The poll function drives consecutive frame sending and timeout handling. User Hooks \u00b6 Implement user hooks in isotp_user.h for: CAN frame transmission (required) Microsecond time source (required) Optional debug output Optional TX/RX completion callbacks (when enabled in configuration) Example Flow (Linux SocketCAN) \u00b6 The Linux example creates a PF_CAN / SOCK_RAW socket, binds it to a CAN interface, and then runs the ISO-TP loop: Initialize the SocketCAN interface and bind the socket. Call isotp_init_link() with buffers and the transmit ID. In a loop, read CAN frames, pass them to isotp_on_can_message() , and call isotp_poll() . When isotp_receive() returns ISOTP_RET_OK , the payload is complete. See the Linux SocketCAN example for a full working reference: example/linux_socket/linux_socket.c . Configuration \u00b6 See Configuration Guide for detailed configuration options. Error Handling \u00b6 The library returns status codes for common conditions: ISOTP_RET_OK - Success ISOTP_RET_INPROGRESS - Multi-frame transfer in progress ISOTP_RET_OVERFLOW - Payload larger than available buffer ISOTP_RET_NO_DATA - No complete payload available yet For the full list and detailed meanings, refer to the API Reference .","title":"Getting Started"},{"location":"guide/#getting-started","text":"This guide shows how to initialize an ISO-TP link, send and receive payloads, and integrate the polling model into your main loop. For full definitions and return codes, see the API Reference .","title":"Getting Started"},{"location":"guide/#initialization","text":"Create a link and provide dedicated TX/RX buffers. The link tracks protocol state and owns the buffers you pass in. #include \"isotp.h\" static uint8_t tx_buffer [ 4095 ]; static uint8_t rx_buffer [ 4095 ]; static IsoTpLink link ; isotp_init_link ( & link , 0x7E0 , tx_buffer , sizeof ( tx_buffer ), rx_buffer , sizeof ( rx_buffer )); The sendid you pass to isotp_init_link() is used for transmissions. Make sure the receiver expects this ID.","title":"Initialization"},{"location":"guide/#sending-data","text":"Single-frame payloads are sent immediately. Multi-frame payloads are queued and sent by isotp_poll() . uint8_t data [] = { 0x01 , 0x02 , 0x03 }; int ret = isotp_send ( & link , data , sizeof ( data )); if ( ret == ISOTP_RET_OK || ret == ISOTP_RET_INPROGRESS ) { /* OK: in progress or already sent */ } Use isotp_send_with_id() for functional addressing or when you need to send with a different arbitration ID.","title":"Sending Data"},{"location":"guide/#receiving-data","text":"Deliver each incoming CAN frame to the ISO-TP handler and poll periodically. When a complete payload is available, call isotp_receive() to copy it out. isotp_on_can_message ( & link , can_data , can_len ); isotp_poll ( & link ); uint8_t payload [ 4095 ]; uint32_t payload_len = 0 ; if ( isotp_receive ( & link , payload , sizeof ( payload ), & payload_len ) == ISOTP_RET_OK ) { /* process payload */ }","title":"Receiving Data"},{"location":"guide/#polling-model","text":"ISO-TP timing is managed by isotp_poll() . Call it from the main loop or a dedicated thread with a consistent period that matches your timing needs. The poll function drives consecutive frame sending and timeout handling.","title":"Polling Model"},{"location":"guide/#user-hooks","text":"Implement user hooks in isotp_user.h for: CAN frame transmission (required) Microsecond time source (required) Optional debug output Optional TX/RX completion callbacks (when enabled in configuration)","title":"User Hooks"},{"location":"guide/#example-flow-linux-socketcan","text":"The Linux example creates a PF_CAN / SOCK_RAW socket, binds it to a CAN interface, and then runs the ISO-TP loop: Initialize the SocketCAN interface and bind the socket. Call isotp_init_link() with buffers and the transmit ID. In a loop, read CAN frames, pass them to isotp_on_can_message() , and call isotp_poll() . When isotp_receive() returns ISOTP_RET_OK , the payload is complete. See the Linux SocketCAN example for a full working reference: example/linux_socket/linux_socket.c .","title":"Example Flow (Linux SocketCAN)"},{"location":"guide/#configuration","text":"See Configuration Guide for detailed configuration options.","title":"Configuration"},{"location":"guide/#error-handling","text":"The library returns status codes for common conditions: ISOTP_RET_OK - Success ISOTP_RET_INPROGRESS - Multi-frame transfer in progress ISOTP_RET_OVERFLOW - Payload larger than available buffer ISOTP_RET_NO_DATA - No complete payload available yet For the full list and detailed meanings, refer to the API Reference .","title":"Error Handling"},{"location":"iso_15765_project_structure/","text":"ISO-15765: Project Structure and Integration Test Coverage \u00b6 This document describes the project structure for ISO-15765 (ISO-TP) tests and the current integration test coverage. It highlights what is implemented and verified, and where there are gaps in implementation or tests. Project Structure (Relevant to ISO-TP and Tests) \u00b6 ISO-TP core (protocol implementation): src/isotp.c Public API and link model: isotp.h Protocol definitions and result codes: inc/isotp_defines.h Build-time configuration (BS, STmin, timeouts, options): inc/isotp_config.h Platform hooks (CAN, time, debug): inc/isotp_user.h Python bindings and CAN/time mocks (test layer): examples/python_api/src Integration tests (Python): tests/integration Integration test documentation: docs/integration_tests Implemented and Verified by Integration Tests \u00b6 The following areas are implemented in the core and covered by integration tests: API smoke + input errors + return codes Tests: tests/integration/test_api_endpoints.py Docs: integration_tests/api_endpoints.md Scope: SF/MF smoke, sender N_Bs timeout, invalid args, overflow, in-progress. API validation (arguments) Tests: tests/integration/test_api_validation.py Docs: integration_tests/api_validation.md Scope: zero buffers, bufsize=0, block_size > 255. Buffer limits and overflow handling Tests: tests/integration/test_buffer_limits.py Docs: integration_tests/buffer_limits.md Scope: ISOTP_RET_OVERFLOW, truncation on receive, ISOTP_RET_INPROGRESS. Multi-frame behavior (FF/CF, SN, BS, STmin, timeouts) Tests: tests/integration/test_multi_frame.py Docs: integration_tests/multi_frame.md Scope: MF roundtrip, 8/9/14/15 boundaries, max payload 4095B, BS=1 and BS=0, STmin, N_Bs/N_Cr timeouts, UNEXP_PDU and WRONG_SN errors. FlowControl (FS=WAIT/CONTINUE/OVERFLOW) AUTOSAR CanTp: tests/integration/test_cantp.py , Docs: integration_tests/cantp.md , Tests: tests/integration/test_flow_control.py Docs: integration_tests/flow_control.md Scope: WAIT -> CONTINUE, WFT overrun, FS=Overflow, BS and STmin parameters. Timing (N_Bs, N_Cr, STmin, BS) Tests: tests/integration/test_timing.py Docs: integration_tests/timing.md Scope: N_Bs and N_Cr timeouts, STmin enforcement, BS=1 roundtrip. Implementation Gaps (Explicitly Identified) \u00b6 N_As, N_Ar, N_Br, N_Cs are not enforced in the core yet (marked as xfail in timing tests). See: tests/integration/test_timing.py and integration_tests/timing.md . Integration Test Gaps (Areas to Expand) \u00b6 Based on current integration tests, there is no visible coverage for: isotp_send_with_id (functional addressing) in isotp.h . tx_done_cb and rx_done_cb callbacks (when enabled in config) in isotp.h and inc/isotp_config.h . ISO_TP_FRAME_PADDING (padded frames) in inc/isotp_config.h . ISOTP_RET_NOSPACE scenarios (retry send) in inc/isotp_defines.h . Invalid FlowControl (e.g., invalid FS) and other protocol errors beyond UNEXP_PDU and WRONG_SN in inc/isotp_defines.h . Transfers larger than 4095B (long FF) - no integration tests yet. Notes \u00b6 Integration tests are executed via Python bindings and CAN/time mocks (see examples/python_api/src ). This document only covers integration test coverage. Unit tests may cover additional areas.","title":"ISO-15765 Project Structure"},{"location":"iso_15765_project_structure/#iso-15765-project-structure-and-integration-test-coverage","text":"This document describes the project structure for ISO-15765 (ISO-TP) tests and the current integration test coverage. It highlights what is implemented and verified, and where there are gaps in implementation or tests.","title":"ISO-15765: Project Structure and Integration Test Coverage"},{"location":"iso_15765_project_structure/#project-structure-relevant-to-iso-tp-and-tests","text":"ISO-TP core (protocol implementation): src/isotp.c Public API and link model: isotp.h Protocol definitions and result codes: inc/isotp_defines.h Build-time configuration (BS, STmin, timeouts, options): inc/isotp_config.h Platform hooks (CAN, time, debug): inc/isotp_user.h Python bindings and CAN/time mocks (test layer): examples/python_api/src Integration tests (Python): tests/integration Integration test documentation: docs/integration_tests","title":"Project Structure (Relevant to ISO-TP and Tests)"},{"location":"iso_15765_project_structure/#implemented-and-verified-by-integration-tests","text":"The following areas are implemented in the core and covered by integration tests: API smoke + input errors + return codes Tests: tests/integration/test_api_endpoints.py Docs: integration_tests/api_endpoints.md Scope: SF/MF smoke, sender N_Bs timeout, invalid args, overflow, in-progress. API validation (arguments) Tests: tests/integration/test_api_validation.py Docs: integration_tests/api_validation.md Scope: zero buffers, bufsize=0, block_size > 255. Buffer limits and overflow handling Tests: tests/integration/test_buffer_limits.py Docs: integration_tests/buffer_limits.md Scope: ISOTP_RET_OVERFLOW, truncation on receive, ISOTP_RET_INPROGRESS. Multi-frame behavior (FF/CF, SN, BS, STmin, timeouts) Tests: tests/integration/test_multi_frame.py Docs: integration_tests/multi_frame.md Scope: MF roundtrip, 8/9/14/15 boundaries, max payload 4095B, BS=1 and BS=0, STmin, N_Bs/N_Cr timeouts, UNEXP_PDU and WRONG_SN errors. FlowControl (FS=WAIT/CONTINUE/OVERFLOW) AUTOSAR CanTp: tests/integration/test_cantp.py , Docs: integration_tests/cantp.md , Tests: tests/integration/test_flow_control.py Docs: integration_tests/flow_control.md Scope: WAIT -> CONTINUE, WFT overrun, FS=Overflow, BS and STmin parameters. Timing (N_Bs, N_Cr, STmin, BS) Tests: tests/integration/test_timing.py Docs: integration_tests/timing.md Scope: N_Bs and N_Cr timeouts, STmin enforcement, BS=1 roundtrip.","title":"Implemented and Verified by Integration Tests"},{"location":"iso_15765_project_structure/#implementation-gaps-explicitly-identified","text":"N_As, N_Ar, N_Br, N_Cs are not enforced in the core yet (marked as xfail in timing tests). See: tests/integration/test_timing.py and integration_tests/timing.md .","title":"Implementation Gaps (Explicitly Identified)"},{"location":"iso_15765_project_structure/#integration-test-gaps-areas-to-expand","text":"Based on current integration tests, there is no visible coverage for: isotp_send_with_id (functional addressing) in isotp.h . tx_done_cb and rx_done_cb callbacks (when enabled in config) in isotp.h and inc/isotp_config.h . ISO_TP_FRAME_PADDING (padded frames) in inc/isotp_config.h . ISOTP_RET_NOSPACE scenarios (retry send) in inc/isotp_defines.h . Invalid FlowControl (e.g., invalid FS) and other protocol errors beyond UNEXP_PDU and WRONG_SN in inc/isotp_defines.h . Transfers larger than 4095B (long FF) - no integration tests yet.","title":"Integration Test Gaps (Areas to Expand)"},{"location":"iso_15765_project_structure/#notes","text":"Integration tests are executed via Python bindings and CAN/time mocks (see examples/python_api/src ). This document only covers integration test coverage. Unit tests may cover additional areas.","title":"Notes"},{"location":"examples/linux_socket/","text":"Linux socket \u00b6 How to use \u00b6 This example shows how to run ISO-TP-C on Linux SocketCAN. Below are the build steps and a short explanation of what the program does. Requirements \u00b6 Linux with SocketCAN enabled. A configured CAN interface (default: slcan0 ). C99 compiler and CMake >= 3.20. Example configuration \u00b6 In examples/linux_socket/linux_socket.c the key parameters are defined: _CAN_INTERFACE - CAN interface name (e.g., can0 , slcan0 ). _ISOTP_CAN_ID - CAN ID used for ISO-TP transmission. _ISOTP_BUFSIZE - TX/RX buffer size (>= 4095 for full ISO-TP support). Build \u00b6 From the examples directory: cd examples/linux_socket cmake -G \"Unix Makefiles\" -B build cmake --build build Run \u00b6 After building, run the application: ./build/LinuxSocketExample The program listens on CAN, assembles ISO-TP frames, and prints the received payload. What the program does \u00b6 Creates a PF_CAN / SOCK_RAW socket and binds it to the CAN interface. Initializes the ISO-TP link via isotp_init_link() . Receives CAN frames in a loop, passes them to isotp_on_can_message() , and calls isotp_poll() . When receive_status is ISOTP_RECEIVE_STATUS_FULL , reads data with isotp_receive() and prints it as hex. Notes \u00b6 The CAN interface and CAN ID must match the configuration on the other side. The example uses extended identifiers ( CAN_EFF_FLAG ).","title":"Linux SocketCAN"},{"location":"examples/linux_socket/#linux-socket","text":"","title":"Linux socket"},{"location":"examples/linux_socket/#how-to-use","text":"This example shows how to run ISO-TP-C on Linux SocketCAN. Below are the build steps and a short explanation of what the program does.","title":"How to use"},{"location":"examples/linux_socket/#requirements","text":"Linux with SocketCAN enabled. A configured CAN interface (default: slcan0 ). C99 compiler and CMake >= 3.20.","title":"Requirements"},{"location":"examples/linux_socket/#example-configuration","text":"In examples/linux_socket/linux_socket.c the key parameters are defined: _CAN_INTERFACE - CAN interface name (e.g., can0 , slcan0 ). _ISOTP_CAN_ID - CAN ID used for ISO-TP transmission. _ISOTP_BUFSIZE - TX/RX buffer size (>= 4095 for full ISO-TP support).","title":"Example configuration"},{"location":"examples/linux_socket/#build","text":"From the examples directory: cd examples/linux_socket cmake -G \"Unix Makefiles\" -B build cmake --build build","title":"Build"},{"location":"examples/linux_socket/#run","text":"After building, run the application: ./build/LinuxSocketExample The program listens on CAN, assembles ISO-TP frames, and prints the received payload.","title":"Run"},{"location":"examples/linux_socket/#what-the-program-does","text":"Creates a PF_CAN / SOCK_RAW socket and binds it to the CAN interface. Initializes the ISO-TP link via isotp_init_link() . Receives CAN frames in a loop, passes them to isotp_on_can_message() , and calls isotp_poll() . When receive_status is ISOTP_RECEIVE_STATUS_FULL , reads data with isotp_receive() and prints it as hex.","title":"What the program does"},{"location":"examples/linux_socket/#notes","text":"The CAN interface and CAN ID must match the configuration on the other side. The example uses extended identifiers ( CAN_EFF_FLAG ).","title":"Notes"},{"location":"examples/python_api/","text":"Python C API \u00b6 How to use \u00b6 This example shows how to build and use the ISO-TP-C Python C extension module from the examples/python_api directory. Requirements \u00b6 C99 compiler and CMake >= 3.20. Python 3 with development headers (Python3::Python). A build toolchain supported by CMake (e.g. MSVC, Ninja, Make). Build \u00b6 From the examples/python_api directory: cd examples/python_api cmake -G \"Unix Makefiles\" -B build cmake --build build The build outputs a Python extension module: Windows: build/pyisotp.pyd Linux: build/pyisotp.so (or the platform-specific Python extension suffix) Use \u00b6 Start Python from the same directory (or add the build folder to PYTHONPATH ) and import the module: python -c \"import sys; sys.path.insert(0, 'build'); import pyisotp; print(pyisotp)\" Basic usage (initialize, send, poll, receive): import sys sys . path . insert ( 0 , \"build\" ) import pyisotp # Parameters: send_id, tx_buf_size, rx_buf_size link = pyisotp . init ( 0x123 , 4095 , 4095 ) # Send data pyisotp . send ( link , b \" \\x01\\x02\\x03\\x04 \" ) # Poll the link (for timeouts/state updates) pyisotp . poll ( link ) # Receive data (returns bytes or None) payload = pyisotp . receive ( link , 4095 ) print ( payload ) Mock helpers \u00b6 The module exposes mock utilities used by tests: pyisotp.mock_enable_drop(enable) - enable or disable frame dropping. pyisotp.mock_disable_fc(enable) - enable or disable flow control handling for testing. pyisotp.time_advance(ms) - advance virtual time in milliseconds. pyisotp.time_set(ms) - set virtual time in milliseconds. pyisotp.time_reset() - reset virtual time to zero. pyisotp.get_last_protocol_result(link) - get the last protocol result for a link. Test \u00b6 Integration tests are optional and use the Python module. Configure CMake with ISOTP_INTEGRATION_TESTS=ON , then build and run the tests from the build tree. Example: cd examples/python_api cmake -G \"Unix Makefiles\" -B build -DISOTP_INTEGRATION_TESTS = ON cmake --build build --target integration_tests If your test runner does not find the module, ensure the build output folder is on PYTHONPATH or run tests from the build directory.","title":"Python API"},{"location":"examples/python_api/#python-c-api","text":"","title":"Python C API"},{"location":"examples/python_api/#how-to-use","text":"This example shows how to build and use the ISO-TP-C Python C extension module from the examples/python_api directory.","title":"How to use"},{"location":"examples/python_api/#requirements","text":"C99 compiler and CMake >= 3.20. Python 3 with development headers (Python3::Python). A build toolchain supported by CMake (e.g. MSVC, Ninja, Make).","title":"Requirements"},{"location":"examples/python_api/#build","text":"From the examples/python_api directory: cd examples/python_api cmake -G \"Unix Makefiles\" -B build cmake --build build The build outputs a Python extension module: Windows: build/pyisotp.pyd Linux: build/pyisotp.so (or the platform-specific Python extension suffix)","title":"Build"},{"location":"examples/python_api/#use","text":"Start Python from the same directory (or add the build folder to PYTHONPATH ) and import the module: python -c \"import sys; sys.path.insert(0, 'build'); import pyisotp; print(pyisotp)\" Basic usage (initialize, send, poll, receive): import sys sys . path . insert ( 0 , \"build\" ) import pyisotp # Parameters: send_id, tx_buf_size, rx_buf_size link = pyisotp . init ( 0x123 , 4095 , 4095 ) # Send data pyisotp . send ( link , b \" \\x01\\x02\\x03\\x04 \" ) # Poll the link (for timeouts/state updates) pyisotp . poll ( link ) # Receive data (returns bytes or None) payload = pyisotp . receive ( link , 4095 ) print ( payload )","title":"Use"},{"location":"examples/python_api/#mock-helpers","text":"The module exposes mock utilities used by tests: pyisotp.mock_enable_drop(enable) - enable or disable frame dropping. pyisotp.mock_disable_fc(enable) - enable or disable flow control handling for testing. pyisotp.time_advance(ms) - advance virtual time in milliseconds. pyisotp.time_set(ms) - set virtual time in milliseconds. pyisotp.time_reset() - reset virtual time to zero. pyisotp.get_last_protocol_result(link) - get the last protocol result for a link.","title":"Mock helpers"},{"location":"examples/python_api/#test","text":"Integration tests are optional and use the Python module. Configure CMake with ISOTP_INTEGRATION_TESTS=ON , then build and run the tests from the build tree. Example: cd examples/python_api cmake -G \"Unix Makefiles\" -B build -DISOTP_INTEGRATION_TESTS = ON cmake --build build --target integration_tests If your test runner does not find the module, ensure the build output folder is on PYTHONPATH or run tests from the build directory.","title":"Test"},{"location":"integration_tests/api_endpoints/","text":"API Endpoints Integration Tests \u00b6 This document describes the API endpoint coverage tests for the Python bindings. The suite acts as a targeted smoke test plus edge-case checks not covered in other files. Scope \u00b6 The tests in tests/integration/test_api_endpoints.py cover: Basic API smoke for single-frame traffic. Multi-frame smoke roundtrip. Return codes for overflow and in-progress send. Input validation errors. Raw CAN injection error cases (unexpected CF, wrong SN). Helper Utilities \u00b6 The test file includes helpers for reuse: _poll_until_receive: poll and receive with optional mock time advance. _make_payload: deterministic payload generator. _ff_frame / _cf_frame: raw FF/CF builders for injection tests. Test Cases \u00b6 test_api_endpoints_smoke \u00b6 Setup: initialize link and verify protocol constant availability. Action: send and receive a single-frame payload; test drop and N_Bs timeout. Expectation: payload matches, drop yields None, timeout updates protocol result. test_api_endpoints_smoke_multi_frame \u00b6 Setup: initialize link. Action: send a 20-byte payload and poll until receive. Expectation: payload matches. test_api_endpoints_return_codes \u00b6 Setup: small send buffer to force overflow. Action: send oversized payload; then send twice to hit in-progress case. Expectation: returns ISOTP_RET_OVERFLOW and ISOTP_RET_INPROGRESS. test_api_endpoints_validation_errors \u00b6 Setup: invalid arguments for init, receive, and set_fc_params. Action: call endpoints with invalid inputs. Expectation: ValueError is raised. test_api_endpoints_inject_unexpected_cf \u00b6 Setup: initialize link. Action: inject a CF without FF. Expectation: receiver protocol result is ISOTP_PROTOCOL_RESULT_UNEXP_PDU. test_api_endpoints_inject_wrong_sn \u00b6 Setup: initialize link. Action: inject FF then CF with wrong SN. Expectation: receiver protocol result is ISOTP_PROTOCOL_RESULT_WRONG_SN. Notes \u00b6 Raw CAN injection uses pyisotp.inject_can. Timing uses mock time where needed. Update this document if API behavior changes.","title":"API Endpoints Integration Tests"},{"location":"integration_tests/api_endpoints/#api-endpoints-integration-tests","text":"This document describes the API endpoint coverage tests for the Python bindings. The suite acts as a targeted smoke test plus edge-case checks not covered in other files.","title":"API Endpoints Integration Tests"},{"location":"integration_tests/api_endpoints/#scope","text":"The tests in tests/integration/test_api_endpoints.py cover: Basic API smoke for single-frame traffic. Multi-frame smoke roundtrip. Return codes for overflow and in-progress send. Input validation errors. Raw CAN injection error cases (unexpected CF, wrong SN).","title":"Scope"},{"location":"integration_tests/api_endpoints/#helper-utilities","text":"The test file includes helpers for reuse: _poll_until_receive: poll and receive with optional mock time advance. _make_payload: deterministic payload generator. _ff_frame / _cf_frame: raw FF/CF builders for injection tests.","title":"Helper Utilities"},{"location":"integration_tests/api_endpoints/#test-cases","text":"","title":"Test Cases"},{"location":"integration_tests/api_endpoints/#test_api_endpoints_smoke","text":"Setup: initialize link and verify protocol constant availability. Action: send and receive a single-frame payload; test drop and N_Bs timeout. Expectation: payload matches, drop yields None, timeout updates protocol result.","title":"test_api_endpoints_smoke"},{"location":"integration_tests/api_endpoints/#test_api_endpoints_smoke_multi_frame","text":"Setup: initialize link. Action: send a 20-byte payload and poll until receive. Expectation: payload matches.","title":"test_api_endpoints_smoke_multi_frame"},{"location":"integration_tests/api_endpoints/#test_api_endpoints_return_codes","text":"Setup: small send buffer to force overflow. Action: send oversized payload; then send twice to hit in-progress case. Expectation: returns ISOTP_RET_OVERFLOW and ISOTP_RET_INPROGRESS.","title":"test_api_endpoints_return_codes"},{"location":"integration_tests/api_endpoints/#test_api_endpoints_validation_errors","text":"Setup: invalid arguments for init, receive, and set_fc_params. Action: call endpoints with invalid inputs. Expectation: ValueError is raised.","title":"test_api_endpoints_validation_errors"},{"location":"integration_tests/api_endpoints/#test_api_endpoints_inject_unexpected_cf","text":"Setup: initialize link. Action: inject a CF without FF. Expectation: receiver protocol result is ISOTP_PROTOCOL_RESULT_UNEXP_PDU.","title":"test_api_endpoints_inject_unexpected_cf"},{"location":"integration_tests/api_endpoints/#test_api_endpoints_inject_wrong_sn","text":"Setup: initialize link. Action: inject FF then CF with wrong SN. Expectation: receiver protocol result is ISOTP_PROTOCOL_RESULT_WRONG_SN.","title":"test_api_endpoints_inject_wrong_sn"},{"location":"integration_tests/api_endpoints/#notes","text":"Raw CAN injection uses pyisotp.inject_can. Timing uses mock time where needed. Update this document if API behavior changes.","title":"Notes"},{"location":"integration_tests/api_validation/","text":"API Validation Integration Tests \u00b6 This document describes API validation tests for the Python bindings. The suite ensures argument validation errors are raised consistently. Scope \u00b6 The tests in tests/integration/test_api_validation.py cover: Invalid buffer sizes when initializing a link. Invalid receive buffer size. Invalid FlowControl parameters. Test Cases \u00b6 test_init_rejects_zero_buffers \u00b6 Setup: attempt to initialize with zero send or receive buffer size. Expectation: ValueError is raised. test_receive_rejects_invalid_bufsize \u00b6 Setup: initialize link with valid buffers. Action: call receive with bufsize 0. Expectation: ValueError is raised. test_set_fc_params_rejects_large_block_size \u00b6 Setup: initialize link with valid buffers. Action: call set_fc_params with block_size > 255. Expectation: ValueError is raised. Notes \u00b6 These tests validate Python API guards only. Update this document if input validation behavior changes.","title":"API Validation Integration Tests"},{"location":"integration_tests/api_validation/#api-validation-integration-tests","text":"This document describes API validation tests for the Python bindings. The suite ensures argument validation errors are raised consistently.","title":"API Validation Integration Tests"},{"location":"integration_tests/api_validation/#scope","text":"The tests in tests/integration/test_api_validation.py cover: Invalid buffer sizes when initializing a link. Invalid receive buffer size. Invalid FlowControl parameters.","title":"Scope"},{"location":"integration_tests/api_validation/#test-cases","text":"","title":"Test Cases"},{"location":"integration_tests/api_validation/#test_init_rejects_zero_buffers","text":"Setup: attempt to initialize with zero send or receive buffer size. Expectation: ValueError is raised.","title":"test_init_rejects_zero_buffers"},{"location":"integration_tests/api_validation/#test_receive_rejects_invalid_bufsize","text":"Setup: initialize link with valid buffers. Action: call receive with bufsize 0. Expectation: ValueError is raised.","title":"test_receive_rejects_invalid_bufsize"},{"location":"integration_tests/api_validation/#test_set_fc_params_rejects_large_block_size","text":"Setup: initialize link with valid buffers. Action: call set_fc_params with block_size > 255. Expectation: ValueError is raised.","title":"test_set_fc_params_rejects_large_block_size"},{"location":"integration_tests/api_validation/#notes","text":"These tests validate Python API guards only. Update this document if input validation behavior changes.","title":"Notes"},{"location":"integration_tests/buffer_limits/","text":"Buffer Limits Integration Tests \u00b6 This document describes buffer limit tests for the Python API. The suite focuses on overflow handling, truncation, and in-progress status. Scope \u00b6 The tests in tests/integration/test_buffer_limits.py cover: Sending payloads larger than send buffer. Receiving into smaller buffers (truncation). Calling send while a transfer is already in progress. Test Cases \u00b6 test_send_overflow_returns_code \u00b6 Setup: link with send buffer size 8. Action: send a 9-byte payload. Expectation: return code is ISOTP_RET_OVERFLOW. test_receive_truncates_payload \u00b6 Setup: link with sufficient buffers and a 20-byte payload. Action: receive with payload_size 10. Expectation: returned payload is truncated to 10 bytes. test_send_in_progress_returns_code \u00b6 Setup: multi-frame payload to keep sender busy. Action: call send again before completion. Expectation: second send returns ISOTP_RET_INPROGRESS. Notes \u00b6 These tests rely on synchronous polling and mock CAN. Update if send/receive return codes change.","title":"Buffer Limits Integration Tests"},{"location":"integration_tests/buffer_limits/#buffer-limits-integration-tests","text":"This document describes buffer limit tests for the Python API. The suite focuses on overflow handling, truncation, and in-progress status.","title":"Buffer Limits Integration Tests"},{"location":"integration_tests/buffer_limits/#scope","text":"The tests in tests/integration/test_buffer_limits.py cover: Sending payloads larger than send buffer. Receiving into smaller buffers (truncation). Calling send while a transfer is already in progress.","title":"Scope"},{"location":"integration_tests/buffer_limits/#test-cases","text":"","title":"Test Cases"},{"location":"integration_tests/buffer_limits/#test_send_overflow_returns_code","text":"Setup: link with send buffer size 8. Action: send a 9-byte payload. Expectation: return code is ISOTP_RET_OVERFLOW.","title":"test_send_overflow_returns_code"},{"location":"integration_tests/buffer_limits/#test_receive_truncates_payload","text":"Setup: link with sufficient buffers and a 20-byte payload. Action: receive with payload_size 10. Expectation: returned payload is truncated to 10 bytes.","title":"test_receive_truncates_payload"},{"location":"integration_tests/buffer_limits/#test_send_in_progress_returns_code","text":"Setup: multi-frame payload to keep sender busy. Action: call send again before completion. Expectation: second send returns ISOTP_RET_INPROGRESS.","title":"test_send_in_progress_returns_code"},{"location":"integration_tests/buffer_limits/#notes","text":"These tests rely on synchronous polling and mock CAN. Update if send/receive return codes change.","title":"Notes"},{"location":"integration_tests/cantp/","text":"AUTOSAR CanTp Integration Tests \u00b6 This document describes the AUTOSAR CanTp-oriented integration tests added for the Python API. The suite focuses on FlowControl WAIT handling and selected CanTp timing and protocol behaviors. All tests are deterministic and use mock time. Scope \u00b6 The tests in tests/integration/test_cantp.py cover: FlowControl WAIT handling: single WAIT then CONTINUE, and WFT overrun. N_Bs and N_Cr timeouts using configurable timeouts. STmin and Block Size (BS) flow control parameters. Unexpected PDU handling (CF without FF). Helper Utilities \u00b6 The test file defines helpers for clarity and reuse: _poll_until_receive: polls until a payload is received or steps are exhausted. _make_payload: creates deterministic payloads. _fc_frame: builds raw FlowControl frames (FS/BS/STmin). Test Cases \u00b6 test_wait_frame_then_continue \u00b6 Setup: multi-frame payload and injected FC frames. Action: inject FC Wait followed by FC Continue. Expectation: payload is transmitted and received successfully. test_wait_frame_overrun \u00b6 Setup: multi-frame payload and injected FC Wait frames. Action: inject FC Wait twice (exceeding ISO_TP_MAX_WFT_NUMBER). Expectation: sender protocol result is ISOTP_PROTOCOL_RESULT_WFT_OVRN. test_cantp_timeout_n_bs \u00b6 Setup: N_Bs=30 ms, N_Cr=10 ms, FlowControl disabled. Action: send a multi-frame payload, advance mock time. Expectation: sender protocol result is ISOTP_PROTOCOL_RESULT_TIMEOUT_BS. test_cantp_timeout_n_cr \u00b6 Setup: N_Bs=30 ms, N_Cr=10 ms, CAN drop enabled after FF. Action: send a multi-frame payload, advance mock time. Expectation: receiver protocol result is ISOTP_PROTOCOL_RESULT_TIMEOUT_CR. test_cantp_stmin_and_bs \u00b6 Setup: BS=1, STmin=5 ms. Action: send a multi-frame payload, poll with mock time. Expectation: payload is received intact. test_cantp_unexpected_pdu \u00b6 Setup: default link. Action: inject a CF without a prior FF. Expectation: receiver protocol result is ISOTP_PROTOCOL_RESULT_UNEXP_PDU. Notes \u00b6 Raw CAN injection uses pyisotp.inject_can. Timing uses mock time via pyisotp.time_advance. Update this document if core behavior or timeout defaults change.","title":"AUTOSAR CanTp Integration Tests"},{"location":"integration_tests/cantp/#autosar-cantp-integration-tests","text":"This document describes the AUTOSAR CanTp-oriented integration tests added for the Python API. The suite focuses on FlowControl WAIT handling and selected CanTp timing and protocol behaviors. All tests are deterministic and use mock time.","title":"AUTOSAR CanTp Integration Tests"},{"location":"integration_tests/cantp/#scope","text":"The tests in tests/integration/test_cantp.py cover: FlowControl WAIT handling: single WAIT then CONTINUE, and WFT overrun. N_Bs and N_Cr timeouts using configurable timeouts. STmin and Block Size (BS) flow control parameters. Unexpected PDU handling (CF without FF).","title":"Scope"},{"location":"integration_tests/cantp/#helper-utilities","text":"The test file defines helpers for clarity and reuse: _poll_until_receive: polls until a payload is received or steps are exhausted. _make_payload: creates deterministic payloads. _fc_frame: builds raw FlowControl frames (FS/BS/STmin).","title":"Helper Utilities"},{"location":"integration_tests/cantp/#test-cases","text":"","title":"Test Cases"},{"location":"integration_tests/cantp/#test_wait_frame_then_continue","text":"Setup: multi-frame payload and injected FC frames. Action: inject FC Wait followed by FC Continue. Expectation: payload is transmitted and received successfully.","title":"test_wait_frame_then_continue"},{"location":"integration_tests/cantp/#test_wait_frame_overrun","text":"Setup: multi-frame payload and injected FC Wait frames. Action: inject FC Wait twice (exceeding ISO_TP_MAX_WFT_NUMBER). Expectation: sender protocol result is ISOTP_PROTOCOL_RESULT_WFT_OVRN.","title":"test_wait_frame_overrun"},{"location":"integration_tests/cantp/#test_cantp_timeout_n_bs","text":"Setup: N_Bs=30 ms, N_Cr=10 ms, FlowControl disabled. Action: send a multi-frame payload, advance mock time. Expectation: sender protocol result is ISOTP_PROTOCOL_RESULT_TIMEOUT_BS.","title":"test_cantp_timeout_n_bs"},{"location":"integration_tests/cantp/#test_cantp_timeout_n_cr","text":"Setup: N_Bs=30 ms, N_Cr=10 ms, CAN drop enabled after FF. Action: send a multi-frame payload, advance mock time. Expectation: receiver protocol result is ISOTP_PROTOCOL_RESULT_TIMEOUT_CR.","title":"test_cantp_timeout_n_cr"},{"location":"integration_tests/cantp/#test_cantp_stmin_and_bs","text":"Setup: BS=1, STmin=5 ms. Action: send a multi-frame payload, poll with mock time. Expectation: payload is received intact.","title":"test_cantp_stmin_and_bs"},{"location":"integration_tests/cantp/#test_cantp_unexpected_pdu","text":"Setup: default link. Action: inject a CF without a prior FF. Expectation: receiver protocol result is ISOTP_PROTOCOL_RESULT_UNEXP_PDU.","title":"test_cantp_unexpected_pdu"},{"location":"integration_tests/cantp/#notes","text":"Raw CAN injection uses pyisotp.inject_can. Timing uses mock time via pyisotp.time_advance. Update this document if core behavior or timeout defaults change.","title":"Notes"},{"location":"integration_tests/flow_control/","text":"FlowControl Integration Tests \u00b6 This document describes FlowControl-specific integration tests. The suite verifies protocol result handling for FlowControl overflow. Scope \u00b6 The tests in tests/integration/test_flow_control.py cover: FlowControl Overflow (FS=Overflow) behavior on the sender. Test Cases \u00b6 test_flow_control_overflow_sets_protocol_result \u00b6 Setup: multi-frame payload and injected FlowControl Overflow frame. Action: inject FC frame with FS=Overflow. Expectation: sender protocol result is ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW. Notes \u00b6 Raw CAN injection uses pyisotp.inject_can. Update this document if FlowControl result handling changes.","title":"FlowControl Integration Tests"},{"location":"integration_tests/flow_control/#flowcontrol-integration-tests","text":"This document describes FlowControl-specific integration tests. The suite verifies protocol result handling for FlowControl overflow.","title":"FlowControl Integration Tests"},{"location":"integration_tests/flow_control/#scope","text":"The tests in tests/integration/test_flow_control.py cover: FlowControl Overflow (FS=Overflow) behavior on the sender.","title":"Scope"},{"location":"integration_tests/flow_control/#test-cases","text":"","title":"Test Cases"},{"location":"integration_tests/flow_control/#test_flow_control_overflow_sets_protocol_result","text":"Setup: multi-frame payload and injected FlowControl Overflow frame. Action: inject FC frame with FS=Overflow. Expectation: sender protocol result is ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW.","title":"test_flow_control_overflow_sets_protocol_result"},{"location":"integration_tests/flow_control/#notes","text":"Raw CAN injection uses pyisotp.inject_can. Update this document if FlowControl result handling changes.","title":"Notes"},{"location":"integration_tests/multi_frame/","text":"Multi-Frame Integration Tests \u00b6 This document describes the multi-frame integration tests for the Python API. The suite focuses on ISO-TP multi-frame behavior, flow control, timing, and protocol error handling. All tests are deterministic and rely on mock time. Scope \u00b6 The tests in tests/integration/test_multi_frame.py cover: Basic multi-frame roundtrip. Boundary payload sizes that switch between single/multi frame logic. Maximum payload size (4095 bytes). FlowControl parameters: Block Size (BS) and STmin. Multi-frame timeouts N_Bs and N_Cr. Protocol errors: unexpected CF and wrong sequence number (SN). Helper Utilities \u00b6 The test file defines helpers to keep test logic consistent: _poll_until_receive: polls and attempts receive until a payload appears. _make_payload: builds deterministic byte payloads. _ff_frame / _cf_frame: create raw FF/CF frames for injection. Test Cases \u00b6 test_multi_frame_roundtrip \u00b6 Setup: default link with large buffers. Action: send a 12-byte payload (multi-frame). Expectation: received payload matches the sent payload. test_multi_frame_boundary_sizes \u00b6 Setup: default link with larger buffers. Action: send sizes 8, 9, 14, and 15 bytes. Expectation: each payload is received intact. test_multi_frame_max_payload \u00b6 Setup: link with 4096-byte buffers. Action: send a 4095-byte payload. Expectation: received payload matches the sent payload. test_multi_frame_bs_one_stmin \u00b6 Setup: BS=1 and STmin=5 ms. Action: send a multi-frame payload, poll with mock time. Expectation: payload is received intact. test_multi_frame_bs_unlimited_stmin \u00b6 Setup: BS=0 (unlimited) and STmin=5 ms. Action: send a multi-frame payload, poll with mock time. Expectation: payload is received intact. test_multi_frame_timeout_n_bs \u00b6 Setup: N_Bs=50 ms, N_Cr=50 ms, FlowControl disabled. Action: send a multi-frame payload, advance mock time. Expectation: sender protocol result is ISOTP_PROTOCOL_RESULT_TIMEOUT_BS. test_multi_frame_timeout_n_cr \u00b6 Setup: N_Bs=50 ms, N_Cr=10 ms, CAN drop enabled. Action: send a multi-frame payload, advance mock time. Expectation: receiver protocol result is ISOTP_PROTOCOL_RESULT_TIMEOUT_CR. test_multi_frame_unexpected_cf \u00b6 Setup: default link. Action: inject a CF without a prior FF. Expectation: receiver protocol result is ISOTP_PROTOCOL_RESULT_UNEXP_PDU. test_multi_frame_wrong_sn \u00b6 Setup: default link. Action: inject FF followed by CF with wrong SN. Expectation: receiver protocol result is ISOTP_PROTOCOL_RESULT_WRONG_SN. Notes \u00b6 Raw CAN injection uses pyisotp.inject_can. Timing uses mock time via pyisotp.time_advance. If FlowControl defaults or protocol rules change, update this document and tests together.","title":"Multi-Frame Integration Tests"},{"location":"integration_tests/multi_frame/#multi-frame-integration-tests","text":"This document describes the multi-frame integration tests for the Python API. The suite focuses on ISO-TP multi-frame behavior, flow control, timing, and protocol error handling. All tests are deterministic and rely on mock time.","title":"Multi-Frame Integration Tests"},{"location":"integration_tests/multi_frame/#scope","text":"The tests in tests/integration/test_multi_frame.py cover: Basic multi-frame roundtrip. Boundary payload sizes that switch between single/multi frame logic. Maximum payload size (4095 bytes). FlowControl parameters: Block Size (BS) and STmin. Multi-frame timeouts N_Bs and N_Cr. Protocol errors: unexpected CF and wrong sequence number (SN).","title":"Scope"},{"location":"integration_tests/multi_frame/#helper-utilities","text":"The test file defines helpers to keep test logic consistent: _poll_until_receive: polls and attempts receive until a payload appears. _make_payload: builds deterministic byte payloads. _ff_frame / _cf_frame: create raw FF/CF frames for injection.","title":"Helper Utilities"},{"location":"integration_tests/multi_frame/#test-cases","text":"","title":"Test Cases"},{"location":"integration_tests/multi_frame/#test_multi_frame_roundtrip","text":"Setup: default link with large buffers. Action: send a 12-byte payload (multi-frame). Expectation: received payload matches the sent payload.","title":"test_multi_frame_roundtrip"},{"location":"integration_tests/multi_frame/#test_multi_frame_boundary_sizes","text":"Setup: default link with larger buffers. Action: send sizes 8, 9, 14, and 15 bytes. Expectation: each payload is received intact.","title":"test_multi_frame_boundary_sizes"},{"location":"integration_tests/multi_frame/#test_multi_frame_max_payload","text":"Setup: link with 4096-byte buffers. Action: send a 4095-byte payload. Expectation: received payload matches the sent payload.","title":"test_multi_frame_max_payload"},{"location":"integration_tests/multi_frame/#test_multi_frame_bs_one_stmin","text":"Setup: BS=1 and STmin=5 ms. Action: send a multi-frame payload, poll with mock time. Expectation: payload is received intact.","title":"test_multi_frame_bs_one_stmin"},{"location":"integration_tests/multi_frame/#test_multi_frame_bs_unlimited_stmin","text":"Setup: BS=0 (unlimited) and STmin=5 ms. Action: send a multi-frame payload, poll with mock time. Expectation: payload is received intact.","title":"test_multi_frame_bs_unlimited_stmin"},{"location":"integration_tests/multi_frame/#test_multi_frame_timeout_n_bs","text":"Setup: N_Bs=50 ms, N_Cr=50 ms, FlowControl disabled. Action: send a multi-frame payload, advance mock time. Expectation: sender protocol result is ISOTP_PROTOCOL_RESULT_TIMEOUT_BS.","title":"test_multi_frame_timeout_n_bs"},{"location":"integration_tests/multi_frame/#test_multi_frame_timeout_n_cr","text":"Setup: N_Bs=50 ms, N_Cr=10 ms, CAN drop enabled. Action: send a multi-frame payload, advance mock time. Expectation: receiver protocol result is ISOTP_PROTOCOL_RESULT_TIMEOUT_CR.","title":"test_multi_frame_timeout_n_cr"},{"location":"integration_tests/multi_frame/#test_multi_frame_unexpected_cf","text":"Setup: default link. Action: inject a CF without a prior FF. Expectation: receiver protocol result is ISOTP_PROTOCOL_RESULT_UNEXP_PDU.","title":"test_multi_frame_unexpected_cf"},{"location":"integration_tests/multi_frame/#test_multi_frame_wrong_sn","text":"Setup: default link. Action: inject FF followed by CF with wrong SN. Expectation: receiver protocol result is ISOTP_PROTOCOL_RESULT_WRONG_SN.","title":"test_multi_frame_wrong_sn"},{"location":"integration_tests/multi_frame/#notes","text":"Raw CAN injection uses pyisotp.inject_can. Timing uses mock time via pyisotp.time_advance. If FlowControl defaults or protocol rules change, update this document and tests together.","title":"Notes"},{"location":"integration_tests/timing/","text":"Timing Tests (ISO-15765-2) \u00b6 This document describes the timing-related integration tests for the Python API. The tests use the mock time source and mock CAN driver to keep results deterministic. Scope \u00b6 The timing suite in tests/integration/test_timing.py validates these behaviors: N_Bs: max wait time for FlowControl after First Frame (FF). N_Cr: max wait time for Consecutive Frame (CF). STmin: minimum separation time between CFs. Block Size (BS): number of CFs allowed before the next FlowControl. The following parameters are listed in ISO-15765-2 but are not yet enforced in core, so they are tracked as xfail placeholders: N_As: max time to send a frame. N_Ar: max time to confirm transmission. N_Br: max time to send FlowControl. N_Cs: max time between CF transmissions. Parameter Mapping \u00b6 The core uses per-link parameters configured via the Python API: pyisotp.set_timeouts(link, n_bs_ms, n_cr_ms) sets N_Bs and N_Cr (milliseconds). pyisotp.set_fc_params(link, block_size, st_min_ms) sets BS and STmin. These values are stored in the IsoTpLink instance and are used by the protocol state machine during polling. Test Summary \u00b6 test_timeout_n_bs \u00b6 Setup: set N_Bs to 100 ms, disable FlowControl frames. Action: send a multi-frame payload, advance time with poll. Expectation: sender protocol result is ISOTP_PROTOCOL_RESULT_TIMEOUT_BS. test_timeout_n_cr \u00b6 Setup: set N_Cr to 20 ms, enable CAN frame drop to block CF delivery. Action: send a multi-frame payload, advance time with poll. Expectation: receiver protocol result is ISOTP_PROTOCOL_RESULT_TIMEOUT_CR. test_st_min_enforced \u00b6 Setup: set STmin to 10 ms, BS unlimited (0). Action: send a multi-frame payload, advance time with poll. Expectation: no full receive before 10 ms; payload arrives after STmin passes. test_block_size_one_roundtrip \u00b6 Setup: set BS to 1, STmin 0. Action: send a multi-frame payload, poll until receive completes. Expectation: full payload is received. xfail placeholders \u00b6 The following tests are present but expected to fail until core support exists: test_timeout_n_as_placeholder test_timeout_n_ar_placeholder test_timeout_n_br_placeholder test_timeout_n_cs_placeholder Notes \u00b6 All tests use mock time (pyisotp.time_advance) and do not sleep. If you change default timeouts or FlowControl behavior, update this document and the tests together.","title":"Timing Tests (ISO-15765-2)"},{"location":"integration_tests/timing/#timing-tests-iso-15765-2","text":"This document describes the timing-related integration tests for the Python API. The tests use the mock time source and mock CAN driver to keep results deterministic.","title":"Timing Tests (ISO-15765-2)"},{"location":"integration_tests/timing/#scope","text":"The timing suite in tests/integration/test_timing.py validates these behaviors: N_Bs: max wait time for FlowControl after First Frame (FF). N_Cr: max wait time for Consecutive Frame (CF). STmin: minimum separation time between CFs. Block Size (BS): number of CFs allowed before the next FlowControl. The following parameters are listed in ISO-15765-2 but are not yet enforced in core, so they are tracked as xfail placeholders: N_As: max time to send a frame. N_Ar: max time to confirm transmission. N_Br: max time to send FlowControl. N_Cs: max time between CF transmissions.","title":"Scope"},{"location":"integration_tests/timing/#parameter-mapping","text":"The core uses per-link parameters configured via the Python API: pyisotp.set_timeouts(link, n_bs_ms, n_cr_ms) sets N_Bs and N_Cr (milliseconds). pyisotp.set_fc_params(link, block_size, st_min_ms) sets BS and STmin. These values are stored in the IsoTpLink instance and are used by the protocol state machine during polling.","title":"Parameter Mapping"},{"location":"integration_tests/timing/#test-summary","text":"","title":"Test Summary"},{"location":"integration_tests/timing/#test_timeout_n_bs","text":"Setup: set N_Bs to 100 ms, disable FlowControl frames. Action: send a multi-frame payload, advance time with poll. Expectation: sender protocol result is ISOTP_PROTOCOL_RESULT_TIMEOUT_BS.","title":"test_timeout_n_bs"},{"location":"integration_tests/timing/#test_timeout_n_cr","text":"Setup: set N_Cr to 20 ms, enable CAN frame drop to block CF delivery. Action: send a multi-frame payload, advance time with poll. Expectation: receiver protocol result is ISOTP_PROTOCOL_RESULT_TIMEOUT_CR.","title":"test_timeout_n_cr"},{"location":"integration_tests/timing/#test_st_min_enforced","text":"Setup: set STmin to 10 ms, BS unlimited (0). Action: send a multi-frame payload, advance time with poll. Expectation: no full receive before 10 ms; payload arrives after STmin passes.","title":"test_st_min_enforced"},{"location":"integration_tests/timing/#test_block_size_one_roundtrip","text":"Setup: set BS to 1, STmin 0. Action: send a multi-frame payload, poll until receive completes. Expectation: full payload is received.","title":"test_block_size_one_roundtrip"},{"location":"integration_tests/timing/#xfail-placeholders","text":"The following tests are present but expected to fail until core support exists: test_timeout_n_as_placeholder test_timeout_n_ar_placeholder test_timeout_n_br_placeholder test_timeout_n_cs_placeholder","title":"xfail placeholders"},{"location":"integration_tests/timing/#notes","text":"All tests use mock time (pyisotp.time_advance) and do not sleep. If you change default timeouts or FlowControl behavior, update this document and the tests together.","title":"Notes"},{"location":"docs/annotated/","text":"Class List \u00b6 Here are the classes, structs, unions and interfaces with brief descriptions: struct IsoTpCanMessage struct IsoTpConsecutiveFrame Consecutive frame layout. struct IsoTpDataArray struct IsoTpFirstFrameShort First frame (short) layout. struct IsoTpFlowControl Flow control frame layout. struct IsoTpLink Link state for a single ISO-TP connection. struct IsoTpPciType CAN frame definitions. struct IsoTpSingleFrame Single frame layout. struct MockCanState Mock CAN state structure for testing purposes. struct can_driver_t struct can_frame_t Structure representing a CAN frame in the mock driver. namespace conftest namespace test_api_endpoints namespace test_api_validation namespace test_buffer_limits namespace test_cantp namespace test_flow_control namespace test_multi_frame namespace test_timing","title":"Class List"},{"location":"docs/annotated/#class-list","text":"Here are the classes, structs, unions and interfaces with brief descriptions: struct IsoTpCanMessage struct IsoTpConsecutiveFrame Consecutive frame layout. struct IsoTpDataArray struct IsoTpFirstFrameShort First frame (short) layout. struct IsoTpFlowControl Flow control frame layout. struct IsoTpLink Link state for a single ISO-TP connection. struct IsoTpPciType CAN frame definitions. struct IsoTpSingleFrame Single frame layout. struct MockCanState Mock CAN state structure for testing purposes. struct can_driver_t struct can_frame_t Structure representing a CAN frame in the mock driver. namespace conftest namespace test_api_endpoints namespace test_api_validation namespace test_buffer_limits namespace test_cantp namespace test_flow_control namespace test_multi_frame namespace test_timing","title":"Class List"},{"location":"docs/files/","text":"File List \u00b6 Here is a list of all files with brief descriptions: dir examples dir linux_socket file linux_socket.c dir python_api dir inc file can_driver.h file mock_can.h file mock_time.h dir src file can_driver.c file isotp_user.c file mock_can.c file mock_time.c file pyisotp.c dir inc file isotp_config.h ISO-TP configuration parameters and feature toggles. file isotp_defines.h Internal protocol definitions and type structures for ISO-TP. file isotp_user.h User callback interfaces and platform abstraction layer. file isotp.h Core ISO-TP protocol API with link management and message handling. dir src file isotp.c dir tests dir integration file conftest.py Pytest fixtures for ISO-TP integration tests. file test_api_endpoints.py Integration smoke tests for public API endpoints. file test_api_validation.py Integration tests for API input validation. file test_buffer_limits.py Integration tests for buffer limit behavior. file test_cantp.py Integration tests for CAN TP and ISO-TP behavior. file test_flow_control.py Integration tests for flow control handling. file test_multi_frame.py Integration tests for multi-frame ISO-TP transfers. file test_timing.py Integration tests for timing-related ISO-TP behavior. dir unit file gtest_isotp_destroy_link.cpp Unit tests for isotp_destroy_link. file gtest_isotp_init_link.cpp Unit tests for isotp_init_link. file gtest_isotp_on_can_message.cpp Unit tests for isotp_on_can_message. file gtest_isotp_poll.cpp Unit tests for isotp_poll. file gtest_isotp_receive.cpp Unit tests for isotp_receive. file gtest_isotp_send.cpp Unit tests for isotp_send. file gtest_isotp_send_with_id.cpp Unit tests for isotp_send_with_id. file isotp_test_mocks.cpp Test doubles for ISO-TP user callbacks. file isotp_test_support.h Test support utilities and mocks.","title":"File List"},{"location":"docs/files/#file-list","text":"Here is a list of all files with brief descriptions: dir examples dir linux_socket file linux_socket.c dir python_api dir inc file can_driver.h file mock_can.h file mock_time.h dir src file can_driver.c file isotp_user.c file mock_can.c file mock_time.c file pyisotp.c dir inc file isotp_config.h ISO-TP configuration parameters and feature toggles. file isotp_defines.h Internal protocol definitions and type structures for ISO-TP. file isotp_user.h User callback interfaces and platform abstraction layer. file isotp.h Core ISO-TP protocol API with link management and message handling. dir src file isotp.c dir tests dir integration file conftest.py Pytest fixtures for ISO-TP integration tests. file test_api_endpoints.py Integration smoke tests for public API endpoints. file test_api_validation.py Integration tests for API input validation. file test_buffer_limits.py Integration tests for buffer limit behavior. file test_cantp.py Integration tests for CAN TP and ISO-TP behavior. file test_flow_control.py Integration tests for flow control handling. file test_multi_frame.py Integration tests for multi-frame ISO-TP transfers. file test_timing.py Integration tests for timing-related ISO-TP behavior. dir unit file gtest_isotp_destroy_link.cpp Unit tests for isotp_destroy_link. file gtest_isotp_init_link.cpp Unit tests for isotp_init_link. file gtest_isotp_on_can_message.cpp Unit tests for isotp_on_can_message. file gtest_isotp_poll.cpp Unit tests for isotp_poll. file gtest_isotp_receive.cpp Unit tests for isotp_receive. file gtest_isotp_send.cpp Unit tests for isotp_send. file gtest_isotp_send_with_id.cpp Unit tests for isotp_send_with_id. file isotp_test_mocks.cpp Test doubles for ISO-TP user callbacks. file isotp_test_support.h Test support utilities and mocks.","title":"File List"},{"location":"docs/structIsoTpCanMessage/","text":"Struct IsoTpCanMessage \u00b6 ClassList > IsoTpCanMessage Public Attributes \u00b6 Type Name union IsoTpCanMessage as IsoTpPciType common IsoTpConsecutiveFrame consecutive_frame IsoTpDataArray data_array IsoTpFirstFrameLong first_frame_long IsoTpFirstFrameShort first_frame_short IsoTpFlowControl flow_control IsoTpSingleFrame single_frame Public Attributes Documentation \u00b6 variable as \u00b6 union IsoTpCanMessage IsoTpCanMessage :: as ; variable common \u00b6 IsoTpPciType IsoTpCanMessage :: common ; variable consecutive_frame \u00b6 IsoTpConsecutiveFrame IsoTpCanMessage :: consecutive_frame ; variable data_array \u00b6 IsoTpDataArray IsoTpCanMessage :: data_array ; variable first_frame_long \u00b6 IsoTpFirstFrameLong IsoTpCanMessage :: first_frame_long ; variable first_frame_short \u00b6 IsoTpFirstFrameShort IsoTpCanMessage :: first_frame_short ; variable flow_control \u00b6 IsoTpFlowControl IsoTpCanMessage :: flow_control ; variable single_frame \u00b6 IsoTpSingleFrame IsoTpCanMessage :: single_frame ; The documentation for this class was generated from the following file inc/isotp_defines.h","title":"Struct IsoTpCanMessage"},{"location":"docs/structIsoTpCanMessage/#struct-isotpcanmessage","text":"ClassList > IsoTpCanMessage","title":"Struct IsoTpCanMessage"},{"location":"docs/structIsoTpCanMessage/#public-attributes","text":"Type Name union IsoTpCanMessage as IsoTpPciType common IsoTpConsecutiveFrame consecutive_frame IsoTpDataArray data_array IsoTpFirstFrameLong first_frame_long IsoTpFirstFrameShort first_frame_short IsoTpFlowControl flow_control IsoTpSingleFrame single_frame","title":"Public Attributes"},{"location":"docs/structIsoTpCanMessage/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/structIsoTpCanMessage/#variable-as","text":"union IsoTpCanMessage IsoTpCanMessage :: as ;","title":"variable as"},{"location":"docs/structIsoTpCanMessage/#variable-common","text":"IsoTpPciType IsoTpCanMessage :: common ;","title":"variable common"},{"location":"docs/structIsoTpCanMessage/#variable-consecutive_frame","text":"IsoTpConsecutiveFrame IsoTpCanMessage :: consecutive_frame ;","title":"variable consecutive_frame"},{"location":"docs/structIsoTpCanMessage/#variable-data_array","text":"IsoTpDataArray IsoTpCanMessage :: data_array ;","title":"variable data_array"},{"location":"docs/structIsoTpCanMessage/#variable-first_frame_long","text":"IsoTpFirstFrameLong IsoTpCanMessage :: first_frame_long ;","title":"variable first_frame_long"},{"location":"docs/structIsoTpCanMessage/#variable-first_frame_short","text":"IsoTpFirstFrameShort IsoTpCanMessage :: first_frame_short ;","title":"variable first_frame_short"},{"location":"docs/structIsoTpCanMessage/#variable-flow_control","text":"IsoTpFlowControl IsoTpCanMessage :: flow_control ;","title":"variable flow_control"},{"location":"docs/structIsoTpCanMessage/#variable-single_frame","text":"IsoTpSingleFrame IsoTpCanMessage :: single_frame ; The documentation for this class was generated from the following file inc/isotp_defines.h","title":"variable single_frame"},{"location":"docs/structIsoTpConsecutiveFrame/","text":"Struct IsoTpConsecutiveFrame \u00b6 ClassList > IsoTpConsecutiveFrame Consecutive frame layout. More... #include <isotp_defines.h> Public Attributes \u00b6 Type Name uint8_t SN uint8_t data uint8_t type Detailed Description \u00b6 +-------------------------+-----+ | byte # 0 | ... | +-------------------------+-----+ | nibble # 0 | nibble # 1 | ... | +-------------+-----------+ ... + | PCIType = 0 | SN | ... | +-------------+-----------+-----+ Public Attributes Documentation \u00b6 variable SN \u00b6 uint8_t IsoTpConsecutiveFrame :: SN ; Sequence number. variable data \u00b6 uint8_t IsoTpConsecutiveFrame :: data [ 7 ]; Payload bytes. variable type \u00b6 uint8_t IsoTpConsecutiveFrame :: type ; PCI type. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"Struct IsoTpConsecutiveFrame"},{"location":"docs/structIsoTpConsecutiveFrame/#struct-isotpconsecutiveframe","text":"ClassList > IsoTpConsecutiveFrame Consecutive frame layout. More... #include <isotp_defines.h>","title":"Struct IsoTpConsecutiveFrame"},{"location":"docs/structIsoTpConsecutiveFrame/#public-attributes","text":"Type Name uint8_t SN uint8_t data uint8_t type","title":"Public Attributes"},{"location":"docs/structIsoTpConsecutiveFrame/#detailed-description","text":"+-------------------------+-----+ | byte # 0 | ... | +-------------------------+-----+ | nibble # 0 | nibble # 1 | ... | +-------------+-----------+ ... + | PCIType = 0 | SN | ... | +-------------+-----------+-----+","title":"Detailed Description"},{"location":"docs/structIsoTpConsecutiveFrame/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/structIsoTpConsecutiveFrame/#variable-sn","text":"uint8_t IsoTpConsecutiveFrame :: SN ; Sequence number.","title":"variable SN"},{"location":"docs/structIsoTpConsecutiveFrame/#variable-data","text":"uint8_t IsoTpConsecutiveFrame :: data [ 7 ]; Payload bytes.","title":"variable data"},{"location":"docs/structIsoTpConsecutiveFrame/#variable-type","text":"uint8_t IsoTpConsecutiveFrame :: type ; PCI type. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"variable type"},{"location":"docs/structIsoTpDataArray/","text":"Struct IsoTpDataArray \u00b6 ClassList > IsoTpDataArray Public Attributes \u00b6 Type Name uint8_t ptr Public Attributes Documentation \u00b6 variable ptr \u00b6 uint8_t IsoTpDataArray :: ptr [ 8 ]; The documentation for this class was generated from the following file inc/isotp_defines.h","title":"Struct IsoTpDataArray"},{"location":"docs/structIsoTpDataArray/#struct-isotpdataarray","text":"ClassList > IsoTpDataArray","title":"Struct IsoTpDataArray"},{"location":"docs/structIsoTpDataArray/#public-attributes","text":"Type Name uint8_t ptr","title":"Public Attributes"},{"location":"docs/structIsoTpDataArray/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/structIsoTpDataArray/#variable-ptr","text":"uint8_t IsoTpDataArray :: ptr [ 8 ]; The documentation for this class was generated from the following file inc/isotp_defines.h","title":"variable ptr"},{"location":"docs/structIsoTpFirstFrameShort/","text":"Struct IsoTpFirstFrameShort \u00b6 ClassList > IsoTpFirstFrameShort First frame (short) layout. More... #include <isotp_defines.h> Public Attributes \u00b6 Type Name uint8_t FF_DL_high uint8_t FF_DL_low uint8_t data uint8_t type Detailed Description \u00b6 +-------------------------+-----------------------+-----+ | byte # 0 | byte # 1 | ... | +-------------------------+-----------+-----------+-----+ | nibble # 0 | nibble # 1 | nibble # 2 | nibble # 3 | ... | +-------------+-----------+-----------+-----------+-----+ | PCIType = 1 | FF_DL | ... | +-------------+-----------+-----------------------+-----+ Public Attributes Documentation \u00b6 variable FF_DL_high \u00b6 uint8_t IsoTpFirstFrameShort :: FF_DL_high ; First-frame data length (high nibble). variable FF_DL_low \u00b6 uint8_t IsoTpFirstFrameShort :: FF_DL_low ; First-frame data length (low byte). variable data \u00b6 uint8_t IsoTpFirstFrameShort :: data [ 6 ]; Payload bytes. variable type \u00b6 uint8_t IsoTpFirstFrameShort :: type ; PCI type. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"Struct IsoTpFirstFrameShort"},{"location":"docs/structIsoTpFirstFrameShort/#struct-isotpfirstframeshort","text":"ClassList > IsoTpFirstFrameShort First frame (short) layout. More... #include <isotp_defines.h>","title":"Struct IsoTpFirstFrameShort"},{"location":"docs/structIsoTpFirstFrameShort/#public-attributes","text":"Type Name uint8_t FF_DL_high uint8_t FF_DL_low uint8_t data uint8_t type","title":"Public Attributes"},{"location":"docs/structIsoTpFirstFrameShort/#detailed-description","text":"+-------------------------+-----------------------+-----+ | byte # 0 | byte # 1 | ... | +-------------------------+-----------+-----------+-----+ | nibble # 0 | nibble # 1 | nibble # 2 | nibble # 3 | ... | +-------------+-----------+-----------+-----------+-----+ | PCIType = 1 | FF_DL | ... | +-------------+-----------+-----------------------+-----+","title":"Detailed Description"},{"location":"docs/structIsoTpFirstFrameShort/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/structIsoTpFirstFrameShort/#variable-ff_dl_high","text":"uint8_t IsoTpFirstFrameShort :: FF_DL_high ; First-frame data length (high nibble).","title":"variable FF_DL_high"},{"location":"docs/structIsoTpFirstFrameShort/#variable-ff_dl_low","text":"uint8_t IsoTpFirstFrameShort :: FF_DL_low ; First-frame data length (low byte).","title":"variable FF_DL_low"},{"location":"docs/structIsoTpFirstFrameShort/#variable-data","text":"uint8_t IsoTpFirstFrameShort :: data [ 6 ]; Payload bytes.","title":"variable data"},{"location":"docs/structIsoTpFirstFrameShort/#variable-type","text":"uint8_t IsoTpFirstFrameShort :: type ; PCI type. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"variable type"},{"location":"docs/structIsoTpFlowControl/","text":"Struct IsoTpFlowControl \u00b6 ClassList > IsoTpFlowControl Flow control frame layout. More... #include <isotp_defines.h> Public Attributes \u00b6 Type Name uint8_t BS uint8_t FS uint8_t STmin uint8_t reserve uint8_t type Detailed Description \u00b6 +-------------------------+-----------------------+-----------------------+-----+ | byte # 0 | byte # 1 | byte # 2 | ... | +-------------------------+-----------+-----------+-----------+-----------+-----+ | nibble # 0 | nibble # 1 | nibble # 2 | nibble # 3 | nibble # 4 | nibble # 5 | ... | +-------------+-----------+-----------+-----------+-----------+-----------+-----+ | PCIType = 1 | FS | BS | STmin | ... | +-------------+-----------+-----------------------+-----------------------+-----+ Public Attributes Documentation \u00b6 variable BS \u00b6 uint8_t IsoTpFlowControl :: BS ; Block size. variable FS \u00b6 uint8_t IsoTpFlowControl :: FS ; Flow status. variable STmin \u00b6 uint8_t IsoTpFlowControl :: STmin ; Minimum separation time. variable reserve \u00b6 uint8_t IsoTpFlowControl :: reserve [ 5 ]; Reserved. variable type \u00b6 uint8_t IsoTpFlowControl :: type ; PCI type. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"Struct IsoTpFlowControl"},{"location":"docs/structIsoTpFlowControl/#struct-isotpflowcontrol","text":"ClassList > IsoTpFlowControl Flow control frame layout. More... #include <isotp_defines.h>","title":"Struct IsoTpFlowControl"},{"location":"docs/structIsoTpFlowControl/#public-attributes","text":"Type Name uint8_t BS uint8_t FS uint8_t STmin uint8_t reserve uint8_t type","title":"Public Attributes"},{"location":"docs/structIsoTpFlowControl/#detailed-description","text":"+-------------------------+-----------------------+-----------------------+-----+ | byte # 0 | byte # 1 | byte # 2 | ... | +-------------------------+-----------+-----------+-----------+-----------+-----+ | nibble # 0 | nibble # 1 | nibble # 2 | nibble # 3 | nibble # 4 | nibble # 5 | ... | +-------------+-----------+-----------+-----------+-----------+-----------+-----+ | PCIType = 1 | FS | BS | STmin | ... | +-------------+-----------+-----------------------+-----------------------+-----+","title":"Detailed Description"},{"location":"docs/structIsoTpFlowControl/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/structIsoTpFlowControl/#variable-bs","text":"uint8_t IsoTpFlowControl :: BS ; Block size.","title":"variable BS"},{"location":"docs/structIsoTpFlowControl/#variable-fs","text":"uint8_t IsoTpFlowControl :: FS ; Flow status.","title":"variable FS"},{"location":"docs/structIsoTpFlowControl/#variable-stmin","text":"uint8_t IsoTpFlowControl :: STmin ; Minimum separation time.","title":"variable STmin"},{"location":"docs/structIsoTpFlowControl/#variable-reserve","text":"uint8_t IsoTpFlowControl :: reserve [ 5 ]; Reserved.","title":"variable reserve"},{"location":"docs/structIsoTpFlowControl/#variable-type","text":"uint8_t IsoTpFlowControl :: type ; PCI type. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"variable type"},{"location":"docs/structIsoTpPciType/","text":"Struct IsoTpPciType \u00b6 ClassList > IsoTpPciType CAN frame definitions. #include <isotp_defines.h> Public Attributes \u00b6 Type Name uint8_t reserve_1 uint8_t reserve_2 uint8_t type Public Attributes Documentation \u00b6 variable reserve_1 \u00b6 uint8_t IsoTpPciType :: reserve_1 ; Reserved. variable reserve_2 \u00b6 uint8_t IsoTpPciType :: reserve_2 [ 7 ]; Reserved. variable type \u00b6 uint8_t IsoTpPciType :: type ; PCI type. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"Struct IsoTpPciType"},{"location":"docs/structIsoTpPciType/#struct-isotppcitype","text":"ClassList > IsoTpPciType CAN frame definitions. #include <isotp_defines.h>","title":"Struct IsoTpPciType"},{"location":"docs/structIsoTpPciType/#public-attributes","text":"Type Name uint8_t reserve_1 uint8_t reserve_2 uint8_t type","title":"Public Attributes"},{"location":"docs/structIsoTpPciType/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/structIsoTpPciType/#variable-reserve_1","text":"uint8_t IsoTpPciType :: reserve_1 ; Reserved.","title":"variable reserve_1"},{"location":"docs/structIsoTpPciType/#variable-reserve_2","text":"uint8_t IsoTpPciType :: reserve_2 [ 7 ]; Reserved.","title":"variable reserve_2"},{"location":"docs/structIsoTpPciType/#variable-type","text":"uint8_t IsoTpPciType :: type ; PCI type. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"variable type"},{"location":"docs/structIsoTpSingleFrame/","text":"Struct IsoTpSingleFrame \u00b6 ClassList > IsoTpSingleFrame Single frame layout. More... #include <isotp_defines.h> Public Attributes \u00b6 Type Name uint8_t SF_DL uint8_t data uint8_t type Detailed Description \u00b6 +-------------------------+-----+ | byte # 0 | ... | +-------------------------+-----+ | nibble # 0 | nibble # 1 | ... | +-------------+-----------+ ... + | PCIType = 0 | SF_DL | ... | +-------------+-----------+-----+ Public Attributes Documentation \u00b6 variable SF_DL \u00b6 uint8_t IsoTpSingleFrame :: SF_DL ; Single-frame data length. variable data \u00b6 uint8_t IsoTpSingleFrame :: data [ 7 ]; Payload bytes. variable type \u00b6 uint8_t IsoTpSingleFrame :: type ; PCI type. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"Struct IsoTpSingleFrame"},{"location":"docs/structIsoTpSingleFrame/#struct-isotpsingleframe","text":"ClassList > IsoTpSingleFrame Single frame layout. More... #include <isotp_defines.h>","title":"Struct IsoTpSingleFrame"},{"location":"docs/structIsoTpSingleFrame/#public-attributes","text":"Type Name uint8_t SF_DL uint8_t data uint8_t type","title":"Public Attributes"},{"location":"docs/structIsoTpSingleFrame/#detailed-description","text":"+-------------------------+-----+ | byte # 0 | ... | +-------------------------+-----+ | nibble # 0 | nibble # 1 | ... | +-------------+-----------+ ... + | PCIType = 0 | SF_DL | ... | +-------------+-----------+-----+","title":"Detailed Description"},{"location":"docs/structIsoTpSingleFrame/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/structIsoTpSingleFrame/#variable-sf_dl","text":"uint8_t IsoTpSingleFrame :: SF_DL ; Single-frame data length.","title":"variable SF_DL"},{"location":"docs/structIsoTpSingleFrame/#variable-data","text":"uint8_t IsoTpSingleFrame :: data [ 7 ]; Payload bytes.","title":"variable data"},{"location":"docs/structIsoTpSingleFrame/#variable-type","text":"uint8_t IsoTpSingleFrame :: type ; PCI type. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"variable type"},{"location":"docs/structMockCanState/","text":"Struct MockCanState \u00b6 ClassList > MockCanState Mock CAN state structure for testing purposes. More... #include <isotp_test_support.h> Public Attributes \u00b6 Type Name int call_count uint8_t last_data uint32_t last_id uint8_t last_size int return_value Detailed Description \u00b6 Captures the last transmitted CAN frame and counts calls. Public Attributes Documentation \u00b6 variable call_count \u00b6 int MockCanState :: call_count ; variable last_data \u00b6 uint8_t MockCanState :: last_data [ 8 ]; variable last_id \u00b6 uint32_t MockCanState :: last_id ; variable last_size \u00b6 uint8_t MockCanState :: last_size ; variable return_value \u00b6 int MockCanState :: return_value ; The documentation for this class was generated from the following file tests/unit/isotp_test_support.h","title":"Struct MockCanState"},{"location":"docs/structMockCanState/#struct-mockcanstate","text":"ClassList > MockCanState Mock CAN state structure for testing purposes. More... #include <isotp_test_support.h>","title":"Struct MockCanState"},{"location":"docs/structMockCanState/#public-attributes","text":"Type Name int call_count uint8_t last_data uint32_t last_id uint8_t last_size int return_value","title":"Public Attributes"},{"location":"docs/structMockCanState/#detailed-description","text":"Captures the last transmitted CAN frame and counts calls.","title":"Detailed Description"},{"location":"docs/structMockCanState/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/structMockCanState/#variable-call_count","text":"int MockCanState :: call_count ;","title":"variable call_count"},{"location":"docs/structMockCanState/#variable-last_data","text":"uint8_t MockCanState :: last_data [ 8 ];","title":"variable last_data"},{"location":"docs/structMockCanState/#variable-last_id","text":"uint32_t MockCanState :: last_id ;","title":"variable last_id"},{"location":"docs/structMockCanState/#variable-last_size","text":"uint8_t MockCanState :: last_size ;","title":"variable last_size"},{"location":"docs/structMockCanState/#variable-return_value","text":"int MockCanState :: return_value ; The documentation for this class was generated from the following file tests/unit/isotp_test_support.h","title":"variable return_value"},{"location":"docs/structcan__driver__t/","text":"Struct can_driver_t \u00b6 ClassList > can_driver_t Public Attributes \u00b6 Type Name int(* receive int(* send Public Attributes Documentation \u00b6 variable receive \u00b6 int ( * can_driver_t :: receive ) ( uint32_t * id , uint8_t * data , uint8_t * len ); variable send \u00b6 int ( * can_driver_t :: send ) ( uint32_t id , const uint8_t * data , uint8_t len ); The documentation for this class was generated from the following file examples/python_api/inc/can_driver.h","title":"Struct can_driver_t"},{"location":"docs/structcan__driver__t/#struct-can_driver_t","text":"ClassList > can_driver_t","title":"Struct can_driver_t"},{"location":"docs/structcan__driver__t/#public-attributes","text":"Type Name int(* receive int(* send","title":"Public Attributes"},{"location":"docs/structcan__driver__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/structcan__driver__t/#variable-receive","text":"int ( * can_driver_t :: receive ) ( uint32_t * id , uint8_t * data , uint8_t * len );","title":"variable receive"},{"location":"docs/structcan__driver__t/#variable-send","text":"int ( * can_driver_t :: send ) ( uint32_t id , const uint8_t * data , uint8_t len ); The documentation for this class was generated from the following file examples/python_api/inc/can_driver.h","title":"variable send"},{"location":"docs/structcan__frame__t/","text":"Struct can_frame_t \u00b6 ClassList > can_frame_t Structure representing a CAN frame in the mock driver. Public Attributes \u00b6 Type Name uint8_t data uint32_t id uint8_t len Public Attributes Documentation \u00b6 variable data \u00b6 uint8_t can_frame_t :: data [ CAN_MAX_DLEN ]; variable id \u00b6 uint32_t can_frame_t :: id ; variable len \u00b6 uint8_t can_frame_t :: len ; The documentation for this class was generated from the following file examples/python_api/src/mock_can.c","title":"Struct can_frame_t"},{"location":"docs/structcan__frame__t/#struct-can_frame_t","text":"ClassList > can_frame_t Structure representing a CAN frame in the mock driver.","title":"Struct can_frame_t"},{"location":"docs/structcan__frame__t/#public-attributes","text":"Type Name uint8_t data uint32_t id uint8_t len","title":"Public Attributes"},{"location":"docs/structcan__frame__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/structcan__frame__t/#variable-data","text":"uint8_t can_frame_t :: data [ CAN_MAX_DLEN ];","title":"variable data"},{"location":"docs/structcan__frame__t/#variable-id","text":"uint32_t can_frame_t :: id ;","title":"variable id"},{"location":"docs/structcan__frame__t/#variable-len","text":"uint8_t can_frame_t :: len ; The documentation for this class was generated from the following file examples/python_api/src/mock_can.c","title":"variable len"},{"location":"docs/namespaceconftest/","text":"Namespace conftest \u00b6 Namespace List > conftest Public Functions \u00b6 Type Name reset_mock_can_state () Ensure mock CAN state is reset around each test. Public Functions Documentation \u00b6 function reset_mock_can_state \u00b6 Ensure mock CAN state is reset around each test. conftest :: reset_mock_can_state () Disables FC mocks before and after each test run. The documentation for this class was generated from the following file tests/integration/conftest.py","title":"Namespace conftest"},{"location":"docs/namespaceconftest/#namespace-conftest","text":"Namespace List > conftest","title":"Namespace conftest"},{"location":"docs/namespaceconftest/#public-functions","text":"Type Name reset_mock_can_state () Ensure mock CAN state is reset around each test.","title":"Public Functions"},{"location":"docs/namespaceconftest/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/namespaceconftest/#function-reset_mock_can_state","text":"Ensure mock CAN state is reset around each test. conftest :: reset_mock_can_state () Disables FC mocks before and after each test run. The documentation for this class was generated from the following file tests/integration/conftest.py","title":"function reset_mock_can_state"},{"location":"docs/namespacetest__api__endpoints/","text":"Namespace test_api_endpoints \u00b6 Namespace List > test_api_endpoints Public Functions \u00b6 Type Name test_api_endpoints_inject_unexpected_cf () Validate unexpected CF injection handling. test_api_endpoints_inject_wrong_sn () Validate wrong sequence number handling. test_api_endpoints_return_codes () Validate return codes for overflow and in-progress sends. test_api_endpoints_smoke () Verify basic API calls and protocol result handling. test_api_endpoints_smoke_multi_frame () Verify multi-frame send/receive path. test_api_endpoints_validation_errors () Validate input checks and error signaling in API. Protected Functions \u00b6 Type Name _cf_frame (sn sn, payload payload) Build a Consecutive Frame (CF) with a given sequence number. _ff_frame (payload_size payload_size, payload payload) Build a First Frame (FF) for an ISO-TP multi-frame transfer. _make_payload (size size) Build a deterministic payload of a given size. _poll_until_receive (link link, payload_size payload_size, steps steps, advance_ms advance_ms=0) Poll the link until a response is received or steps are exhausted. Public Functions Documentation \u00b6 function test_api_endpoints_inject_unexpected_cf \u00b6 Validate unexpected CF injection handling. test_api_endpoints :: test_api_endpoints_inject_unexpected_cf () function test_api_endpoints_inject_wrong_sn \u00b6 Validate wrong sequence number handling. test_api_endpoints :: test_api_endpoints_inject_wrong_sn () function test_api_endpoints_return_codes \u00b6 Validate return codes for overflow and in-progress sends. test_api_endpoints :: test_api_endpoints_return_codes () function test_api_endpoints_smoke \u00b6 Verify basic API calls and protocol result handling. test_api_endpoints :: test_api_endpoints_smoke () function test_api_endpoints_smoke_multi_frame \u00b6 Verify multi-frame send/receive path. test_api_endpoints :: test_api_endpoints_smoke_multi_frame () function test_api_endpoints_validation_errors \u00b6 Validate input checks and error signaling in API. test_api_endpoints :: test_api_endpoints_validation_errors () Protected Functions Documentation \u00b6 function _cf_frame \u00b6 Build a Consecutive Frame (CF) with a given sequence number. test_api_endpoints :: _cf_frame ( sn sn , payload payload ) Parameters: sn Sequence number (0-15). payload Payload bytes to embed in CF. Returns: CAN frame bytes representing the CF. function _ff_frame \u00b6 Build a First Frame (FF) for an ISO-TP multi-frame transfer. test_api_endpoints :: _ff_frame ( payload_size payload_size , payload payload ) Parameters: payload_size Total payload size. payload Payload bytes to embed in FF. Returns: CAN frame bytes representing the FF. function _make_payload \u00b6 Build a deterministic payload of a given size. test_api_endpoints :: _make_payload ( size size ) Parameters: size Number of bytes to generate. Returns: Payload bytes. function _poll_until_receive \u00b6 Poll the link until a response is received or steps are exhausted. test_api_endpoints :: _poll_until_receive ( link link , payload_size payload_size , steps steps , advance_ms advance_ms = 0 ) Parameters: link ISO-TP link handle. payload_size Expected payload size for receive. steps Maximum number of poll iterations. advance_ms Optional time advance per step in milliseconds. Returns: Received payload bytes or None when nothing is received. The documentation for this class was generated from the following file tests/integration/test_api_endpoints.py","title":"Namespace test_api_endpoints"},{"location":"docs/namespacetest__api__endpoints/#namespace-test_api_endpoints","text":"Namespace List > test_api_endpoints","title":"Namespace test_api_endpoints"},{"location":"docs/namespacetest__api__endpoints/#public-functions","text":"Type Name test_api_endpoints_inject_unexpected_cf () Validate unexpected CF injection handling. test_api_endpoints_inject_wrong_sn () Validate wrong sequence number handling. test_api_endpoints_return_codes () Validate return codes for overflow and in-progress sends. test_api_endpoints_smoke () Verify basic API calls and protocol result handling. test_api_endpoints_smoke_multi_frame () Verify multi-frame send/receive path. test_api_endpoints_validation_errors () Validate input checks and error signaling in API.","title":"Public Functions"},{"location":"docs/namespacetest__api__endpoints/#protected-functions","text":"Type Name _cf_frame (sn sn, payload payload) Build a Consecutive Frame (CF) with a given sequence number. _ff_frame (payload_size payload_size, payload payload) Build a First Frame (FF) for an ISO-TP multi-frame transfer. _make_payload (size size) Build a deterministic payload of a given size. _poll_until_receive (link link, payload_size payload_size, steps steps, advance_ms advance_ms=0) Poll the link until a response is received or steps are exhausted.","title":"Protected Functions"},{"location":"docs/namespacetest__api__endpoints/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/namespacetest__api__endpoints/#function-test_api_endpoints_inject_unexpected_cf","text":"Validate unexpected CF injection handling. test_api_endpoints :: test_api_endpoints_inject_unexpected_cf ()","title":"function test_api_endpoints_inject_unexpected_cf"},{"location":"docs/namespacetest__api__endpoints/#function-test_api_endpoints_inject_wrong_sn","text":"Validate wrong sequence number handling. test_api_endpoints :: test_api_endpoints_inject_wrong_sn ()","title":"function test_api_endpoints_inject_wrong_sn"},{"location":"docs/namespacetest__api__endpoints/#function-test_api_endpoints_return_codes","text":"Validate return codes for overflow and in-progress sends. test_api_endpoints :: test_api_endpoints_return_codes ()","title":"function test_api_endpoints_return_codes"},{"location":"docs/namespacetest__api__endpoints/#function-test_api_endpoints_smoke","text":"Verify basic API calls and protocol result handling. test_api_endpoints :: test_api_endpoints_smoke ()","title":"function test_api_endpoints_smoke"},{"location":"docs/namespacetest__api__endpoints/#function-test_api_endpoints_smoke_multi_frame","text":"Verify multi-frame send/receive path. test_api_endpoints :: test_api_endpoints_smoke_multi_frame ()","title":"function test_api_endpoints_smoke_multi_frame"},{"location":"docs/namespacetest__api__endpoints/#function-test_api_endpoints_validation_errors","text":"Validate input checks and error signaling in API. test_api_endpoints :: test_api_endpoints_validation_errors ()","title":"function test_api_endpoints_validation_errors"},{"location":"docs/namespacetest__api__endpoints/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"docs/namespacetest__api__endpoints/#function-_cf_frame","text":"Build a Consecutive Frame (CF) with a given sequence number. test_api_endpoints :: _cf_frame ( sn sn , payload payload ) Parameters: sn Sequence number (0-15). payload Payload bytes to embed in CF. Returns: CAN frame bytes representing the CF.","title":"function _cf_frame"},{"location":"docs/namespacetest__api__endpoints/#function-_ff_frame","text":"Build a First Frame (FF) for an ISO-TP multi-frame transfer. test_api_endpoints :: _ff_frame ( payload_size payload_size , payload payload ) Parameters: payload_size Total payload size. payload Payload bytes to embed in FF. Returns: CAN frame bytes representing the FF.","title":"function _ff_frame"},{"location":"docs/namespacetest__api__endpoints/#function-_make_payload","text":"Build a deterministic payload of a given size. test_api_endpoints :: _make_payload ( size size ) Parameters: size Number of bytes to generate. Returns: Payload bytes.","title":"function _make_payload"},{"location":"docs/namespacetest__api__endpoints/#function-_poll_until_receive","text":"Poll the link until a response is received or steps are exhausted. test_api_endpoints :: _poll_until_receive ( link link , payload_size payload_size , steps steps , advance_ms advance_ms = 0 ) Parameters: link ISO-TP link handle. payload_size Expected payload size for receive. steps Maximum number of poll iterations. advance_ms Optional time advance per step in milliseconds. Returns: Received payload bytes or None when nothing is received. The documentation for this class was generated from the following file tests/integration/test_api_endpoints.py","title":"function _poll_until_receive"},{"location":"docs/namespacetest__api__validation/","text":"Namespace test_api_validation \u00b6 Namespace List > test_api_validation Public Functions \u00b6 Type Name test_init_rejects_zero_buffers () Verify init rejects zero-length buffers. test_receive_rejects_invalid_bufsize () Verify receive rejects invalid buffer sizes. test_set_fc_params_rejects_large_block_size () Verify flow control params reject oversized block size. Public Functions Documentation \u00b6 function test_init_rejects_zero_buffers \u00b6 Verify init rejects zero-length buffers. test_api_validation :: test_init_rejects_zero_buffers () Validates both send and receive buffer size checks. function test_receive_rejects_invalid_bufsize \u00b6 Verify receive rejects invalid buffer sizes. test_api_validation :: test_receive_rejects_invalid_bufsize () Ensures zero length is rejected by the binding. function test_set_fc_params_rejects_large_block_size \u00b6 Verify flow control params reject oversized block size. test_api_validation :: test_set_fc_params_rejects_large_block_size () Block size values above 255 must be rejected. The documentation for this class was generated from the following file tests/integration/test_api_validation.py","title":"Namespace test_api_validation"},{"location":"docs/namespacetest__api__validation/#namespace-test_api_validation","text":"Namespace List > test_api_validation","title":"Namespace test_api_validation"},{"location":"docs/namespacetest__api__validation/#public-functions","text":"Type Name test_init_rejects_zero_buffers () Verify init rejects zero-length buffers. test_receive_rejects_invalid_bufsize () Verify receive rejects invalid buffer sizes. test_set_fc_params_rejects_large_block_size () Verify flow control params reject oversized block size.","title":"Public Functions"},{"location":"docs/namespacetest__api__validation/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/namespacetest__api__validation/#function-test_init_rejects_zero_buffers","text":"Verify init rejects zero-length buffers. test_api_validation :: test_init_rejects_zero_buffers () Validates both send and receive buffer size checks.","title":"function test_init_rejects_zero_buffers"},{"location":"docs/namespacetest__api__validation/#function-test_receive_rejects_invalid_bufsize","text":"Verify receive rejects invalid buffer sizes. test_api_validation :: test_receive_rejects_invalid_bufsize () Ensures zero length is rejected by the binding.","title":"function test_receive_rejects_invalid_bufsize"},{"location":"docs/namespacetest__api__validation/#function-test_set_fc_params_rejects_large_block_size","text":"Verify flow control params reject oversized block size. test_api_validation :: test_set_fc_params_rejects_large_block_size () Block size values above 255 must be rejected. The documentation for this class was generated from the following file tests/integration/test_api_validation.py","title":"function test_set_fc_params_rejects_large_block_size"},{"location":"docs/namespacetest__buffer__limits/","text":"Namespace test_buffer_limits \u00b6 Namespace List > test_buffer_limits Public Functions \u00b6 Type Name test_receive_truncates_payload () Verify receive truncates payload to buffer size. test_send_in_progress_returns_code () Verify in-progress is reported on concurrent send. test_send_overflow_returns_code () Verify overflow is reported on send. Protected Functions \u00b6 Type Name _make_payload (size size) Build a deterministic payload of a given size. _poll_until_receive (link link, payload_size payload_size, steps steps) Poll the link until a response is received or steps are exhausted. Public Functions Documentation \u00b6 function test_receive_truncates_payload \u00b6 Verify receive truncates payload to buffer size. test_buffer_limits :: test_receive_truncates_payload () The returned payload must be capped to the buffer length. function test_send_in_progress_returns_code \u00b6 Verify in-progress is reported on concurrent send. test_buffer_limits :: test_send_in_progress_returns_code () Second send while active returns ISOTP_RET_INPROGRESS. function test_send_overflow_returns_code \u00b6 Verify overflow is reported on send. test_buffer_limits :: test_send_overflow_returns_code () Exceeding the send buffer returns ISOTP_RET_OVERFLOW. Protected Functions Documentation \u00b6 function _make_payload \u00b6 Build a deterministic payload of a given size. test_buffer_limits :: _make_payload ( size size ) Parameters: size Number of bytes to generate. Returns: Payload bytes. Uses a simple modulo pattern for repeatability. function _poll_until_receive \u00b6 Poll the link until a response is received or steps are exhausted. test_buffer_limits :: _poll_until_receive ( link link , payload_size payload_size , steps steps ) Parameters: link ISO-TP link handle. payload_size Expected payload size for receive. steps Maximum number of poll iterations. Returns: Received payload bytes or None when nothing is received. Polls the core without advancing time. The documentation for this class was generated from the following file tests/integration/test_buffer_limits.py","title":"Namespace test_buffer_limits"},{"location":"docs/namespacetest__buffer__limits/#namespace-test_buffer_limits","text":"Namespace List > test_buffer_limits","title":"Namespace test_buffer_limits"},{"location":"docs/namespacetest__buffer__limits/#public-functions","text":"Type Name test_receive_truncates_payload () Verify receive truncates payload to buffer size. test_send_in_progress_returns_code () Verify in-progress is reported on concurrent send. test_send_overflow_returns_code () Verify overflow is reported on send.","title":"Public Functions"},{"location":"docs/namespacetest__buffer__limits/#protected-functions","text":"Type Name _make_payload (size size) Build a deterministic payload of a given size. _poll_until_receive (link link, payload_size payload_size, steps steps) Poll the link until a response is received or steps are exhausted.","title":"Protected Functions"},{"location":"docs/namespacetest__buffer__limits/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/namespacetest__buffer__limits/#function-test_receive_truncates_payload","text":"Verify receive truncates payload to buffer size. test_buffer_limits :: test_receive_truncates_payload () The returned payload must be capped to the buffer length.","title":"function test_receive_truncates_payload"},{"location":"docs/namespacetest__buffer__limits/#function-test_send_in_progress_returns_code","text":"Verify in-progress is reported on concurrent send. test_buffer_limits :: test_send_in_progress_returns_code () Second send while active returns ISOTP_RET_INPROGRESS.","title":"function test_send_in_progress_returns_code"},{"location":"docs/namespacetest__buffer__limits/#function-test_send_overflow_returns_code","text":"Verify overflow is reported on send. test_buffer_limits :: test_send_overflow_returns_code () Exceeding the send buffer returns ISOTP_RET_OVERFLOW.","title":"function test_send_overflow_returns_code"},{"location":"docs/namespacetest__buffer__limits/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"docs/namespacetest__buffer__limits/#function-_make_payload","text":"Build a deterministic payload of a given size. test_buffer_limits :: _make_payload ( size size ) Parameters: size Number of bytes to generate. Returns: Payload bytes. Uses a simple modulo pattern for repeatability.","title":"function _make_payload"},{"location":"docs/namespacetest__buffer__limits/#function-_poll_until_receive","text":"Poll the link until a response is received or steps are exhausted. test_buffer_limits :: _poll_until_receive ( link link , payload_size payload_size , steps steps ) Parameters: link ISO-TP link handle. payload_size Expected payload size for receive. steps Maximum number of poll iterations. Returns: Received payload bytes or None when nothing is received. Polls the core without advancing time. The documentation for this class was generated from the following file tests/integration/test_buffer_limits.py","title":"function _poll_until_receive"},{"location":"docs/namespacetest__cantp/","text":"Namespace test_cantp \u00b6 Namespace List > test_cantp Public Functions \u00b6 Type Name test_cantp_stmin_and_bs () Verify STmin and block size pacing. test_cantp_timeout_n_bs () Verify N_Bs timeout is detected. test_cantp_timeout_n_cr () Verify N_Cr timeout is detected. test_cantp_unexpected_pdu () Verify unexpected PDU is reported. test_wait_frame_overrun () Verify WAIT frame overrun is reported. test_wait_frame_then_continue () Verify receiver resumes after WAIT then CONTINUE FC. Protected Functions \u00b6 Type Name _fc_frame (flow_status flow_status, block_size block_size, st_min st_min) Build a Flow Control (FC) frame. _make_payload (size size) Build a deterministic payload of a given size. _poll_until_receive (link link, payload_size payload_size, steps steps, advance_ms advance_ms=0) Poll the link until a response is received or steps are exhausted. Public Functions Documentation \u00b6 function test_cantp_stmin_and_bs \u00b6 Verify STmin and block size pacing. test_cantp :: test_cantp_stmin_and_bs () Advances time to satisfy STmin between frames. function test_cantp_timeout_n_bs \u00b6 Verify N_Bs timeout is detected. test_cantp :: test_cantp_timeout_n_bs () Disables FC to force a sender block-size timeout. function test_cantp_timeout_n_cr \u00b6 Verify N_Cr timeout is detected. test_cantp :: test_cantp_timeout_n_cr () Drops incoming frames to force a receiver timeout. function test_cantp_unexpected_pdu \u00b6 Verify unexpected PDU is reported. test_cantp :: test_cantp_unexpected_pdu () Injects a CF when receiver is idle. function test_wait_frame_overrun \u00b6 Verify WAIT frame overrun is reported. test_cantp :: test_wait_frame_overrun () Repeated WAIT frames exceed the limit and trigger WFT_OVRN. function test_wait_frame_then_continue \u00b6 Verify receiver resumes after WAIT then CONTINUE FC. test_cantp :: test_wait_frame_then_continue () WAIT should pause transmission until CONTINUE arrives. Protected Functions Documentation \u00b6 function _fc_frame \u00b6 Build a Flow Control (FC) frame. test_cantp :: _fc_frame ( flow_status flow_status , block_size block_size , st_min st_min ) Parameters: flow_status Flow status nibble. block_size Block size byte. st_min STmin byte. Returns: CAN frame bytes representing the FC. Encodes the 0x30 PCI for flow control. function _make_payload \u00b6 Build a deterministic payload of a given size. test_cantp :: _make_payload ( size size ) Parameters: size Number of bytes to generate. Returns: Payload bytes. Uses a simple modulo pattern for repeatability. function _poll_until_receive \u00b6 Poll the link until a response is received or steps are exhausted. test_cantp :: _poll_until_receive ( link link , payload_size payload_size , steps steps , advance_ms advance_ms = 0 ) Parameters: link ISO-TP link handle. payload_size Expected payload size for receive. steps Maximum number of poll iterations. advance_ms Optional time advance per step in milliseconds. Returns: Received payload bytes or None when nothing is received. Optionally advances the mock time between polls. The documentation for this class was generated from the following file tests/integration/test_cantp.py","title":"Namespace test_cantp"},{"location":"docs/namespacetest__cantp/#namespace-test_cantp","text":"Namespace List > test_cantp","title":"Namespace test_cantp"},{"location":"docs/namespacetest__cantp/#public-functions","text":"Type Name test_cantp_stmin_and_bs () Verify STmin and block size pacing. test_cantp_timeout_n_bs () Verify N_Bs timeout is detected. test_cantp_timeout_n_cr () Verify N_Cr timeout is detected. test_cantp_unexpected_pdu () Verify unexpected PDU is reported. test_wait_frame_overrun () Verify WAIT frame overrun is reported. test_wait_frame_then_continue () Verify receiver resumes after WAIT then CONTINUE FC.","title":"Public Functions"},{"location":"docs/namespacetest__cantp/#protected-functions","text":"Type Name _fc_frame (flow_status flow_status, block_size block_size, st_min st_min) Build a Flow Control (FC) frame. _make_payload (size size) Build a deterministic payload of a given size. _poll_until_receive (link link, payload_size payload_size, steps steps, advance_ms advance_ms=0) Poll the link until a response is received or steps are exhausted.","title":"Protected Functions"},{"location":"docs/namespacetest__cantp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/namespacetest__cantp/#function-test_cantp_stmin_and_bs","text":"Verify STmin and block size pacing. test_cantp :: test_cantp_stmin_and_bs () Advances time to satisfy STmin between frames.","title":"function test_cantp_stmin_and_bs"},{"location":"docs/namespacetest__cantp/#function-test_cantp_timeout_n_bs","text":"Verify N_Bs timeout is detected. test_cantp :: test_cantp_timeout_n_bs () Disables FC to force a sender block-size timeout.","title":"function test_cantp_timeout_n_bs"},{"location":"docs/namespacetest__cantp/#function-test_cantp_timeout_n_cr","text":"Verify N_Cr timeout is detected. test_cantp :: test_cantp_timeout_n_cr () Drops incoming frames to force a receiver timeout.","title":"function test_cantp_timeout_n_cr"},{"location":"docs/namespacetest__cantp/#function-test_cantp_unexpected_pdu","text":"Verify unexpected PDU is reported. test_cantp :: test_cantp_unexpected_pdu () Injects a CF when receiver is idle.","title":"function test_cantp_unexpected_pdu"},{"location":"docs/namespacetest__cantp/#function-test_wait_frame_overrun","text":"Verify WAIT frame overrun is reported. test_cantp :: test_wait_frame_overrun () Repeated WAIT frames exceed the limit and trigger WFT_OVRN.","title":"function test_wait_frame_overrun"},{"location":"docs/namespacetest__cantp/#function-test_wait_frame_then_continue","text":"Verify receiver resumes after WAIT then CONTINUE FC. test_cantp :: test_wait_frame_then_continue () WAIT should pause transmission until CONTINUE arrives.","title":"function test_wait_frame_then_continue"},{"location":"docs/namespacetest__cantp/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"docs/namespacetest__cantp/#function-_fc_frame","text":"Build a Flow Control (FC) frame. test_cantp :: _fc_frame ( flow_status flow_status , block_size block_size , st_min st_min ) Parameters: flow_status Flow status nibble. block_size Block size byte. st_min STmin byte. Returns: CAN frame bytes representing the FC. Encodes the 0x30 PCI for flow control.","title":"function _fc_frame"},{"location":"docs/namespacetest__cantp/#function-_make_payload","text":"Build a deterministic payload of a given size. test_cantp :: _make_payload ( size size ) Parameters: size Number of bytes to generate. Returns: Payload bytes. Uses a simple modulo pattern for repeatability.","title":"function _make_payload"},{"location":"docs/namespacetest__cantp/#function-_poll_until_receive","text":"Poll the link until a response is received or steps are exhausted. test_cantp :: _poll_until_receive ( link link , payload_size payload_size , steps steps , advance_ms advance_ms = 0 ) Parameters: link ISO-TP link handle. payload_size Expected payload size for receive. steps Maximum number of poll iterations. advance_ms Optional time advance per step in milliseconds. Returns: Received payload bytes or None when nothing is received. Optionally advances the mock time between polls. The documentation for this class was generated from the following file tests/integration/test_cantp.py","title":"function _poll_until_receive"},{"location":"docs/namespacetest__flow__control/","text":"Namespace test_flow_control \u00b6 Namespace List > test_flow_control Public Functions \u00b6 Type Name test_flow_control_overflow_sets_protocol_result () Verify overflow FC sets protocol result. Protected Functions \u00b6 Type Name _fc_frame (flow_status flow_status, block_size block_size, st_min st_min) Build a Flow Control (FC) frame. _make_payload (size size) Build a deterministic payload of a given size. Public Functions Documentation \u00b6 function test_flow_control_overflow_sets_protocol_result \u00b6 Verify overflow FC sets protocol result. test_flow_control :: test_flow_control_overflow_sets_protocol_result () Injects PCI_FLOW_STATUS_OVERFLOW and checks protocol state. Protected Functions Documentation \u00b6 function _fc_frame \u00b6 Build a Flow Control (FC) frame. test_flow_control :: _fc_frame ( flow_status flow_status , block_size block_size , st_min st_min ) Parameters: flow_status Flow status nibble. block_size Block size byte. st_min STmin byte. Returns: CAN frame bytes representing the FC. Encodes the 0x30 PCI for flow control. function _make_payload \u00b6 Build a deterministic payload of a given size. test_flow_control :: _make_payload ( size size ) Parameters: size Number of bytes to generate. Returns: Payload bytes. Uses a simple modulo pattern for repeatability. The documentation for this class was generated from the following file tests/integration/test_flow_control.py","title":"Namespace test_flow_control"},{"location":"docs/namespacetest__flow__control/#namespace-test_flow_control","text":"Namespace List > test_flow_control","title":"Namespace test_flow_control"},{"location":"docs/namespacetest__flow__control/#public-functions","text":"Type Name test_flow_control_overflow_sets_protocol_result () Verify overflow FC sets protocol result.","title":"Public Functions"},{"location":"docs/namespacetest__flow__control/#protected-functions","text":"Type Name _fc_frame (flow_status flow_status, block_size block_size, st_min st_min) Build a Flow Control (FC) frame. _make_payload (size size) Build a deterministic payload of a given size.","title":"Protected Functions"},{"location":"docs/namespacetest__flow__control/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/namespacetest__flow__control/#function-test_flow_control_overflow_sets_protocol_result","text":"Verify overflow FC sets protocol result. test_flow_control :: test_flow_control_overflow_sets_protocol_result () Injects PCI_FLOW_STATUS_OVERFLOW and checks protocol state.","title":"function test_flow_control_overflow_sets_protocol_result"},{"location":"docs/namespacetest__flow__control/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"docs/namespacetest__flow__control/#function-_fc_frame","text":"Build a Flow Control (FC) frame. test_flow_control :: _fc_frame ( flow_status flow_status , block_size block_size , st_min st_min ) Parameters: flow_status Flow status nibble. block_size Block size byte. st_min STmin byte. Returns: CAN frame bytes representing the FC. Encodes the 0x30 PCI for flow control.","title":"function _fc_frame"},{"location":"docs/namespacetest__flow__control/#function-_make_payload","text":"Build a deterministic payload of a given size. test_flow_control :: _make_payload ( size size ) Parameters: size Number of bytes to generate. Returns: Payload bytes. Uses a simple modulo pattern for repeatability. The documentation for this class was generated from the following file tests/integration/test_flow_control.py","title":"function _make_payload"},{"location":"docs/namespacetest__multi__frame/","text":"Namespace test_multi_frame \u00b6 Namespace List > test_multi_frame Public Functions \u00b6 Type Name test_multi_frame_boundary_sizes (size size) Verify multi-frame behavior around boundary sizes. test_multi_frame_bs_one_stmin () Verify block size 1 with STmin pacing. test_multi_frame_bs_unlimited_stmin () Verify unlimited block size with STmin pacing. test_multi_frame_max_payload () Verify maximum payload size roundtrip. test_multi_frame_roundtrip () Verify multi-frame roundtrip delivery. test_multi_frame_timeout_n_bs () Verify N_Bs timeout during multi-frame send. test_multi_frame_timeout_n_cr () Verify N_Cr timeout during multi-frame receive. test_multi_frame_unexpected_cf () Verify unexpected CF is reported. test_multi_frame_wrong_sn () Verify wrong sequence number is reported. Protected Functions \u00b6 Type Name _cf_frame (sn sn, payload payload) Build a Consecutive Frame (CF) with a given sequence number. _ff_frame (payload_size payload_size, payload payload) Build a First Frame (FF) for an ISO-TP transfer. _make_payload (size size) Build a deterministic payload of a given size. _poll_until_receive (link link, payload_size payload_size, steps steps, advance_ms advance_ms=0) Poll the link until a response is received or steps are exhausted. Public Functions Documentation \u00b6 function test_multi_frame_boundary_sizes \u00b6 Verify multi-frame behavior around boundary sizes. test_multi_frame :: test_multi_frame_boundary_sizes ( size size ) Parameters: size Payload size under test. Exercises sizes near the SF/FF boundary. function test_multi_frame_bs_one_stmin \u00b6 Verify block size 1 with STmin pacing. test_multi_frame :: test_multi_frame_bs_one_stmin () Advances time between frames to satisfy STmin. function test_multi_frame_bs_unlimited_stmin \u00b6 Verify unlimited block size with STmin pacing. test_multi_frame :: test_multi_frame_bs_unlimited_stmin () Exercises BS=0 with STmin delay. function test_multi_frame_max_payload \u00b6 Verify maximum payload size roundtrip. test_multi_frame :: test_multi_frame_max_payload () Uses a large payload to stress segmentation and reassembly. function test_multi_frame_roundtrip \u00b6 Verify multi-frame roundtrip delivery. test_multi_frame :: test_multi_frame_roundtrip () Ensures payload integrity across segmented transfer. function test_multi_frame_timeout_n_bs \u00b6 Verify N_Bs timeout during multi-frame send. test_multi_frame :: test_multi_frame_timeout_n_bs () Disables FC to force sender block-size timeout. function test_multi_frame_timeout_n_cr \u00b6 Verify N_Cr timeout during multi-frame receive. test_multi_frame :: test_multi_frame_timeout_n_cr () Drops incoming frames to force receiver timeout. function test_multi_frame_unexpected_cf \u00b6 Verify unexpected CF is reported. test_multi_frame :: test_multi_frame_unexpected_cf () Injects a CF when receiver is idle. function test_multi_frame_wrong_sn \u00b6 Verify wrong sequence number is reported. test_multi_frame :: test_multi_frame_wrong_sn () Injects a CF with unexpected SN after FF. Protected Functions Documentation \u00b6 function _cf_frame \u00b6 Build a Consecutive Frame (CF) with a given sequence number. test_multi_frame :: _cf_frame ( sn sn , payload payload ) Parameters: sn Sequence number (0-15). payload Payload bytes to embed in CF. Returns: CAN frame bytes representing the CF. Encodes the 0x20 PCI with SN. function _ff_frame \u00b6 Build a First Frame (FF) for an ISO-TP transfer. test_multi_frame :: _ff_frame ( payload_size payload_size , payload payload ) Parameters: payload_size Total payload size. payload Payload bytes to embed in FF. Returns: CAN frame bytes representing the FF. Encodes the 0x10 PCI with 12-bit length. function _make_payload \u00b6 Build a deterministic payload of a given size. test_multi_frame :: _make_payload ( size size ) Parameters: size Number of bytes to generate. Returns: Payload bytes. Uses a simple modulo pattern for repeatability. function _poll_until_receive \u00b6 Poll the link until a response is received or steps are exhausted. test_multi_frame :: _poll_until_receive ( link link , payload_size payload_size , steps steps , advance_ms advance_ms = 0 ) Parameters: link ISO-TP link handle. payload_size Expected payload size for receive. steps Maximum number of poll iterations. advance_ms Optional time advance per step in milliseconds. Returns: Received payload bytes or None when nothing is received. Optionally advances the mock time between polls. The documentation for this class was generated from the following file tests/integration/test_multi_frame.py","title":"Namespace test_multi_frame"},{"location":"docs/namespacetest__multi__frame/#namespace-test_multi_frame","text":"Namespace List > test_multi_frame","title":"Namespace test_multi_frame"},{"location":"docs/namespacetest__multi__frame/#public-functions","text":"Type Name test_multi_frame_boundary_sizes (size size) Verify multi-frame behavior around boundary sizes. test_multi_frame_bs_one_stmin () Verify block size 1 with STmin pacing. test_multi_frame_bs_unlimited_stmin () Verify unlimited block size with STmin pacing. test_multi_frame_max_payload () Verify maximum payload size roundtrip. test_multi_frame_roundtrip () Verify multi-frame roundtrip delivery. test_multi_frame_timeout_n_bs () Verify N_Bs timeout during multi-frame send. test_multi_frame_timeout_n_cr () Verify N_Cr timeout during multi-frame receive. test_multi_frame_unexpected_cf () Verify unexpected CF is reported. test_multi_frame_wrong_sn () Verify wrong sequence number is reported.","title":"Public Functions"},{"location":"docs/namespacetest__multi__frame/#protected-functions","text":"Type Name _cf_frame (sn sn, payload payload) Build a Consecutive Frame (CF) with a given sequence number. _ff_frame (payload_size payload_size, payload payload) Build a First Frame (FF) for an ISO-TP transfer. _make_payload (size size) Build a deterministic payload of a given size. _poll_until_receive (link link, payload_size payload_size, steps steps, advance_ms advance_ms=0) Poll the link until a response is received or steps are exhausted.","title":"Protected Functions"},{"location":"docs/namespacetest__multi__frame/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/namespacetest__multi__frame/#function-test_multi_frame_boundary_sizes","text":"Verify multi-frame behavior around boundary sizes. test_multi_frame :: test_multi_frame_boundary_sizes ( size size ) Parameters: size Payload size under test. Exercises sizes near the SF/FF boundary.","title":"function test_multi_frame_boundary_sizes"},{"location":"docs/namespacetest__multi__frame/#function-test_multi_frame_bs_one_stmin","text":"Verify block size 1 with STmin pacing. test_multi_frame :: test_multi_frame_bs_one_stmin () Advances time between frames to satisfy STmin.","title":"function test_multi_frame_bs_one_stmin"},{"location":"docs/namespacetest__multi__frame/#function-test_multi_frame_bs_unlimited_stmin","text":"Verify unlimited block size with STmin pacing. test_multi_frame :: test_multi_frame_bs_unlimited_stmin () Exercises BS=0 with STmin delay.","title":"function test_multi_frame_bs_unlimited_stmin"},{"location":"docs/namespacetest__multi__frame/#function-test_multi_frame_max_payload","text":"Verify maximum payload size roundtrip. test_multi_frame :: test_multi_frame_max_payload () Uses a large payload to stress segmentation and reassembly.","title":"function test_multi_frame_max_payload"},{"location":"docs/namespacetest__multi__frame/#function-test_multi_frame_roundtrip","text":"Verify multi-frame roundtrip delivery. test_multi_frame :: test_multi_frame_roundtrip () Ensures payload integrity across segmented transfer.","title":"function test_multi_frame_roundtrip"},{"location":"docs/namespacetest__multi__frame/#function-test_multi_frame_timeout_n_bs","text":"Verify N_Bs timeout during multi-frame send. test_multi_frame :: test_multi_frame_timeout_n_bs () Disables FC to force sender block-size timeout.","title":"function test_multi_frame_timeout_n_bs"},{"location":"docs/namespacetest__multi__frame/#function-test_multi_frame_timeout_n_cr","text":"Verify N_Cr timeout during multi-frame receive. test_multi_frame :: test_multi_frame_timeout_n_cr () Drops incoming frames to force receiver timeout.","title":"function test_multi_frame_timeout_n_cr"},{"location":"docs/namespacetest__multi__frame/#function-test_multi_frame_unexpected_cf","text":"Verify unexpected CF is reported. test_multi_frame :: test_multi_frame_unexpected_cf () Injects a CF when receiver is idle.","title":"function test_multi_frame_unexpected_cf"},{"location":"docs/namespacetest__multi__frame/#function-test_multi_frame_wrong_sn","text":"Verify wrong sequence number is reported. test_multi_frame :: test_multi_frame_wrong_sn () Injects a CF with unexpected SN after FF.","title":"function test_multi_frame_wrong_sn"},{"location":"docs/namespacetest__multi__frame/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"docs/namespacetest__multi__frame/#function-_cf_frame","text":"Build a Consecutive Frame (CF) with a given sequence number. test_multi_frame :: _cf_frame ( sn sn , payload payload ) Parameters: sn Sequence number (0-15). payload Payload bytes to embed in CF. Returns: CAN frame bytes representing the CF. Encodes the 0x20 PCI with SN.","title":"function _cf_frame"},{"location":"docs/namespacetest__multi__frame/#function-_ff_frame","text":"Build a First Frame (FF) for an ISO-TP transfer. test_multi_frame :: _ff_frame ( payload_size payload_size , payload payload ) Parameters: payload_size Total payload size. payload Payload bytes to embed in FF. Returns: CAN frame bytes representing the FF. Encodes the 0x10 PCI with 12-bit length.","title":"function _ff_frame"},{"location":"docs/namespacetest__multi__frame/#function-_make_payload","text":"Build a deterministic payload of a given size. test_multi_frame :: _make_payload ( size size ) Parameters: size Number of bytes to generate. Returns: Payload bytes. Uses a simple modulo pattern for repeatability.","title":"function _make_payload"},{"location":"docs/namespacetest__multi__frame/#function-_poll_until_receive","text":"Poll the link until a response is received or steps are exhausted. test_multi_frame :: _poll_until_receive ( link link , payload_size payload_size , steps steps , advance_ms advance_ms = 0 ) Parameters: link ISO-TP link handle. payload_size Expected payload size for receive. steps Maximum number of poll iterations. advance_ms Optional time advance per step in milliseconds. Returns: Received payload bytes or None when nothing is received. Optionally advances the mock time between polls. The documentation for this class was generated from the following file tests/integration/test_multi_frame.py","title":"function _poll_until_receive"},{"location":"docs/namespacetest__timing/","text":"Namespace test_timing \u00b6 Namespace List > test_timing Public Functions \u00b6 Type Name test_block_size_one_roundtrip () Verify block size one roundtrip behavior. test_st_min_enforced () Verify STmin delay is enforced. test_timeout_n_ar_placeholder () Placeholder for N_Ar timeout support. test_timeout_n_as_placeholder () Placeholder for N_As timeout support. test_timeout_n_br_placeholder () Placeholder for N_Br timeout support. test_timeout_n_bs () Verify N_Bs timeout handling. test_timeout_n_cr () Verify N_Cr timeout handling. test_timeout_n_cs_placeholder () Placeholder for N_Cs timeout support. Public Functions Documentation \u00b6 function test_block_size_one_roundtrip \u00b6 Verify block size one roundtrip behavior. test_timing :: test_block_size_one_roundtrip () Uses BS=1 to enforce FC after each CF. function test_st_min_enforced \u00b6 Verify STmin delay is enforced. test_timing :: test_st_min_enforced () Ensures receive does not complete before STmin elapses. function test_timeout_n_ar_placeholder \u00b6 Placeholder for N_Ar timeout support. test_timing :: test_timeout_n_ar_placeholder () Note: Marked xfail until core enforces N_Ar. function test_timeout_n_as_placeholder \u00b6 Placeholder for N_As timeout support. test_timing :: test_timeout_n_as_placeholder () Note: Marked xfail until core enforces N_As. function test_timeout_n_br_placeholder \u00b6 Placeholder for N_Br timeout support. test_timing :: test_timeout_n_br_placeholder () Note: Marked xfail until core enforces N_Br. function test_timeout_n_bs \u00b6 Verify N_Bs timeout handling. test_timing :: test_timeout_n_bs () Disables FC to force sender timeout. function test_timeout_n_cr \u00b6 Verify N_Cr timeout handling. test_timing :: test_timeout_n_cr () Drops incoming frames to force receiver timeout. function test_timeout_n_cs_placeholder \u00b6 Placeholder for N_Cs timeout support. test_timing :: test_timeout_n_cs_placeholder () Note: Marked xfail until core enforces N_Cs. The documentation for this class was generated from the following file tests/integration/test_timing.py","title":"Namespace test_timing"},{"location":"docs/namespacetest__timing/#namespace-test_timing","text":"Namespace List > test_timing","title":"Namespace test_timing"},{"location":"docs/namespacetest__timing/#public-functions","text":"Type Name test_block_size_one_roundtrip () Verify block size one roundtrip behavior. test_st_min_enforced () Verify STmin delay is enforced. test_timeout_n_ar_placeholder () Placeholder for N_Ar timeout support. test_timeout_n_as_placeholder () Placeholder for N_As timeout support. test_timeout_n_br_placeholder () Placeholder for N_Br timeout support. test_timeout_n_bs () Verify N_Bs timeout handling. test_timeout_n_cr () Verify N_Cr timeout handling. test_timeout_n_cs_placeholder () Placeholder for N_Cs timeout support.","title":"Public Functions"},{"location":"docs/namespacetest__timing/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/namespacetest__timing/#function-test_block_size_one_roundtrip","text":"Verify block size one roundtrip behavior. test_timing :: test_block_size_one_roundtrip () Uses BS=1 to enforce FC after each CF.","title":"function test_block_size_one_roundtrip"},{"location":"docs/namespacetest__timing/#function-test_st_min_enforced","text":"Verify STmin delay is enforced. test_timing :: test_st_min_enforced () Ensures receive does not complete before STmin elapses.","title":"function test_st_min_enforced"},{"location":"docs/namespacetest__timing/#function-test_timeout_n_ar_placeholder","text":"Placeholder for N_Ar timeout support. test_timing :: test_timeout_n_ar_placeholder () Note: Marked xfail until core enforces N_Ar.","title":"function test_timeout_n_ar_placeholder"},{"location":"docs/namespacetest__timing/#function-test_timeout_n_as_placeholder","text":"Placeholder for N_As timeout support. test_timing :: test_timeout_n_as_placeholder () Note: Marked xfail until core enforces N_As.","title":"function test_timeout_n_as_placeholder"},{"location":"docs/namespacetest__timing/#function-test_timeout_n_br_placeholder","text":"Placeholder for N_Br timeout support. test_timing :: test_timeout_n_br_placeholder () Note: Marked xfail until core enforces N_Br.","title":"function test_timeout_n_br_placeholder"},{"location":"docs/namespacetest__timing/#function-test_timeout_n_bs","text":"Verify N_Bs timeout handling. test_timing :: test_timeout_n_bs () Disables FC to force sender timeout.","title":"function test_timeout_n_bs"},{"location":"docs/namespacetest__timing/#function-test_timeout_n_cr","text":"Verify N_Cr timeout handling. test_timing :: test_timeout_n_cr () Drops incoming frames to force receiver timeout.","title":"function test_timeout_n_cr"},{"location":"docs/namespacetest__timing/#function-test_timeout_n_cs_placeholder","text":"Placeholder for N_Cs timeout support. test_timing :: test_timeout_n_cs_placeholder () Note: Marked xfail until core enforces N_Cs. The documentation for this class was generated from the following file tests/integration/test_timing.py","title":"function test_timeout_n_cs_placeholder"},{"location":"docs/group__isotp/","text":"Group isotp \u00b6 Modules > isotp Public API for ISO-TP link management and message handling. More... Modules \u00b6 Type Name module Configuration Build-time configuration for ISO-TP. module Protocol definitions Internal protocol definitions and type structures. module User hooks User-implemented callbacks and platform hooks. Classes \u00b6 Type Name struct IsoTpLink Link state for a single ISO-TP connection. Public Types \u00b6 Type Name typedef struct IsoTpLink IsoTpLink Link state for a single ISO-TP connection. Public Functions \u00b6 Type Name void isotp_destroy_link ( IsoTpLink * link) Destroys the ISO-TP link and releases associated resources. void isotp_init_link ( IsoTpLink * link, uint32_t sendid, uint8_t * sendbuf, uint32_t sendbufsize, uint8_t * recvbuf, uint32_t recvbufsize) Initialises the ISO-TP library. void isotp_on_can_message ( IsoTpLink * link, const uint8_t * data, uint8_t len) Handles incoming CAN messages. Determines whether an incoming message is a valid ISO-TP frame or not and handles it accordingly. void isotp_poll ( IsoTpLink * link) Polling function; call this function periodically to handle timeouts, send consecutive frames, etc. int isotp_receive ( IsoTpLink * link, uint8_t * payload, const uint32_t payload_size, uint32_t * out_size) Receives and parses the received data and copies the parsed data into the internal buffer. int isotp_send ( IsoTpLink * link, const uint8_t payload, uint32_t size) Sends ISO-TP frames via CAN, using the ID set in the initialising function. int isotp_send_with_id ( IsoTpLink * link, uint32_t id, const uint8_t payload, uint32_t size) See isotp_send , with the exception that this function is used only for functional addressing. void isotp_set_fc_params ( IsoTpLink * link, uint8_t block_size, uint32_t st_min_us) Sets FlowControl parameters used by the receiver. void isotp_set_timeouts ( IsoTpLink * link, uint32_t n_bs_us, uint32_t n_cr_us) Sets timing parameters for waiting on FlowControl and ConsecutiveFrame. Detailed Description \u00b6 This module groups the public interface and its supporting submodules: Configuration , Protocol definitions , and User hooks . This group defines the public interface for initializing links, sending and receiving messages, handling incoming CAN frames, and polling the protocol state machine. It also exposes optional callback registration when enabled in configuration. ** ** Link lifecycle: isotp_init_link , isotp_destroy_link . Message flow: isotp_send , isotp_send_with_id , isotp_on_can_message , isotp_receive , isotp_poll . Link data model: IsoTpLink . Optional callbacks: isotp_set_tx_done_cb, isotp_set_rx_done_cb. Public Types Documentation \u00b6 typedef IsoTpLink \u00b6 Link state for a single ISO-TP connection. typedef struct IsoTpLink IsoTpLink; The data stored in this struct is used internally and may be used by software programs using this library. Public Functions Documentation \u00b6 function isotp_destroy_link \u00b6 Destroys the ISO-TP link and releases associated resources. void isotp_destroy_link ( IsoTpLink * link ) Parameters: link The IsoTpLink instance to destroy. function isotp_init_link \u00b6 Initialises the ISO-TP library. void isotp_init_link ( IsoTpLink * link, uint32_t sendid, uint8_t * sendbuf, uint32_t sendbufsize, uint8_t * recvbuf, uint32_t recvbufsize ) Parameters: link The IsoTpLink instance used for transceiving data. sendid The ID used to send data to other CAN nodes. sendbuf A pointer to an area in memory which can be used as a buffer for data to be sent. sendbufsize The size of the buffer area. recvbuf A pointer to an area in memory which can be used as a buffer for data to be received. recvbufsize The size of the buffer area. function isotp_on_can_message \u00b6 Handles incoming CAN messages. Determines whether an incoming message is a valid ISO-TP frame or not and handles it accordingly. void isotp_on_can_message ( IsoTpLink * link, const uint8_t * data, uint8_t len ) Parameters: link The IsoTpLink instance used for transceiving data. data The data received via CAN. len The length of the data received. function isotp_poll \u00b6 Polling function; call this function periodically to handle timeouts, send consecutive frames, etc. void isotp_poll ( IsoTpLink * link ) Parameters: link The IsoTpLink instance used. function isotp_receive \u00b6 Receives and parses the received data and copies the parsed data into the internal buffer. int isotp_receive ( IsoTpLink * link, uint8_t * payload, const uint32_t payload_size, uint32_t * out_size ) Parameters: link The IsoTpLink instance used to transceive data. payload A pointer to an area in memory where the raw data is copied from. payload_size The size of the received (raw) CAN data. out_size A reference to a variable which will contain the size of the actual (parsed) data. Returns: Possible return values: * ISOTP_RET_OK * ISOTP_RET_NO_DATA function isotp_send \u00b6 Sends ISO-TP frames via CAN, using the ID set in the initialising function. int isotp_send ( IsoTpLink * link, const uint8_t payload, uint32_t size ) Single-frame messages will be sent immediately when calling this function. Multi-frame messages will be sent consecutively when calling isotp_poll. Parameters: link The IsoTpLink instance used for transceiving data. payload The payload to be sent. (Up to 4095 bytes). size The size of the payload to be sent. Returns: Possible return values: * ISOTP_RET_OVERFLOW ISOTP_RET_INPROGRESS ISOTP_RET_OK The return value of the user shim function isotp_user_send_can() . function isotp_send_with_id \u00b6 See isotp_send , with the exception that this function is used only for functional addressing. int isotp_send_with_id ( IsoTpLink * link, uint32_t id, const uint8_t payload, uint32_t size ) function isotp_set_fc_params \u00b6 Sets FlowControl parameters used by the receiver. void isotp_set_fc_params ( IsoTpLink * link, uint8_t block_size, uint32_t st_min_us ) Parameters: link The IsoTpLink instance used for transceiving data. block_size Block size (BS) for FlowControl. Zero means unlimited. st_min_us Minimum separation time (STmin) in microseconds. function isotp_set_timeouts \u00b6 Sets timing parameters for waiting on FlowControl and ConsecutiveFrame. void isotp_set_timeouts ( IsoTpLink * link, uint32_t n_bs_us, uint32_t n_cr_us ) Parameters: link The IsoTpLink instance used for transceiving data. n_bs_us Timeout for N_Bs in microseconds. n_cr_us Timeout for N_Cr in microseconds.","title":"Group isotp"},{"location":"docs/group__isotp/#group-isotp","text":"Modules > isotp Public API for ISO-TP link management and message handling. More...","title":"Group isotp"},{"location":"docs/group__isotp/#modules","text":"Type Name module Configuration Build-time configuration for ISO-TP. module Protocol definitions Internal protocol definitions and type structures. module User hooks User-implemented callbacks and platform hooks.","title":"Modules"},{"location":"docs/group__isotp/#classes","text":"Type Name struct IsoTpLink Link state for a single ISO-TP connection.","title":"Classes"},{"location":"docs/group__isotp/#public-types","text":"Type Name typedef struct IsoTpLink IsoTpLink Link state for a single ISO-TP connection.","title":"Public Types"},{"location":"docs/group__isotp/#public-functions","text":"Type Name void isotp_destroy_link ( IsoTpLink * link) Destroys the ISO-TP link and releases associated resources. void isotp_init_link ( IsoTpLink * link, uint32_t sendid, uint8_t * sendbuf, uint32_t sendbufsize, uint8_t * recvbuf, uint32_t recvbufsize) Initialises the ISO-TP library. void isotp_on_can_message ( IsoTpLink * link, const uint8_t * data, uint8_t len) Handles incoming CAN messages. Determines whether an incoming message is a valid ISO-TP frame or not and handles it accordingly. void isotp_poll ( IsoTpLink * link) Polling function; call this function periodically to handle timeouts, send consecutive frames, etc. int isotp_receive ( IsoTpLink * link, uint8_t * payload, const uint32_t payload_size, uint32_t * out_size) Receives and parses the received data and copies the parsed data into the internal buffer. int isotp_send ( IsoTpLink * link, const uint8_t payload, uint32_t size) Sends ISO-TP frames via CAN, using the ID set in the initialising function. int isotp_send_with_id ( IsoTpLink * link, uint32_t id, const uint8_t payload, uint32_t size) See isotp_send , with the exception that this function is used only for functional addressing. void isotp_set_fc_params ( IsoTpLink * link, uint8_t block_size, uint32_t st_min_us) Sets FlowControl parameters used by the receiver. void isotp_set_timeouts ( IsoTpLink * link, uint32_t n_bs_us, uint32_t n_cr_us) Sets timing parameters for waiting on FlowControl and ConsecutiveFrame.","title":"Public Functions"},{"location":"docs/group__isotp/#detailed-description","text":"This module groups the public interface and its supporting submodules: Configuration , Protocol definitions , and User hooks . This group defines the public interface for initializing links, sending and receiving messages, handling incoming CAN frames, and polling the protocol state machine. It also exposes optional callback registration when enabled in configuration. ** ** Link lifecycle: isotp_init_link , isotp_destroy_link . Message flow: isotp_send , isotp_send_with_id , isotp_on_can_message , isotp_receive , isotp_poll . Link data model: IsoTpLink . Optional callbacks: isotp_set_tx_done_cb, isotp_set_rx_done_cb.","title":"Detailed Description"},{"location":"docs/group__isotp/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"docs/group__isotp/#typedef-isotplink","text":"Link state for a single ISO-TP connection. typedef struct IsoTpLink IsoTpLink; The data stored in this struct is used internally and may be used by software programs using this library.","title":"typedef IsoTpLink"},{"location":"docs/group__isotp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/group__isotp/#function-isotp_destroy_link","text":"Destroys the ISO-TP link and releases associated resources. void isotp_destroy_link ( IsoTpLink * link ) Parameters: link The IsoTpLink instance to destroy.","title":"function isotp_destroy_link"},{"location":"docs/group__isotp/#function-isotp_init_link","text":"Initialises the ISO-TP library. void isotp_init_link ( IsoTpLink * link, uint32_t sendid, uint8_t * sendbuf, uint32_t sendbufsize, uint8_t * recvbuf, uint32_t recvbufsize ) Parameters: link The IsoTpLink instance used for transceiving data. sendid The ID used to send data to other CAN nodes. sendbuf A pointer to an area in memory which can be used as a buffer for data to be sent. sendbufsize The size of the buffer area. recvbuf A pointer to an area in memory which can be used as a buffer for data to be received. recvbufsize The size of the buffer area.","title":"function isotp_init_link"},{"location":"docs/group__isotp/#function-isotp_on_can_message","text":"Handles incoming CAN messages. Determines whether an incoming message is a valid ISO-TP frame or not and handles it accordingly. void isotp_on_can_message ( IsoTpLink * link, const uint8_t * data, uint8_t len ) Parameters: link The IsoTpLink instance used for transceiving data. data The data received via CAN. len The length of the data received.","title":"function isotp_on_can_message"},{"location":"docs/group__isotp/#function-isotp_poll","text":"Polling function; call this function periodically to handle timeouts, send consecutive frames, etc. void isotp_poll ( IsoTpLink * link ) Parameters: link The IsoTpLink instance used.","title":"function isotp_poll"},{"location":"docs/group__isotp/#function-isotp_receive","text":"Receives and parses the received data and copies the parsed data into the internal buffer. int isotp_receive ( IsoTpLink * link, uint8_t * payload, const uint32_t payload_size, uint32_t * out_size ) Parameters: link The IsoTpLink instance used to transceive data. payload A pointer to an area in memory where the raw data is copied from. payload_size The size of the received (raw) CAN data. out_size A reference to a variable which will contain the size of the actual (parsed) data. Returns: Possible return values: * ISOTP_RET_OK * ISOTP_RET_NO_DATA","title":"function isotp_receive"},{"location":"docs/group__isotp/#function-isotp_send","text":"Sends ISO-TP frames via CAN, using the ID set in the initialising function. int isotp_send ( IsoTpLink * link, const uint8_t payload, uint32_t size ) Single-frame messages will be sent immediately when calling this function. Multi-frame messages will be sent consecutively when calling isotp_poll. Parameters: link The IsoTpLink instance used for transceiving data. payload The payload to be sent. (Up to 4095 bytes). size The size of the payload to be sent. Returns: Possible return values: * ISOTP_RET_OVERFLOW ISOTP_RET_INPROGRESS ISOTP_RET_OK The return value of the user shim function isotp_user_send_can() .","title":"function isotp_send"},{"location":"docs/group__isotp/#function-isotp_send_with_id","text":"See isotp_send , with the exception that this function is used only for functional addressing. int isotp_send_with_id ( IsoTpLink * link, uint32_t id, const uint8_t payload, uint32_t size )","title":"function isotp_send_with_id"},{"location":"docs/group__isotp/#function-isotp_set_fc_params","text":"Sets FlowControl parameters used by the receiver. void isotp_set_fc_params ( IsoTpLink * link, uint8_t block_size, uint32_t st_min_us ) Parameters: link The IsoTpLink instance used for transceiving data. block_size Block size (BS) for FlowControl. Zero means unlimited. st_min_us Minimum separation time (STmin) in microseconds.","title":"function isotp_set_fc_params"},{"location":"docs/group__isotp/#function-isotp_set_timeouts","text":"Sets timing parameters for waiting on FlowControl and ConsecutiveFrame. void isotp_set_timeouts ( IsoTpLink * link, uint32_t n_bs_us, uint32_t n_cr_us ) Parameters: link The IsoTpLink instance used for transceiving data. n_bs_us Timeout for N_Bs in microseconds. n_cr_us Timeout for N_Cr in microseconds.","title":"function isotp_set_timeouts"},{"location":"docs/structIsoTpLink/","text":"Struct IsoTpLink \u00b6 ClassList > IsoTpLink Link state for a single ISO-TP connection. More... #include <isotp.h> Public Attributes \u00b6 Type Name uint8_t param_block_size uint32_t param_n_bs_us uint32_t param_n_cr_us uint32_t param_st_min_us uint32_t receive_arbitration_id uint8_t receive_bs_count uint32_t receive_buf_size uint8_t * receive_buffer uint32_t receive_offset int receive_protocol_result uint32_t receive_size uint8_t receive_sn uint8_t receive_status uint32_t receive_timer_cr uint32_t send_arbitration_id uint32_t send_bs_remain uint32_t send_buf_size uint8_t * send_buffer uint32_t send_offset int32_t send_protocol_result uint32_t send_size uint8_t send_sn uint32_t send_st_min_us uint8_t send_status uint32_t send_timer_bs uint32_t send_timer_st uint8_t send_wtf_count Detailed Description \u00b6 The data stored in this struct is used internally and may be used by software programs using this library. Public Attributes Documentation \u00b6 variable param_block_size \u00b6 uint8_t IsoTpLink :: param_block_size ; Block size (BS) for FlowControl. variable param_n_bs_us \u00b6 uint32_t IsoTpLink :: param_n_bs_us ; N_Bs timeout in microseconds. variable param_n_cr_us \u00b6 uint32_t IsoTpLink :: param_n_cr_us ; N_Cr timeout in microseconds. variable param_st_min_us \u00b6 uint32_t IsoTpLink :: param_st_min_us ; STmin in microseconds. variable receive_arbitration_id \u00b6 uint32_t IsoTpLink :: receive_arbitration_id ; Arbitration ID used for reception. variable receive_bs_count \u00b6 uint8_t IsoTpLink :: receive_bs_count ; Max number of FC.Wait frames to send. variable receive_buf_size \u00b6 uint32_t IsoTpLink :: receive_buf_size ; Receive buffer size in bytes. variable receive_buffer \u00b6 uint8_t * IsoTpLink :: receive_buffer ; Receive buffer base pointer. variable receive_offset \u00b6 uint32_t IsoTpLink :: receive_offset ; Current receive offset in bytes. variable receive_protocol_result \u00b6 int IsoTpLink :: receive_protocol_result ; Last protocol result code for receiver. variable receive_size \u00b6 uint32_t IsoTpLink :: receive_size ; Total received size in bytes. variable receive_sn \u00b6 uint8_t IsoTpLink :: receive_sn ; Expected sequence number. variable receive_status \u00b6 uint8_t IsoTpLink :: receive_status ; Receiver status. variable receive_timer_cr \u00b6 uint32_t IsoTpLink :: receive_timer_cr ; Timer until next ConsecutiveFrame is expected. variable send_arbitration_id \u00b6 uint32_t IsoTpLink :: send_arbitration_id ; Arbitration ID used for consecutive frames. variable send_bs_remain \u00b6 uint32_t IsoTpLink :: send_bs_remain ; Remaining block size. variable send_buf_size \u00b6 uint32_t IsoTpLink :: send_buf_size ; Send buffer size in bytes. variable send_buffer \u00b6 uint8_t * IsoTpLink :: send_buffer ; Send buffer base pointer. variable send_offset \u00b6 uint32_t IsoTpLink :: send_offset ; Current send offset in bytes. variable send_protocol_result \u00b6 int32_t IsoTpLink :: send_protocol_result ; Last protocol result code for sender. variable send_size \u00b6 uint32_t IsoTpLink :: send_size ; Total size to send in bytes. variable send_sn \u00b6 uint8_t IsoTpLink :: send_sn ; Current sequence number. variable send_st_min_us \u00b6 uint32_t IsoTpLink :: send_st_min_us ; Minimum separation time in microseconds. variable send_status \u00b6 uint8_t IsoTpLink :: send_status ; Sender status. variable send_timer_bs \u00b6 uint32_t IsoTpLink :: send_timer_bs ; Timer until next FlowControl is expected. variable send_timer_st \u00b6 uint32_t IsoTpLink :: send_timer_st ; Timestamp of last consecutive frame send. variable send_wtf_count \u00b6 uint8_t IsoTpLink :: send_wtf_count ; Max number of FC.Wait frames to send. The documentation for this class was generated from the following file isotp.h","title":"Struct IsoTpLink"},{"location":"docs/structIsoTpLink/#struct-isotplink","text":"ClassList > IsoTpLink Link state for a single ISO-TP connection. More... #include <isotp.h>","title":"Struct IsoTpLink"},{"location":"docs/structIsoTpLink/#public-attributes","text":"Type Name uint8_t param_block_size uint32_t param_n_bs_us uint32_t param_n_cr_us uint32_t param_st_min_us uint32_t receive_arbitration_id uint8_t receive_bs_count uint32_t receive_buf_size uint8_t * receive_buffer uint32_t receive_offset int receive_protocol_result uint32_t receive_size uint8_t receive_sn uint8_t receive_status uint32_t receive_timer_cr uint32_t send_arbitration_id uint32_t send_bs_remain uint32_t send_buf_size uint8_t * send_buffer uint32_t send_offset int32_t send_protocol_result uint32_t send_size uint8_t send_sn uint32_t send_st_min_us uint8_t send_status uint32_t send_timer_bs uint32_t send_timer_st uint8_t send_wtf_count","title":"Public Attributes"},{"location":"docs/structIsoTpLink/#detailed-description","text":"The data stored in this struct is used internally and may be used by software programs using this library.","title":"Detailed Description"},{"location":"docs/structIsoTpLink/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/structIsoTpLink/#variable-param_block_size","text":"uint8_t IsoTpLink :: param_block_size ; Block size (BS) for FlowControl.","title":"variable param_block_size"},{"location":"docs/structIsoTpLink/#variable-param_n_bs_us","text":"uint32_t IsoTpLink :: param_n_bs_us ; N_Bs timeout in microseconds.","title":"variable param_n_bs_us"},{"location":"docs/structIsoTpLink/#variable-param_n_cr_us","text":"uint32_t IsoTpLink :: param_n_cr_us ; N_Cr timeout in microseconds.","title":"variable param_n_cr_us"},{"location":"docs/structIsoTpLink/#variable-param_st_min_us","text":"uint32_t IsoTpLink :: param_st_min_us ; STmin in microseconds.","title":"variable param_st_min_us"},{"location":"docs/structIsoTpLink/#variable-receive_arbitration_id","text":"uint32_t IsoTpLink :: receive_arbitration_id ; Arbitration ID used for reception.","title":"variable receive_arbitration_id"},{"location":"docs/structIsoTpLink/#variable-receive_bs_count","text":"uint8_t IsoTpLink :: receive_bs_count ; Max number of FC.Wait frames to send.","title":"variable receive_bs_count"},{"location":"docs/structIsoTpLink/#variable-receive_buf_size","text":"uint32_t IsoTpLink :: receive_buf_size ; Receive buffer size in bytes.","title":"variable receive_buf_size"},{"location":"docs/structIsoTpLink/#variable-receive_buffer","text":"uint8_t * IsoTpLink :: receive_buffer ; Receive buffer base pointer.","title":"variable receive_buffer"},{"location":"docs/structIsoTpLink/#variable-receive_offset","text":"uint32_t IsoTpLink :: receive_offset ; Current receive offset in bytes.","title":"variable receive_offset"},{"location":"docs/structIsoTpLink/#variable-receive_protocol_result","text":"int IsoTpLink :: receive_protocol_result ; Last protocol result code for receiver.","title":"variable receive_protocol_result"},{"location":"docs/structIsoTpLink/#variable-receive_size","text":"uint32_t IsoTpLink :: receive_size ; Total received size in bytes.","title":"variable receive_size"},{"location":"docs/structIsoTpLink/#variable-receive_sn","text":"uint8_t IsoTpLink :: receive_sn ; Expected sequence number.","title":"variable receive_sn"},{"location":"docs/structIsoTpLink/#variable-receive_status","text":"uint8_t IsoTpLink :: receive_status ; Receiver status.","title":"variable receive_status"},{"location":"docs/structIsoTpLink/#variable-receive_timer_cr","text":"uint32_t IsoTpLink :: receive_timer_cr ; Timer until next ConsecutiveFrame is expected.","title":"variable receive_timer_cr"},{"location":"docs/structIsoTpLink/#variable-send_arbitration_id","text":"uint32_t IsoTpLink :: send_arbitration_id ; Arbitration ID used for consecutive frames.","title":"variable send_arbitration_id"},{"location":"docs/structIsoTpLink/#variable-send_bs_remain","text":"uint32_t IsoTpLink :: send_bs_remain ; Remaining block size.","title":"variable send_bs_remain"},{"location":"docs/structIsoTpLink/#variable-send_buf_size","text":"uint32_t IsoTpLink :: send_buf_size ; Send buffer size in bytes.","title":"variable send_buf_size"},{"location":"docs/structIsoTpLink/#variable-send_buffer","text":"uint8_t * IsoTpLink :: send_buffer ; Send buffer base pointer.","title":"variable send_buffer"},{"location":"docs/structIsoTpLink/#variable-send_offset","text":"uint32_t IsoTpLink :: send_offset ; Current send offset in bytes.","title":"variable send_offset"},{"location":"docs/structIsoTpLink/#variable-send_protocol_result","text":"int32_t IsoTpLink :: send_protocol_result ; Last protocol result code for sender.","title":"variable send_protocol_result"},{"location":"docs/structIsoTpLink/#variable-send_size","text":"uint32_t IsoTpLink :: send_size ; Total size to send in bytes.","title":"variable send_size"},{"location":"docs/structIsoTpLink/#variable-send_sn","text":"uint8_t IsoTpLink :: send_sn ; Current sequence number.","title":"variable send_sn"},{"location":"docs/structIsoTpLink/#variable-send_st_min_us","text":"uint32_t IsoTpLink :: send_st_min_us ; Minimum separation time in microseconds.","title":"variable send_st_min_us"},{"location":"docs/structIsoTpLink/#variable-send_status","text":"uint8_t IsoTpLink :: send_status ; Sender status.","title":"variable send_status"},{"location":"docs/structIsoTpLink/#variable-send_timer_bs","text":"uint32_t IsoTpLink :: send_timer_bs ; Timer until next FlowControl is expected.","title":"variable send_timer_bs"},{"location":"docs/structIsoTpLink/#variable-send_timer_st","text":"uint32_t IsoTpLink :: send_timer_st ; Timestamp of last consecutive frame send.","title":"variable send_timer_st"},{"location":"docs/structIsoTpLink/#variable-send_wtf_count","text":"uint8_t IsoTpLink :: send_wtf_count ; Max number of FC.Wait frames to send. The documentation for this class was generated from the following file isotp.h","title":"variable send_wtf_count"},{"location":"docs/group__isotp__config/","text":"Group isotp_config \u00b6 Modules > isotp_config Build-time configuration for ISO-TP. More... Detailed Description \u00b6 Configuration parameters in this group control protocol behavior as exposed by the API in isotp.h and implemented in isotp.c. They cover limits and timing used when sending and receiving single- and multi-frame messages, including block size (BS), minimum separation time (ST_min), and response timeouts. They also enable optional features such as frame padding, an extra argument for isotp_user_send_can, and callbacks for transmit and receive completion. ** ** ISO_TP_DEFAULT_BLOCK_SIZE : default receiver block size (BS). ISO_TP_DEFAULT_ST_MIN_US : default minimum separation time (ST_min) in us. ISO_TP_MAX_WFT_NUMBER : maximum number of FC.Wait frames in a row. ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US : response timeout during multi-frame transfer. ISO_TP_FRAME_PADDING : enable frame padding for ISO-TP frames. ISO_TP_FRAME_PADDING_VALUE : padding byte value when padding is enabled. ISO_TP_USER_SEND_CAN_ARG : add a user argument to isotp_user_send_can . ISO_TP_TRANSMIT_COMPLETE_CALLBACK : enable transmit complete callback support. ISO_TP_RECEIVE_COMPLETE_CALLBACK: enable receive complete callback support.","title":"Group isotp_config"},{"location":"docs/group__isotp__config/#group-isotp_config","text":"Modules > isotp_config Build-time configuration for ISO-TP. More...","title":"Group isotp_config"},{"location":"docs/group__isotp__config/#detailed-description","text":"Configuration parameters in this group control protocol behavior as exposed by the API in isotp.h and implemented in isotp.c. They cover limits and timing used when sending and receiving single- and multi-frame messages, including block size (BS), minimum separation time (ST_min), and response timeouts. They also enable optional features such as frame padding, an extra argument for isotp_user_send_can, and callbacks for transmit and receive completion. ** ** ISO_TP_DEFAULT_BLOCK_SIZE : default receiver block size (BS). ISO_TP_DEFAULT_ST_MIN_US : default minimum separation time (ST_min) in us. ISO_TP_MAX_WFT_NUMBER : maximum number of FC.Wait frames in a row. ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US : response timeout during multi-frame transfer. ISO_TP_FRAME_PADDING : enable frame padding for ISO-TP frames. ISO_TP_FRAME_PADDING_VALUE : padding byte value when padding is enabled. ISO_TP_USER_SEND_CAN_ARG : add a user argument to isotp_user_send_can . ISO_TP_TRANSMIT_COMPLETE_CALLBACK : enable transmit complete callback support. ISO_TP_RECEIVE_COMPLETE_CALLBACK: enable receive complete callback support.","title":"Detailed Description"},{"location":"docs/group__isotp__defines/","text":"Group isotp_defines \u00b6 Modules > isotp_defines Internal protocol definitions and type structures. More... Detailed Description \u00b6 This group contains the low-level building blocks used by the ISO-TP core (frame layouts, PCI types, status codes, and timing helpers). These definitions describe how CAN frames are encoded/decoded and provide enums and constants that drive the state machine in isotp.c. ** ** Frame layout structs: IsoTpSingleFrame , IsoTpFirstFrameShort , IsoTpFirstFrameLong, IsoTpConsecutiveFrame , IsoTpFlowControl . Frame container: IsoTpCanMessage and IsoTpDataArray . PCI type and flow status enums: IsoTpProtocolControlInformation , IsoTpFlowStatus . Return codes and protocol result codes: ISOTP_RET_OK , ISOTP_RET_ERROR, ISOTP_RET_INPROGRESS, ISOTP_RET_OVERFLOW, ISOTP_RET_WRONG_SN, ISOTP_RET_NO_DATA, ISOTP_RET_TIMEOUT, ISOTP_RET_LENGTH, ISOTP_RET_NOSPACE, ISOTP_PROTOCOL_RESULT_OK , ISOTP_PROTOCOL_RESULT_TIMEOUT_A, ISOTP_PROTOCOL_RESULT_TIMEOUT_BS, ISOTP_PROTOCOL_RESULT_TIMEOUT_CR, ISOTP_PROTOCOL_RESULT_WRONG_SN, ISOTP_PROTOCOL_RESULT_INVALID_FS, ISOTP_PROTOCOL_RESULT_UNEXP_PDU, ISOTP_PROTOCOL_RESULT_WFT_OVRN, ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW, ISOTP_PROTOCOL_RESULT_ERROR. Byte order and packing helpers: ISOTP_BYTE_ORDER_LITTLE_ENDIAN, ISOTP_PACKED_STRUCT , LE32TOH . Status types and helpers: IsoTpSendStatusTypes , IsoTpReceiveStatusTypes , IsoTpTimeAfter , ISOTP_INVALID_BS , ISOTP_MAX_ERROR_MSG_SIZE .","title":"Group isotp_defines"},{"location":"docs/group__isotp__defines/#group-isotp_defines","text":"Modules > isotp_defines Internal protocol definitions and type structures. More...","title":"Group isotp_defines"},{"location":"docs/group__isotp__defines/#detailed-description","text":"This group contains the low-level building blocks used by the ISO-TP core (frame layouts, PCI types, status codes, and timing helpers). These definitions describe how CAN frames are encoded/decoded and provide enums and constants that drive the state machine in isotp.c. ** ** Frame layout structs: IsoTpSingleFrame , IsoTpFirstFrameShort , IsoTpFirstFrameLong, IsoTpConsecutiveFrame , IsoTpFlowControl . Frame container: IsoTpCanMessage and IsoTpDataArray . PCI type and flow status enums: IsoTpProtocolControlInformation , IsoTpFlowStatus . Return codes and protocol result codes: ISOTP_RET_OK , ISOTP_RET_ERROR, ISOTP_RET_INPROGRESS, ISOTP_RET_OVERFLOW, ISOTP_RET_WRONG_SN, ISOTP_RET_NO_DATA, ISOTP_RET_TIMEOUT, ISOTP_RET_LENGTH, ISOTP_RET_NOSPACE, ISOTP_PROTOCOL_RESULT_OK , ISOTP_PROTOCOL_RESULT_TIMEOUT_A, ISOTP_PROTOCOL_RESULT_TIMEOUT_BS, ISOTP_PROTOCOL_RESULT_TIMEOUT_CR, ISOTP_PROTOCOL_RESULT_WRONG_SN, ISOTP_PROTOCOL_RESULT_INVALID_FS, ISOTP_PROTOCOL_RESULT_UNEXP_PDU, ISOTP_PROTOCOL_RESULT_WFT_OVRN, ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW, ISOTP_PROTOCOL_RESULT_ERROR. Byte order and packing helpers: ISOTP_BYTE_ORDER_LITTLE_ENDIAN, ISOTP_PACKED_STRUCT , LE32TOH . Status types and helpers: IsoTpSendStatusTypes , IsoTpReceiveStatusTypes , IsoTpTimeAfter , ISOTP_INVALID_BS , ISOTP_MAX_ERROR_MSG_SIZE .","title":"Detailed Description"},{"location":"docs/group__isotp__user/","text":"Group isotp_user \u00b6 Modules > isotp_user User-implemented callbacks and platform hooks. More... Public Functions \u00b6 Type Name void isotp_user_debug (const char * message, ...) User implemented, print debug message. uint32_t isotp_user_get_us (void) User implemented, return a monotonically increasing timebase in microseconds. int isotp_user_send_can (const uint32_t arbitration_id, const uint8_t * data, const uint8_t size) User implemented, send CAN message. Detailed Description \u00b6 This group defines the platform abstraction points required by the ISO-TP core. Applications must provide these functions to integrate with their CAN driver, timing source, and optional debug output. ** ** Debug output hook: isotp_user_debug . CAN transmit hook: isotp_user_send_can (optionally with ISO_TP_USER_SEND_CAN_ARG). Time source hook: isotp_user_get_us . Public Functions Documentation \u00b6 function isotp_user_debug \u00b6 User implemented, print debug message. void isotp_user_debug ( const char * message, ... ) Parameters: message Debug message format string. User implemented, print debug message. Parameters: message The message to print. User implemented, print debug message. function isotp_user_get_us \u00b6 User implemented, return a monotonically increasing timebase in microseconds. uint32_t isotp_user_get_us ( void ) This function must provide a free-running timestamp in microseconds that increases monotonically over time. The ISO-TP core uses this value for timeout and delay calculations by performing arithmetic on the returned timestamp (for example, adding a timeout interval to it). Natural wrap-around of the 32-bit counter is allowed and will be handled by the ISO-TP core, but the value must not jump backwards except for such wrap-around. Returns: Current timebase value in microseconds. User implemented, return a monotonically increasing timebase in microseconds. Returns: uint32_t Current time in microseconds User implemented, return a monotonically increasing timebase in microseconds. function isotp_user_send_can \u00b6 User implemented, send CAN message. int isotp_user_send_can ( const uint32_t arbitration_id, const uint8_t * data, const uint8_t size ) Should return ISOTP_RET_OK on success. Parameters: arbitration_id CAN message arbitration ID. data Pointer to message data buffer. size Size of message data in bytes. Returns: ISOTP_RET_OK on success, ISOTP_RET_NOSPACE if transfer should be retried later, or ISOTP_RET_ERROR on failure. User implemented, send CAN message. Parameters: arbitration_id The CAN ID to send with. data Pointer to the data buffer to send. size Size of the data buffer (max 8 bytes). Returns: int ISOTP_RET_OK on success, ISOTP_RET_ERROR on failure. User implemented, send CAN message.","title":"Group isotp_user"},{"location":"docs/group__isotp__user/#group-isotp_user","text":"Modules > isotp_user User-implemented callbacks and platform hooks. More...","title":"Group isotp_user"},{"location":"docs/group__isotp__user/#public-functions","text":"Type Name void isotp_user_debug (const char * message, ...) User implemented, print debug message. uint32_t isotp_user_get_us (void) User implemented, return a monotonically increasing timebase in microseconds. int isotp_user_send_can (const uint32_t arbitration_id, const uint8_t * data, const uint8_t size) User implemented, send CAN message.","title":"Public Functions"},{"location":"docs/group__isotp__user/#detailed-description","text":"This group defines the platform abstraction points required by the ISO-TP core. Applications must provide these functions to integrate with their CAN driver, timing source, and optional debug output. ** ** Debug output hook: isotp_user_debug . CAN transmit hook: isotp_user_send_can (optionally with ISO_TP_USER_SEND_CAN_ARG). Time source hook: isotp_user_get_us .","title":"Detailed Description"},{"location":"docs/group__isotp__user/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/group__isotp__user/#function-isotp_user_debug","text":"User implemented, print debug message. void isotp_user_debug ( const char * message, ... ) Parameters: message Debug message format string. User implemented, print debug message. Parameters: message The message to print. User implemented, print debug message.","title":"function isotp_user_debug"},{"location":"docs/group__isotp__user/#function-isotp_user_get_us","text":"User implemented, return a monotonically increasing timebase in microseconds. uint32_t isotp_user_get_us ( void ) This function must provide a free-running timestamp in microseconds that increases monotonically over time. The ISO-TP core uses this value for timeout and delay calculations by performing arithmetic on the returned timestamp (for example, adding a timeout interval to it). Natural wrap-around of the 32-bit counter is allowed and will be handled by the ISO-TP core, but the value must not jump backwards except for such wrap-around. Returns: Current timebase value in microseconds. User implemented, return a monotonically increasing timebase in microseconds. Returns: uint32_t Current time in microseconds User implemented, return a monotonically increasing timebase in microseconds.","title":"function isotp_user_get_us"},{"location":"docs/group__isotp__user/#function-isotp_user_send_can","text":"User implemented, send CAN message. int isotp_user_send_can ( const uint32_t arbitration_id, const uint8_t * data, const uint8_t size ) Should return ISOTP_RET_OK on success. Parameters: arbitration_id CAN message arbitration ID. data Pointer to message data buffer. size Size of message data in bytes. Returns: ISOTP_RET_OK on success, ISOTP_RET_NOSPACE if transfer should be retried later, or ISOTP_RET_ERROR on failure. User implemented, send CAN message. Parameters: arbitration_id The CAN ID to send with. data Pointer to the data buffer to send. size Size of the data buffer (max 8 bytes). Returns: int ISOTP_RET_OK on success, ISOTP_RET_ERROR on failure. User implemented, send CAN message.","title":"function isotp_user_send_can"},{"location":"docs/dir_d28a4824dc47e487b107a5db32ef43c4/","text":"Dir examples \u00b6 FileList > examples Directories \u00b6 Type Name dir linux_socket dir python_api The documentation for this class was generated from the following file examples/","title":"Dir examples"},{"location":"docs/dir_d28a4824dc47e487b107a5db32ef43c4/#dir-examples","text":"FileList > examples","title":"Dir examples"},{"location":"docs/dir_d28a4824dc47e487b107a5db32ef43c4/#directories","text":"Type Name dir linux_socket dir python_api The documentation for this class was generated from the following file examples/","title":"Directories"},{"location":"docs/dir_7880a7b12136fba6b737e09baa66bc78/","text":"Dir examples/linux_socket \u00b6 FileList > examples > linux_socket Files \u00b6 Type Name file linux_socket.c The documentation for this class was generated from the following file examples/linux_socket/","title":"Dir examples/linux_socket"},{"location":"docs/dir_7880a7b12136fba6b737e09baa66bc78/#dir-exampleslinux_socket","text":"FileList > examples > linux_socket","title":"Dir examples/linux_socket"},{"location":"docs/dir_7880a7b12136fba6b737e09baa66bc78/#files","text":"Type Name file linux_socket.c The documentation for this class was generated from the following file examples/linux_socket/","title":"Files"},{"location":"docs/linux__socket_8c/","text":"File linux_socket.c \u00b6 FileList > examples > linux_socket > linux_socket.c Go to the source code of this file #include <stdio.h> #include <stdlib.h> #include <stdbool.h> #include <string.h> #include <unistd.h> #include <time.h> #include <stdarg.h> #include <net/if.h> #include <sys/ioctl.h> #include <sys/socket.h> #include <linux/can.h> #include <linux/can/raw.h> #include <isotp.h> Public Static Attributes \u00b6 Type Name int _socket SocketCAN file descriptor. uint8_t g_isotpRecvBuf uint8_t g_isotpSendBuf IsoTpLink g_link ISO-TP link instance, allocated statically in RAM. Public Functions \u00b6 Type Name int main (int argc, char ** argv) Macros \u00b6 Type Name define SEC_TO_US (sec) ((sec) \\* 1000000) Macro to convert seconds to microseconds. define _CAN_INTERFACE \"slcan0\" CAN interface to use (e.g., \"can0\", \"slcan0\", etc.) define _ISOTP_BUFSIZE (128) Buffer size for ISO-TP messages (must be >= 4095 for full ISO-TP support)/*#end#* /. define _ISOTP_CAN_ID (0x0C1) CAN ID to use for sending ISO-TP messages (must match the receiver's expected ID)/*#end#* /. Public Static Attributes Documentation \u00b6 variable _socket \u00b6 SocketCAN file descriptor. int _socket ; variable g_isotpRecvBuf \u00b6 uint8_t g_isotpRecvBuf [ _ISOTP_BUFSIZE ]; Buffer for receiving ISO-TP messages, allocated statically in RAM variable g_isotpSendBuf \u00b6 uint8_t g_isotpSendBuf [ _ISOTP_BUFSIZE ]; Buffer for sending ISO-TP messages, allocated statically in RAM variable g_link \u00b6 ISO-TP link instance, allocated statically in RAM. IsoTpLink g_link ; Public Functions Documentation \u00b6 function main \u00b6 int main ( int argc , char ** argv ) Macro Definition Documentation \u00b6 define SEC_TO_US \u00b6 Macro to convert seconds to microseconds. #define SEC_TO_US ( sec ) ` (( sec ) * 1000000 ) ` define _CAN_INTERFACE \u00b6 CAN interface to use (e.g., \"can0\", \"slcan0\", etc.) #define _CAN_INTERFACE `\"slcan0\"` define _ISOTP_BUFSIZE \u00b6 Buffer size for ISO-TP messages (must be >= 4095 for full ISO-TP support)/*#end#* /. #define _ISOTP_BUFSIZE `(128)` define _ISOTP_CAN_ID \u00b6 CAN ID to use for sending ISO-TP messages (must match the receiver's expected ID)/*#end#* /. #define _ISOTP_CAN_ID `(0x0C1)` The documentation for this class was generated from the following file examples/linux_socket/linux_socket.c","title":"File linux_socket.c"},{"location":"docs/linux__socket_8c/#file-linux_socketc","text":"FileList > examples > linux_socket > linux_socket.c Go to the source code of this file #include <stdio.h> #include <stdlib.h> #include <stdbool.h> #include <string.h> #include <unistd.h> #include <time.h> #include <stdarg.h> #include <net/if.h> #include <sys/ioctl.h> #include <sys/socket.h> #include <linux/can.h> #include <linux/can/raw.h> #include <isotp.h>","title":"File linux_socket.c"},{"location":"docs/linux__socket_8c/#public-static-attributes","text":"Type Name int _socket SocketCAN file descriptor. uint8_t g_isotpRecvBuf uint8_t g_isotpSendBuf IsoTpLink g_link ISO-TP link instance, allocated statically in RAM.","title":"Public Static Attributes"},{"location":"docs/linux__socket_8c/#public-functions","text":"Type Name int main (int argc, char ** argv)","title":"Public Functions"},{"location":"docs/linux__socket_8c/#macros","text":"Type Name define SEC_TO_US (sec) ((sec) \\* 1000000) Macro to convert seconds to microseconds. define _CAN_INTERFACE \"slcan0\" CAN interface to use (e.g., \"can0\", \"slcan0\", etc.) define _ISOTP_BUFSIZE (128) Buffer size for ISO-TP messages (must be >= 4095 for full ISO-TP support)/*#end#* /. define _ISOTP_CAN_ID (0x0C1) CAN ID to use for sending ISO-TP messages (must match the receiver's expected ID)/*#end#* /.","title":"Macros"},{"location":"docs/linux__socket_8c/#public-static-attributes-documentation","text":"","title":"Public Static Attributes Documentation"},{"location":"docs/linux__socket_8c/#variable-_socket","text":"SocketCAN file descriptor. int _socket ;","title":"variable _socket"},{"location":"docs/linux__socket_8c/#variable-g_isotprecvbuf","text":"uint8_t g_isotpRecvBuf [ _ISOTP_BUFSIZE ]; Buffer for receiving ISO-TP messages, allocated statically in RAM","title":"variable g_isotpRecvBuf"},{"location":"docs/linux__socket_8c/#variable-g_isotpsendbuf","text":"uint8_t g_isotpSendBuf [ _ISOTP_BUFSIZE ]; Buffer for sending ISO-TP messages, allocated statically in RAM","title":"variable g_isotpSendBuf"},{"location":"docs/linux__socket_8c/#variable-g_link","text":"ISO-TP link instance, allocated statically in RAM. IsoTpLink g_link ;","title":"variable g_link"},{"location":"docs/linux__socket_8c/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/linux__socket_8c/#function-main","text":"int main ( int argc , char ** argv )","title":"function main"},{"location":"docs/linux__socket_8c/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"docs/linux__socket_8c/#define-sec_to_us","text":"Macro to convert seconds to microseconds. #define SEC_TO_US ( sec ) ` (( sec ) * 1000000 ) `","title":"define SEC_TO_US"},{"location":"docs/linux__socket_8c/#define-_can_interface","text":"CAN interface to use (e.g., \"can0\", \"slcan0\", etc.) #define _CAN_INTERFACE `\"slcan0\"`","title":"define _CAN_INTERFACE"},{"location":"docs/linux__socket_8c/#define-_isotp_bufsize","text":"Buffer size for ISO-TP messages (must be >= 4095 for full ISO-TP support)/*#end#* /. #define _ISOTP_BUFSIZE `(128)`","title":"define _ISOTP_BUFSIZE"},{"location":"docs/linux__socket_8c/#define-_isotp_can_id","text":"CAN ID to use for sending ISO-TP messages (must match the receiver's expected ID)/*#end#* /. #define _ISOTP_CAN_ID `(0x0C1)` The documentation for this class was generated from the following file examples/linux_socket/linux_socket.c","title":"define _ISOTP_CAN_ID"},{"location":"docs/linux__socket_8c_source/","text":"File linux_socket.c \u00b6 File List > examples > linux_socket > linux_socket.c Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Example implementation of ISO-TP over Linux SocketCAN * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <stdio.h> #include <stdlib.h> #include <stdbool.h> #include <string.h> #include <unistd.h> #include <time.h> #include <stdarg.h> #include <net/if.h> #include <sys/ioctl.h> #include <sys/socket.h> #include <linux/can.h> #include <linux/can/raw.h> #include <isotp.h> /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ #define _CAN_INTERFACE \"slcan0\" #define _ISOTP_BUFSIZE \\ (128) #define _ISOTP_CAN_ID \\ (0x0C1) #define SEC_TO_US(sec) ((sec) * 1000000) /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Static type definitions local to this file */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ static IsoTpLink g_link ; static uint8_t g_isotpRecvBuf [ _ISOTP_BUFSIZE ]; static uint8_t g_isotpSendBuf [ _ISOTP_BUFSIZE ]; static int _socket ; /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ uint32_t isotp_user_get_us ( void ); void isotp_user_debug ( const char * message , ...); int isotp_user_send_can ( const uint32_t arbitration_id , const uint8_t * data , const uint8_t size #ifdef ISO_TP_USER_SEND_CAN_ARG , void * arg #endif ); /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ void isotp_user_debug ( const char * message , ...) { va_list args ; va_start ( args , message ); vfprintf ( stderr , message , args ); va_end ( args ); } int isotp_user_send_can ( const uint32_t arbitration_id , const uint8_t * data , const uint8_t size #ifdef ISO_TP_USER_SEND_CAN_ARG , void * arg #endif ) { int ret = ISOTP_RET_ERROR ; struct can_frame frame ; frame . can_id = arbitration_id | CAN_EFF_FLAG ; frame . can_dlc = size ; memcpy ( frame . data , data , size ); #ifdef ISO_TP_USER_SEND_CAN_ARG ( void ) arg ; #endif ssize_t ret_size = write ( _socket , & frame , sizeof ( struct can_frame )); if ( ret_size == sizeof ( struct can_frame )) { ret = ISOTP_RET_OK ; } return ret ; /* TODO: Check return value */ } uint32_t isotp_user_get_us ( void ) { uint64_t microsecond ; struct timespec ts ; if ( clock_gettime ( CLOCK_MONOTONIC , & ts ) != 0 ) { perror ( \"Failed to obtain monotonic timestamp.\" ); microsecond = UINT64_MAX ; // use this to indicate error } else { // `ts` now contains your timestamp in seconds and microseconds! To // convert the whole struct to microseconds, do this: microsecond = SEC_TO_US (( uint64_t ) ts . tv_sec ) + ( uint64_t ) ( ts . tv_nsec / 1000 ); } return ( uint32_t ) microsecond ; } /* ============================================================================== * PUBLIC FUNCTION IMPLEMENTATIONS * =============================================================================*/ int main ( int argc , char ** argv ) { int i ; int nbytes ; struct sockaddr_can addr ; struct ifreq ifr ; struct can_frame frame ; printf ( \"CAN Sockets Demo \\r\\n \" ); _socket = socket ( PF_CAN , SOCK_RAW , CAN_RAW ); if ( _socket < 0 ) { perror ( \"Socket\" ); return 1 ; } strcpy ( ifr . ifr_name , _CAN_INTERFACE ); ioctl ( _socket , SIOCGIFINDEX , & ifr ); memset ( & addr , 0 , sizeof ( addr )); addr . can_family = AF_CAN ; addr . can_ifindex = ifr . ifr_ifindex ; if ( bind ( _socket , ( struct sockaddr * ) & addr , sizeof ( addr )) < 0 ) { perror ( \"Bind\" ); return 1 ; } /* Init ISOTP lib */ /* Initialize link, ISOTP_CAN_ID is the CAN ID you send with */ isotp_init_link ( & g_link , _ISOTP_CAN_ID , g_isotpSendBuf , sizeof ( g_isotpSendBuf ), g_isotpRecvBuf , sizeof ( g_isotpRecvBuf )); while ( true ) { nbytes = read ( _socket , & frame , sizeof ( struct can_frame )); if ( nbytes < 0 ) { perror ( \"Read\" ); break ; } uint32_t arbitration_id = frame . can_id & CAN_EFF_MASK ; if ( arbitration_id != _ISOTP_CAN_ID ) { continue ; } isotp_on_can_message ( & g_link , frame . data , frame . can_dlc ); isotp_poll ( & g_link ); if ( g_link . receive_status == ISOTP_RECEIVE_STATUS_FULL ) { uint8_t payload [ _ISOTP_BUFSIZE ] = { 0 }; uint32_t out_size = 0 ; int ret = isotp_receive ( & g_link , payload , sizeof ( payload ), & out_size ); if ( ret == ISOTP_RET_OK ) { bool is_eff = ( frame . can_id & CAN_EFF_FLAG ) != 0U ; uint32_t can_id = frame . can_id & ( is_eff ? CAN_EFF_MASK : CAN_SFF_MASK ); if ( is_eff ) { printf ( \"0x%08X [%d] \" , can_id , out_size ); } else { printf ( \"0x%03X [%d] \" , can_id , out_size ); } for ( i = 0 ; i < out_size ; i ++ ) printf ( \"%02X \" , payload [ i ]); printf ( \" \\r\\n \" ); } } } isotp_destroy_link ( & g_link ); if ( close ( _socket ) < 0 ) { perror ( \"Close\" ); return 1 ; } return 0 ; }","title":"File linux_socket.c"},{"location":"docs/linux__socket_8c_source/#file-linux_socketc","text":"File List > examples > linux_socket > linux_socket.c Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Example implementation of ISO-TP over Linux SocketCAN * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <stdio.h> #include <stdlib.h> #include <stdbool.h> #include <string.h> #include <unistd.h> #include <time.h> #include <stdarg.h> #include <net/if.h> #include <sys/ioctl.h> #include <sys/socket.h> #include <linux/can.h> #include <linux/can/raw.h> #include <isotp.h> /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ #define _CAN_INTERFACE \"slcan0\" #define _ISOTP_BUFSIZE \\ (128) #define _ISOTP_CAN_ID \\ (0x0C1) #define SEC_TO_US(sec) ((sec) * 1000000) /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Static type definitions local to this file */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ static IsoTpLink g_link ; static uint8_t g_isotpRecvBuf [ _ISOTP_BUFSIZE ]; static uint8_t g_isotpSendBuf [ _ISOTP_BUFSIZE ]; static int _socket ; /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ uint32_t isotp_user_get_us ( void ); void isotp_user_debug ( const char * message , ...); int isotp_user_send_can ( const uint32_t arbitration_id , const uint8_t * data , const uint8_t size #ifdef ISO_TP_USER_SEND_CAN_ARG , void * arg #endif ); /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ void isotp_user_debug ( const char * message , ...) { va_list args ; va_start ( args , message ); vfprintf ( stderr , message , args ); va_end ( args ); } int isotp_user_send_can ( const uint32_t arbitration_id , const uint8_t * data , const uint8_t size #ifdef ISO_TP_USER_SEND_CAN_ARG , void * arg #endif ) { int ret = ISOTP_RET_ERROR ; struct can_frame frame ; frame . can_id = arbitration_id | CAN_EFF_FLAG ; frame . can_dlc = size ; memcpy ( frame . data , data , size ); #ifdef ISO_TP_USER_SEND_CAN_ARG ( void ) arg ; #endif ssize_t ret_size = write ( _socket , & frame , sizeof ( struct can_frame )); if ( ret_size == sizeof ( struct can_frame )) { ret = ISOTP_RET_OK ; } return ret ; /* TODO: Check return value */ } uint32_t isotp_user_get_us ( void ) { uint64_t microsecond ; struct timespec ts ; if ( clock_gettime ( CLOCK_MONOTONIC , & ts ) != 0 ) { perror ( \"Failed to obtain monotonic timestamp.\" ); microsecond = UINT64_MAX ; // use this to indicate error } else { // `ts` now contains your timestamp in seconds and microseconds! To // convert the whole struct to microseconds, do this: microsecond = SEC_TO_US (( uint64_t ) ts . tv_sec ) + ( uint64_t ) ( ts . tv_nsec / 1000 ); } return ( uint32_t ) microsecond ; } /* ============================================================================== * PUBLIC FUNCTION IMPLEMENTATIONS * =============================================================================*/ int main ( int argc , char ** argv ) { int i ; int nbytes ; struct sockaddr_can addr ; struct ifreq ifr ; struct can_frame frame ; printf ( \"CAN Sockets Demo \\r\\n \" ); _socket = socket ( PF_CAN , SOCK_RAW , CAN_RAW ); if ( _socket < 0 ) { perror ( \"Socket\" ); return 1 ; } strcpy ( ifr . ifr_name , _CAN_INTERFACE ); ioctl ( _socket , SIOCGIFINDEX , & ifr ); memset ( & addr , 0 , sizeof ( addr )); addr . can_family = AF_CAN ; addr . can_ifindex = ifr . ifr_ifindex ; if ( bind ( _socket , ( struct sockaddr * ) & addr , sizeof ( addr )) < 0 ) { perror ( \"Bind\" ); return 1 ; } /* Init ISOTP lib */ /* Initialize link, ISOTP_CAN_ID is the CAN ID you send with */ isotp_init_link ( & g_link , _ISOTP_CAN_ID , g_isotpSendBuf , sizeof ( g_isotpSendBuf ), g_isotpRecvBuf , sizeof ( g_isotpRecvBuf )); while ( true ) { nbytes = read ( _socket , & frame , sizeof ( struct can_frame )); if ( nbytes < 0 ) { perror ( \"Read\" ); break ; } uint32_t arbitration_id = frame . can_id & CAN_EFF_MASK ; if ( arbitration_id != _ISOTP_CAN_ID ) { continue ; } isotp_on_can_message ( & g_link , frame . data , frame . can_dlc ); isotp_poll ( & g_link ); if ( g_link . receive_status == ISOTP_RECEIVE_STATUS_FULL ) { uint8_t payload [ _ISOTP_BUFSIZE ] = { 0 }; uint32_t out_size = 0 ; int ret = isotp_receive ( & g_link , payload , sizeof ( payload ), & out_size ); if ( ret == ISOTP_RET_OK ) { bool is_eff = ( frame . can_id & CAN_EFF_FLAG ) != 0U ; uint32_t can_id = frame . can_id & ( is_eff ? CAN_EFF_MASK : CAN_SFF_MASK ); if ( is_eff ) { printf ( \"0x%08X [%d] \" , can_id , out_size ); } else { printf ( \"0x%03X [%d] \" , can_id , out_size ); } for ( i = 0 ; i < out_size ; i ++ ) printf ( \"%02X \" , payload [ i ]); printf ( \" \\r\\n \" ); } } } isotp_destroy_link ( & g_link ); if ( close ( _socket ) < 0 ) { perror ( \"Close\" ); return 1 ; } return 0 ; }","title":"File linux_socket.c"},{"location":"docs/dir_181ea403426f4b233011860116dcb1b5/","text":"Dir examples/python_api \u00b6 FileList > examples > python_api Files \u00b6 Type Name file pyisotp.c Directories \u00b6 Type Name dir inc dir src The documentation for this class was generated from the following file examples/python_api/","title":"Dir examples/python_api"},{"location":"docs/dir_181ea403426f4b233011860116dcb1b5/#dir-examplespython_api","text":"FileList > examples > python_api","title":"Dir examples/python_api"},{"location":"docs/dir_181ea403426f4b233011860116dcb1b5/#files","text":"Type Name file pyisotp.c","title":"Files"},{"location":"docs/dir_181ea403426f4b233011860116dcb1b5/#directories","text":"Type Name dir inc dir src The documentation for this class was generated from the following file examples/python_api/","title":"Directories"},{"location":"docs/dir_a048739b84e6d1db49a725d8f1a9c5e6/","text":"Dir examples/python_api/inc \u00b6 FileList > examples > python_api > inc Files \u00b6 Type Name file can_driver.h file mock_can.h file mock_time.h The documentation for this class was generated from the following file examples/python_api/inc/","title":"Dir examples/python_api/inc"},{"location":"docs/dir_a048739b84e6d1db49a725d8f1a9c5e6/#dir-examplespython_apiinc","text":"FileList > examples > python_api > inc","title":"Dir examples/python_api/inc"},{"location":"docs/dir_a048739b84e6d1db49a725d8f1a9c5e6/#files","text":"Type Name file can_driver.h file mock_can.h file mock_time.h The documentation for this class was generated from the following file examples/python_api/inc/","title":"Files"},{"location":"docs/can__driver_8h/","text":"File can_driver.h \u00b6 FileList > examples > python_api > inc > can_driver.h Go to the source code of this file #include <stdint.h> Classes \u00b6 Type Name struct can_driver_t Public Functions \u00b6 Type Name int can_receive (uint32_t * id, uint8_t * data, uint8_t * len) Receives a CAN frame using the active CAN driver. int can_send (uint32_t id, const uint8_t * data, uint8_t len) Sends a CAN frame using the active CAN driver. void can_set_driver (const can_driver_t * driver) Sets the active CAN driver to be used by the ISO-TP implementation. Public Functions Documentation \u00b6 function can_receive \u00b6 Receives a CAN frame using the active CAN driver. int can_receive ( uint32_t * id , uint8_t * data , uint8_t * len ) Parameters: id Pointer to store the received CAN ID. data Pointer to buffer to store the received CAN data. len Pointer to variable to store the length of the received CAN data. Returns: int 0 on success, -1 if the queue is empty or if the driver is not set. function can_send \u00b6 Sends a CAN frame using the active CAN driver. int can_send ( uint32_t id , const uint8_t * data , uint8_t len ) Parameters: id CAN ID to send. data Pointer to the CAN data to send. len Length of the CAN data to send. Returns: int 0 on success, -1 on failure (e.g., if the driver is not set or if send fails). function can_set_driver \u00b6 Sets the active CAN driver to be used by the ISO-TP implementation. void can_set_driver ( const can_driver_t * driver ) Parameters: driver Pointer to the CAN driver to set as active. The documentation for this class was generated from the following file examples/python_api/inc/can_driver.h","title":"File can_driver.h"},{"location":"docs/can__driver_8h/#file-can_driverh","text":"FileList > examples > python_api > inc > can_driver.h Go to the source code of this file #include <stdint.h>","title":"File can_driver.h"},{"location":"docs/can__driver_8h/#classes","text":"Type Name struct can_driver_t","title":"Classes"},{"location":"docs/can__driver_8h/#public-functions","text":"Type Name int can_receive (uint32_t * id, uint8_t * data, uint8_t * len) Receives a CAN frame using the active CAN driver. int can_send (uint32_t id, const uint8_t * data, uint8_t len) Sends a CAN frame using the active CAN driver. void can_set_driver (const can_driver_t * driver) Sets the active CAN driver to be used by the ISO-TP implementation.","title":"Public Functions"},{"location":"docs/can__driver_8h/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/can__driver_8h/#function-can_receive","text":"Receives a CAN frame using the active CAN driver. int can_receive ( uint32_t * id , uint8_t * data , uint8_t * len ) Parameters: id Pointer to store the received CAN ID. data Pointer to buffer to store the received CAN data. len Pointer to variable to store the length of the received CAN data. Returns: int 0 on success, -1 if the queue is empty or if the driver is not set.","title":"function can_receive"},{"location":"docs/can__driver_8h/#function-can_send","text":"Sends a CAN frame using the active CAN driver. int can_send ( uint32_t id , const uint8_t * data , uint8_t len ) Parameters: id CAN ID to send. data Pointer to the CAN data to send. len Length of the CAN data to send. Returns: int 0 on success, -1 on failure (e.g., if the driver is not set or if send fails).","title":"function can_send"},{"location":"docs/can__driver_8h/#function-can_set_driver","text":"Sets the active CAN driver to be used by the ISO-TP implementation. void can_set_driver ( const can_driver_t * driver ) Parameters: driver Pointer to the CAN driver to set as active. The documentation for this class was generated from the following file examples/python_api/inc/can_driver.h","title":"function can_set_driver"},{"location":"docs/can__driver_8h_source/","text":"File can_driver.h \u00b6 File List > examples > python_api > inc > can_driver.h Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: The CAN driver interface definition for the ISO-TP implementation. This header * defines the structure and functions required to interact with a CAN driver. It * allows for abstraction of the CAN communication layer, enabling the use of different * CAN drivers without modifying the ISO-TP implementation. The mock CAN driver * provided in this project implements this interface for testing purposes. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ #ifndef CAN_DRIVER_H #define CAN_DRIVER_H /* ============================================================================== * INCLUDES * =============================================================================*/ #include <stdint.h> #ifdef __cplusplus extern \"C\" { #endif /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Define your macros and constants here */ /* ============================================================================== * TYPE DEFINITIONS * =============================================================================*/ typedef struct { int ( * send )( uint32_t id , const uint8_t * data , uint8_t len ); int ( * receive )( uint32_t * id , uint8_t * data , uint8_t * len ); } can_driver_t ; /* ============================================================================== * GLOBAL VARIABLES (extern declarations) * =============================================================================*/ /* extern declarations for global variables */ /* ============================================================================== * PUBLIC FUNCTION DECLARATIONS * =============================================================================*/ void can_set_driver ( const can_driver_t * driver ); int can_send ( uint32_t id , const uint8_t * data , uint8_t len ); int can_receive ( uint32_t * id , uint8_t * data , uint8_t * len ); #ifdef __cplusplus } #endif #endif /* CAN_DRIVER_H */","title":"File can_driver.h"},{"location":"docs/can__driver_8h_source/#file-can_driverh","text":"File List > examples > python_api > inc > can_driver.h Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: The CAN driver interface definition for the ISO-TP implementation. This header * defines the structure and functions required to interact with a CAN driver. It * allows for abstraction of the CAN communication layer, enabling the use of different * CAN drivers without modifying the ISO-TP implementation. The mock CAN driver * provided in this project implements this interface for testing purposes. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ #ifndef CAN_DRIVER_H #define CAN_DRIVER_H /* ============================================================================== * INCLUDES * =============================================================================*/ #include <stdint.h> #ifdef __cplusplus extern \"C\" { #endif /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Define your macros and constants here */ /* ============================================================================== * TYPE DEFINITIONS * =============================================================================*/ typedef struct { int ( * send )( uint32_t id , const uint8_t * data , uint8_t len ); int ( * receive )( uint32_t * id , uint8_t * data , uint8_t * len ); } can_driver_t ; /* ============================================================================== * GLOBAL VARIABLES (extern declarations) * =============================================================================*/ /* extern declarations for global variables */ /* ============================================================================== * PUBLIC FUNCTION DECLARATIONS * =============================================================================*/ void can_set_driver ( const can_driver_t * driver ); int can_send ( uint32_t id , const uint8_t * data , uint8_t len ); int can_receive ( uint32_t * id , uint8_t * data , uint8_t * len ); #ifdef __cplusplus } #endif #endif /* CAN_DRIVER_H */","title":"File can_driver.h"},{"location":"docs/mock__can_8h/","text":"File mock_can.h \u00b6 FileList > examples > python_api > inc > mock_can.h Go to the source code of this file #include <stdint.h> Public Functions \u00b6 Type Name void mock_can_disable_fc (int enable) Disables sending FlowControl frames in the mock CAN driver. void mock_can_enable_drop (int enable) Enables or disables frame dropping in the mock CAN driver. void mock_can_init (void) Initializes the mock CAN driver and sets it as the active driver. void mock_can_set_delay_ms (int delay) Sets the artificial delay for the mock CAN driver. Public Functions Documentation \u00b6 function mock_can_disable_fc \u00b6 Disables sending FlowControl frames in the mock CAN driver. void mock_can_disable_fc ( int enable ) Parameters: enable - 1 to disable FlowControl frames, 0 to allow them. function mock_can_enable_drop \u00b6 Enables or disables frame dropping in the mock CAN driver. void mock_can_enable_drop ( int enable ) Parameters: enable - 1 to enable frame dropping, 0 to disable. function mock_can_init \u00b6 Initializes the mock CAN driver and sets it as the active driver. void mock_can_init ( void ) function mock_can_set_delay_ms \u00b6 Sets the artificial delay for the mock CAN driver. void mock_can_set_delay_ms ( int delay ) Parameters: delay - Delay in milliseconds. The documentation for this class was generated from the following file examples/python_api/inc/mock_can.h","title":"File mock_can.h"},{"location":"docs/mock__can_8h/#file-mock_canh","text":"FileList > examples > python_api > inc > mock_can.h Go to the source code of this file #include <stdint.h>","title":"File mock_can.h"},{"location":"docs/mock__can_8h/#public-functions","text":"Type Name void mock_can_disable_fc (int enable) Disables sending FlowControl frames in the mock CAN driver. void mock_can_enable_drop (int enable) Enables or disables frame dropping in the mock CAN driver. void mock_can_init (void) Initializes the mock CAN driver and sets it as the active driver. void mock_can_set_delay_ms (int delay) Sets the artificial delay for the mock CAN driver.","title":"Public Functions"},{"location":"docs/mock__can_8h/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/mock__can_8h/#function-mock_can_disable_fc","text":"Disables sending FlowControl frames in the mock CAN driver. void mock_can_disable_fc ( int enable ) Parameters: enable - 1 to disable FlowControl frames, 0 to allow them.","title":"function mock_can_disable_fc"},{"location":"docs/mock__can_8h/#function-mock_can_enable_drop","text":"Enables or disables frame dropping in the mock CAN driver. void mock_can_enable_drop ( int enable ) Parameters: enable - 1 to enable frame dropping, 0 to disable.","title":"function mock_can_enable_drop"},{"location":"docs/mock__can_8h/#function-mock_can_init","text":"Initializes the mock CAN driver and sets it as the active driver. void mock_can_init ( void )","title":"function mock_can_init"},{"location":"docs/mock__can_8h/#function-mock_can_set_delay_ms","text":"Sets the artificial delay for the mock CAN driver. void mock_can_set_delay_ms ( int delay ) Parameters: delay - Delay in milliseconds. The documentation for this class was generated from the following file examples/python_api/inc/mock_can.h","title":"function mock_can_set_delay_ms"},{"location":"docs/mock__can_8h_source/","text":"File mock_can.h \u00b6 File List > examples > python_api > inc > mock_can.h Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: The mock CAN driver implementation for testing purposes. This file provides a simple * in-memory queue to simulate CAN communication, allowing for testing of the ISO-TP * implementation without requiring actual CAN hardware. It supports basic send and * receive operations, as well as optional frame dropping and artificial delays. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ #ifndef MOCK_CAN_H #define MOCK_CAN_H /* ============================================================================== * INCLUDES * =============================================================================*/ #include <stdint.h> #ifdef __cplusplus extern \"C\" { #endif /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Define your macros and constants here */ /* ============================================================================== * TYPE DEFINITIONS * =============================================================================*/ /* Define your types, enums, and structs here */ /* ============================================================================== * GLOBAL VARIABLES (extern declarations) * =============================================================================*/ /* extern declarations for global variables */ /* ============================================================================== * PUBLIC FUNCTION DECLARATIONS * =============================================================================*/ void mock_can_init ( void ); void mock_can_enable_drop ( int enable ); void mock_can_disable_fc ( int enable ); void mock_can_set_delay_ms ( int delay ); #ifdef __cplusplus } #endif #endif /* MOCK_CAN_H */","title":"File mock_can.h"},{"location":"docs/mock__can_8h_source/#file-mock_canh","text":"File List > examples > python_api > inc > mock_can.h Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: The mock CAN driver implementation for testing purposes. This file provides a simple * in-memory queue to simulate CAN communication, allowing for testing of the ISO-TP * implementation without requiring actual CAN hardware. It supports basic send and * receive operations, as well as optional frame dropping and artificial delays. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ #ifndef MOCK_CAN_H #define MOCK_CAN_H /* ============================================================================== * INCLUDES * =============================================================================*/ #include <stdint.h> #ifdef __cplusplus extern \"C\" { #endif /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Define your macros and constants here */ /* ============================================================================== * TYPE DEFINITIONS * =============================================================================*/ /* Define your types, enums, and structs here */ /* ============================================================================== * GLOBAL VARIABLES (extern declarations) * =============================================================================*/ /* extern declarations for global variables */ /* ============================================================================== * PUBLIC FUNCTION DECLARATIONS * =============================================================================*/ void mock_can_init ( void ); void mock_can_enable_drop ( int enable ); void mock_can_disable_fc ( int enable ); void mock_can_set_delay_ms ( int delay ); #ifdef __cplusplus } #endif #endif /* MOCK_CAN_H */","title":"File mock_can.h"},{"location":"docs/mock__time_8h/","text":"File mock_time.h \u00b6 FileList > examples > python_api > inc > mock_time.h Go to the source code of this file #include <stdint.h> Public Functions \u00b6 Type Name void mock_time_advance (uint32_t delta) Advances the virtual time by the specified number of microseconds. uint32_t mock_time_now (void) Returns the current virtual time in microseconds. void mock_time_reset (void) Resets the virtual time to zero. void mock_time_set (uint32_t value) Sets the virtual time to a specific value. Public Functions Documentation \u00b6 function mock_time_advance \u00b6 Advances the virtual time by the specified number of microseconds. void mock_time_advance ( uint32_t delta ) Parameters: delta - Number of microseconds to advance the virtual time. function mock_time_now \u00b6 Returns the current virtual time in microseconds. uint32_t mock_time_now ( void ) Returns: uint32_t Current virtual time in microseconds. function mock_time_reset \u00b6 Resets the virtual time to zero. void mock_time_reset ( void ) function mock_time_set \u00b6 Sets the virtual time to a specific value. void mock_time_set ( uint32_t value ) Parameters: value - The value to set the virtual time to, in microseconds. The documentation for this class was generated from the following file examples/python_api/inc/mock_time.h","title":"File mock_time.h"},{"location":"docs/mock__time_8h/#file-mock_timeh","text":"FileList > examples > python_api > inc > mock_time.h Go to the source code of this file #include <stdint.h>","title":"File mock_time.h"},{"location":"docs/mock__time_8h/#public-functions","text":"Type Name void mock_time_advance (uint32_t delta) Advances the virtual time by the specified number of microseconds. uint32_t mock_time_now (void) Returns the current virtual time in microseconds. void mock_time_reset (void) Resets the virtual time to zero. void mock_time_set (uint32_t value) Sets the virtual time to a specific value.","title":"Public Functions"},{"location":"docs/mock__time_8h/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/mock__time_8h/#function-mock_time_advance","text":"Advances the virtual time by the specified number of microseconds. void mock_time_advance ( uint32_t delta ) Parameters: delta - Number of microseconds to advance the virtual time.","title":"function mock_time_advance"},{"location":"docs/mock__time_8h/#function-mock_time_now","text":"Returns the current virtual time in microseconds. uint32_t mock_time_now ( void ) Returns: uint32_t Current virtual time in microseconds.","title":"function mock_time_now"},{"location":"docs/mock__time_8h/#function-mock_time_reset","text":"Resets the virtual time to zero. void mock_time_reset ( void )","title":"function mock_time_reset"},{"location":"docs/mock__time_8h/#function-mock_time_set","text":"Sets the virtual time to a specific value. void mock_time_set ( uint32_t value ) Parameters: value - The value to set the virtual time to, in microseconds. The documentation for this class was generated from the following file examples/python_api/inc/mock_time.h","title":"function mock_time_set"},{"location":"docs/mock__time_8h_source/","text":"File mock_time.h \u00b6 File List > examples > python_api > inc > mock_time.h Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: File description - briefly describe purpose of this header * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ #ifndef MOCK_TIME_H #define MOCK_TIME_H /* ============================================================================== * INCLUDES * =============================================================================*/ #include <stdint.h> #ifdef __cplusplus extern \"C\" { #endif /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Define your macros and constants here */ /* ============================================================================== * TYPE DEFINITIONS * =============================================================================*/ /* Define your types, enums, and structs here */ /* ============================================================================== * GLOBAL VARIABLES (extern declarations) * =============================================================================*/ /* extern declarations for global variables */ /* ============================================================================== * PUBLIC FUNCTION DECLARATIONS * =============================================================================*/ uint32_t mock_time_now ( void ); void mock_time_advance ( uint32_t delta ); void mock_time_set ( uint32_t value ); void mock_time_reset ( void ); #ifdef __cplusplus } #endif #endif /* MOCK_TIME_H */","title":"File mock_time.h"},{"location":"docs/mock__time_8h_source/#file-mock_timeh","text":"File List > examples > python_api > inc > mock_time.h Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: File description - briefly describe purpose of this header * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ #ifndef MOCK_TIME_H #define MOCK_TIME_H /* ============================================================================== * INCLUDES * =============================================================================*/ #include <stdint.h> #ifdef __cplusplus extern \"C\" { #endif /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Define your macros and constants here */ /* ============================================================================== * TYPE DEFINITIONS * =============================================================================*/ /* Define your types, enums, and structs here */ /* ============================================================================== * GLOBAL VARIABLES (extern declarations) * =============================================================================*/ /* extern declarations for global variables */ /* ============================================================================== * PUBLIC FUNCTION DECLARATIONS * =============================================================================*/ uint32_t mock_time_now ( void ); void mock_time_advance ( uint32_t delta ); void mock_time_set ( uint32_t value ); void mock_time_reset ( void ); #ifdef __cplusplus } #endif #endif /* MOCK_TIME_H */","title":"File mock_time.h"},{"location":"docs/dir_63ad0292e4d57c8e6c47fd30f33819f0/","text":"Dir examples/python_api/src \u00b6 FileList > examples > python_api > src Files \u00b6 Type Name file can_driver.c file isotp_user.c file mock_can.c file mock_time.c The documentation for this class was generated from the following file examples/python_api/src/","title":"Dir examples/python_api/src"},{"location":"docs/dir_63ad0292e4d57c8e6c47fd30f33819f0/#dir-examplespython_apisrc","text":"FileList > examples > python_api > src","title":"Dir examples/python_api/src"},{"location":"docs/dir_63ad0292e4d57c8e6c47fd30f33819f0/#files","text":"Type Name file can_driver.c file isotp_user.c file mock_can.c file mock_time.c The documentation for this class was generated from the following file examples/python_api/src/","title":"Files"},{"location":"docs/can__driver_8c/","text":"File can_driver.c \u00b6 FileList > examples > python_api > src > can_driver.c Go to the source code of this file #include \"can_driver.h\" Public Static Attributes \u00b6 Type Name const can_driver_t * active_driver = 0 Pointer to the currently active CAN driver (set by mock_can_init) Public Functions \u00b6 Type Name int can_receive (uint32_t * id, uint8_t * data, uint8_t * len) Receives a CAN frame using the active CAN driver. int can_send (uint32_t id, const uint8_t * data, uint8_t len) Sends a CAN frame using the active CAN driver. void can_set_driver (const can_driver_t * driver) Sets the active CAN driver to be used by the ISO-TP implementation. Public Static Attributes Documentation \u00b6 variable active_driver \u00b6 Pointer to the currently active CAN driver (set by mock_can_init) const can_driver_t * active_driver ; Public Functions Documentation \u00b6 function can_receive \u00b6 Receives a CAN frame using the active CAN driver. int can_receive ( uint32_t * id , uint8_t * data , uint8_t * len ) Parameters: id Pointer to store the received CAN ID. data Pointer to buffer to store the received CAN data. len Pointer to variable to store the length of the received CAN data. Returns: int 0 on success, -1 if the queue is empty or if the driver is not set. function can_send \u00b6 Sends a CAN frame using the active CAN driver. int can_send ( uint32_t id , const uint8_t * data , uint8_t len ) Parameters: id CAN ID to send. data Pointer to the CAN data to send. len Length of the CAN data to send. Returns: int 0 on success, -1 on failure (e.g., if the driver is not set or if send fails). function can_set_driver \u00b6 Sets the active CAN driver to be used by the ISO-TP implementation. void can_set_driver ( const can_driver_t * driver ) Parameters: driver Pointer to the CAN driver to set as active. The documentation for this class was generated from the following file examples/python_api/src/can_driver.c","title":"File can_driver.c"},{"location":"docs/can__driver_8c/#file-can_driverc","text":"FileList > examples > python_api > src > can_driver.c Go to the source code of this file #include \"can_driver.h\"","title":"File can_driver.c"},{"location":"docs/can__driver_8c/#public-static-attributes","text":"Type Name const can_driver_t * active_driver = 0 Pointer to the currently active CAN driver (set by mock_can_init)","title":"Public Static Attributes"},{"location":"docs/can__driver_8c/#public-functions","text":"Type Name int can_receive (uint32_t * id, uint8_t * data, uint8_t * len) Receives a CAN frame using the active CAN driver. int can_send (uint32_t id, const uint8_t * data, uint8_t len) Sends a CAN frame using the active CAN driver. void can_set_driver (const can_driver_t * driver) Sets the active CAN driver to be used by the ISO-TP implementation.","title":"Public Functions"},{"location":"docs/can__driver_8c/#public-static-attributes-documentation","text":"","title":"Public Static Attributes Documentation"},{"location":"docs/can__driver_8c/#variable-active_driver","text":"Pointer to the currently active CAN driver (set by mock_can_init) const can_driver_t * active_driver ;","title":"variable active_driver"},{"location":"docs/can__driver_8c/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/can__driver_8c/#function-can_receive","text":"Receives a CAN frame using the active CAN driver. int can_receive ( uint32_t * id , uint8_t * data , uint8_t * len ) Parameters: id Pointer to store the received CAN ID. data Pointer to buffer to store the received CAN data. len Pointer to variable to store the length of the received CAN data. Returns: int 0 on success, -1 if the queue is empty or if the driver is not set.","title":"function can_receive"},{"location":"docs/can__driver_8c/#function-can_send","text":"Sends a CAN frame using the active CAN driver. int can_send ( uint32_t id , const uint8_t * data , uint8_t len ) Parameters: id CAN ID to send. data Pointer to the CAN data to send. len Length of the CAN data to send. Returns: int 0 on success, -1 on failure (e.g., if the driver is not set or if send fails).","title":"function can_send"},{"location":"docs/can__driver_8c/#function-can_set_driver","text":"Sets the active CAN driver to be used by the ISO-TP implementation. void can_set_driver ( const can_driver_t * driver ) Parameters: driver Pointer to the CAN driver to set as active. The documentation for this class was generated from the following file examples/python_api/src/can_driver.c","title":"function can_set_driver"},{"location":"docs/can__driver_8c_source/","text":"File can_driver.c \u00b6 File List > examples > python_api > src > can_driver.c Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: The CAN driver interface definition for the ISO-TP implementation. This header * defines the structure and functions required to interact with a CAN driver. It * allows for abstraction of the CAN communication layer, enabling the use of different * CAN drivers without modifying the ISO-TP implementation. The mock CAN driver * provided in this project implements this interface for testing purposes. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include \"can_driver.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Internal macros and constants */ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Static type definitions local to this file */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ // clang-format off static const can_driver_t * active_driver = 0 ; // clang-format on /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* ============================================================================== * PUBLIC FUNCTION IMPLEMENTATIONS * =============================================================================*/ void can_set_driver ( const can_driver_t * driver ) { active_driver = driver ; } int can_send ( uint32_t id , const uint8_t * data , uint8_t len ) { if ( ! active_driver || ! active_driver -> send ) { return -1 ; } return active_driver -> send ( id , data , len ); } int can_receive ( uint32_t * id , uint8_t * data , uint8_t * len ) { if ( ! active_driver || ! active_driver -> receive ) { return -1 ; } return active_driver -> receive ( id , data , len ); }","title":"File can_driver.c"},{"location":"docs/can__driver_8c_source/#file-can_driverc","text":"File List > examples > python_api > src > can_driver.c Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: The CAN driver interface definition for the ISO-TP implementation. This header * defines the structure and functions required to interact with a CAN driver. It * allows for abstraction of the CAN communication layer, enabling the use of different * CAN drivers without modifying the ISO-TP implementation. The mock CAN driver * provided in this project implements this interface for testing purposes. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include \"can_driver.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Internal macros and constants */ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Static type definitions local to this file */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ // clang-format off static const can_driver_t * active_driver = 0 ; // clang-format on /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* ============================================================================== * PUBLIC FUNCTION IMPLEMENTATIONS * =============================================================================*/ void can_set_driver ( const can_driver_t * driver ) { active_driver = driver ; } int can_send ( uint32_t id , const uint8_t * data , uint8_t len ) { if ( ! active_driver || ! active_driver -> send ) { return -1 ; } return active_driver -> send ( id , data , len ); } int can_receive ( uint32_t * id , uint8_t * data , uint8_t * len ) { if ( ! active_driver || ! active_driver -> receive ) { return -1 ; } return active_driver -> receive ( id , data , len ); }","title":"File can_driver.c"},{"location":"docs/isotp__user_8c/","text":"File isotp_user.c \u00b6 FileList > examples > python_api > src > isotp_user.c Go to the source code of this file #include \"isotp.h\" #include \"can_driver.h\" #include \"mock_time.h\" #include <stdarg.h> #include <stdio.h> The documentation for this class was generated from the following file examples/python_api/src/isotp_user.c","title":"File isotp_user.c"},{"location":"docs/isotp__user_8c/#file-isotp_userc","text":"FileList > examples > python_api > src > isotp_user.c Go to the source code of this file #include \"isotp.h\" #include \"can_driver.h\" #include \"mock_time.h\" #include <stdarg.h> #include <stdio.h> The documentation for this class was generated from the following file examples/python_api/src/isotp_user.c","title":"File isotp_user.c"},{"location":"docs/isotp__user_8c_source/","text":"File isotp_user.c \u00b6 File List > examples > python_api > src > isotp_user.c Go to the documentation of this file /* ******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: User hooks for the ISO-TP core used by the Python API example. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================ * INCLUDES * ==========================================================================*/ #include \"isotp.h\" #include \"can_driver.h\" #include \"mock_time.h\" #include <stdarg.h> #include <stdio.h> /* ============================================================================ * PUBLIC FUNCTION IMPLEMENTATIONS * ==========================================================================*/ void isotp_user_debug ( const char * message , ...) { va_list args ; va_start ( args , message ); vfprintf ( stderr , message , args ); va_end ( args ); } int isotp_user_send_can ( const uint32_t arbitration_id , const uint8_t * data , const uint8_t size #ifdef ISO_TP_USER_SEND_CAN_ARG , void * arg #endif ) { #ifdef ISO_TP_USER_SEND_CAN_ARG ( void ) arg ; #endif int ret = can_send ( arbitration_id , data , size ); if ( ret == 0 ) { return ISOTP_RET_OK ; } return ISOTP_RET_NOSPACE ; } uint32_t isotp_user_get_us ( void ) { return mock_time_now (); }","title":"File isotp_user.c"},{"location":"docs/isotp__user_8c_source/#file-isotp_userc","text":"File List > examples > python_api > src > isotp_user.c Go to the documentation of this file /* ******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: User hooks for the ISO-TP core used by the Python API example. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================ * INCLUDES * ==========================================================================*/ #include \"isotp.h\" #include \"can_driver.h\" #include \"mock_time.h\" #include <stdarg.h> #include <stdio.h> /* ============================================================================ * PUBLIC FUNCTION IMPLEMENTATIONS * ==========================================================================*/ void isotp_user_debug ( const char * message , ...) { va_list args ; va_start ( args , message ); vfprintf ( stderr , message , args ); va_end ( args ); } int isotp_user_send_can ( const uint32_t arbitration_id , const uint8_t * data , const uint8_t size #ifdef ISO_TP_USER_SEND_CAN_ARG , void * arg #endif ) { #ifdef ISO_TP_USER_SEND_CAN_ARG ( void ) arg ; #endif int ret = can_send ( arbitration_id , data , size ); if ( ret == 0 ) { return ISOTP_RET_OK ; } return ISOTP_RET_NOSPACE ; } uint32_t isotp_user_get_us ( void ) { return mock_time_now (); }","title":"File isotp_user.c"},{"location":"docs/mock__can_8c/","text":"File mock_can.c \u00b6 FileList > examples > python_api > src > mock_can.c Go to the source code of this file #include \"mock_can.h\" #include \"can_driver.h\" #include <string.h> #include <unistd.h> Classes \u00b6 Type Name struct can_frame_t Structure representing a CAN frame in the mock driver. Public Static Attributes \u00b6 Type Name int delay_ms = 0 Artificial delay in milliseconds for send operations (0 for no delay) int disable_fc = 0 Flag to disable FlowControl frames in the mock driver. int drop_enabled = 0 Flag to enable or disable frame dropping in the mock driver. int head = 0 Index of the head of the queue (next frame to receive) can_frame_t queue Internal queue to hold CAN frames for simulation. int tail = 0 Index of the tail of the queue (next position to send a frame) Public Functions \u00b6 Type Name void mock_can_disable_fc (int enable) Disables sending FlowControl frames in the mock CAN driver. void mock_can_enable_drop (int enable) Enables or disables frame dropping in the mock CAN driver. void mock_can_init (void) Initializes the mock CAN driver and sets it as the active driver. void mock_can_set_delay_ms (int delay) Sets the artificial delay for the mock CAN driver. Public Static Functions \u00b6 Type Name int mock_receive (uint32_t * id, uint8_t * data, uint8_t * len) Mock implementation of CAN receive function. int mock_send (uint32_t id, const uint8_t * data, uint8_t len) Mock implementation of CAN send function. void sleep_ms (int ms) Sleep for a specified number of milliseconds. Macros \u00b6 Type Name define CAN_MAX_DLEN 8 Maximum data length for CAN frames. define MOCK_QUEUE_SIZE 256 Size of the internal queue for simulating CAN frames. Public Static Attributes Documentation \u00b6 variable delay_ms \u00b6 Artificial delay in milliseconds for send operations (0 for no delay) int delay_ms ; variable disable_fc \u00b6 Flag to disable FlowControl frames in the mock driver. int disable_fc ; variable drop_enabled \u00b6 Flag to enable or disable frame dropping in the mock driver. int drop_enabled ; variable head \u00b6 Index of the head of the queue (next frame to receive) int head ; variable queue \u00b6 Internal queue to hold CAN frames for simulation. can_frame_t queue [ MOCK_QUEUE_SIZE ]; variable tail \u00b6 Index of the tail of the queue (next position to send a frame) int tail ; Public Functions Documentation \u00b6 function mock_can_disable_fc \u00b6 Disables sending FlowControl frames in the mock CAN driver. void mock_can_disable_fc ( int enable ) Parameters: enable - 1 to disable FlowControl frames, 0 to allow them. function mock_can_enable_drop \u00b6 Enables or disables frame dropping in the mock CAN driver. void mock_can_enable_drop ( int enable ) Parameters: enable - 1 to enable frame dropping, 0 to disable. function mock_can_init \u00b6 Initializes the mock CAN driver and sets it as the active driver. void mock_can_init ( void ) function mock_can_set_delay_ms \u00b6 Sets the artificial delay for the mock CAN driver. void mock_can_set_delay_ms ( int delay ) Parameters: delay - Delay in milliseconds. Public Static Functions Documentation \u00b6 function mock_receive \u00b6 Mock implementation of CAN receive function. static int mock_receive ( uint32_t * id , uint8_t * data , uint8_t * len ) Parameters: id Pointer to store the received CAN ID. data Pointer to store the received CAN data. len Pointer to store the length of the received CAN data. Returns: int 0 on success, -1 if the queue is empty. function mock_send \u00b6 Mock implementation of CAN send function. static int mock_send ( uint32_t id , const uint8_t * data , uint8_t len ) Parameters: id CAN ID to send. data Pointer to the CAN data to send. len Length of the CAN data to send. Returns: int 0 on success (including when drop is enabled and a frame is discarded), -1 if the queue is full. function sleep_ms \u00b6 Sleep for a specified number of milliseconds. static void sleep_ms ( int ms ) Parameters: ms Number of milliseconds to sleep. Macro Definition Documentation \u00b6 define CAN_MAX_DLEN \u00b6 Maximum data length for CAN frames. #define CAN_MAX_DLEN `8` define MOCK_QUEUE_SIZE \u00b6 Size of the internal queue for simulating CAN frames. #define MOCK_QUEUE_SIZE `256` The documentation for this class was generated from the following file examples/python_api/src/mock_can.c","title":"File mock_can.c"},{"location":"docs/mock__can_8c/#file-mock_canc","text":"FileList > examples > python_api > src > mock_can.c Go to the source code of this file #include \"mock_can.h\" #include \"can_driver.h\" #include <string.h> #include <unistd.h>","title":"File mock_can.c"},{"location":"docs/mock__can_8c/#classes","text":"Type Name struct can_frame_t Structure representing a CAN frame in the mock driver.","title":"Classes"},{"location":"docs/mock__can_8c/#public-static-attributes","text":"Type Name int delay_ms = 0 Artificial delay in milliseconds for send operations (0 for no delay) int disable_fc = 0 Flag to disable FlowControl frames in the mock driver. int drop_enabled = 0 Flag to enable or disable frame dropping in the mock driver. int head = 0 Index of the head of the queue (next frame to receive) can_frame_t queue Internal queue to hold CAN frames for simulation. int tail = 0 Index of the tail of the queue (next position to send a frame)","title":"Public Static Attributes"},{"location":"docs/mock__can_8c/#public-functions","text":"Type Name void mock_can_disable_fc (int enable) Disables sending FlowControl frames in the mock CAN driver. void mock_can_enable_drop (int enable) Enables or disables frame dropping in the mock CAN driver. void mock_can_init (void) Initializes the mock CAN driver and sets it as the active driver. void mock_can_set_delay_ms (int delay) Sets the artificial delay for the mock CAN driver.","title":"Public Functions"},{"location":"docs/mock__can_8c/#public-static-functions","text":"Type Name int mock_receive (uint32_t * id, uint8_t * data, uint8_t * len) Mock implementation of CAN receive function. int mock_send (uint32_t id, const uint8_t * data, uint8_t len) Mock implementation of CAN send function. void sleep_ms (int ms) Sleep for a specified number of milliseconds.","title":"Public Static Functions"},{"location":"docs/mock__can_8c/#macros","text":"Type Name define CAN_MAX_DLEN 8 Maximum data length for CAN frames. define MOCK_QUEUE_SIZE 256 Size of the internal queue for simulating CAN frames.","title":"Macros"},{"location":"docs/mock__can_8c/#public-static-attributes-documentation","text":"","title":"Public Static Attributes Documentation"},{"location":"docs/mock__can_8c/#variable-delay_ms","text":"Artificial delay in milliseconds for send operations (0 for no delay) int delay_ms ;","title":"variable delay_ms"},{"location":"docs/mock__can_8c/#variable-disable_fc","text":"Flag to disable FlowControl frames in the mock driver. int disable_fc ;","title":"variable disable_fc"},{"location":"docs/mock__can_8c/#variable-drop_enabled","text":"Flag to enable or disable frame dropping in the mock driver. int drop_enabled ;","title":"variable drop_enabled"},{"location":"docs/mock__can_8c/#variable-head","text":"Index of the head of the queue (next frame to receive) int head ;","title":"variable head"},{"location":"docs/mock__can_8c/#variable-queue","text":"Internal queue to hold CAN frames for simulation. can_frame_t queue [ MOCK_QUEUE_SIZE ];","title":"variable queue"},{"location":"docs/mock__can_8c/#variable-tail","text":"Index of the tail of the queue (next position to send a frame) int tail ;","title":"variable tail"},{"location":"docs/mock__can_8c/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/mock__can_8c/#function-mock_can_disable_fc","text":"Disables sending FlowControl frames in the mock CAN driver. void mock_can_disable_fc ( int enable ) Parameters: enable - 1 to disable FlowControl frames, 0 to allow them.","title":"function mock_can_disable_fc"},{"location":"docs/mock__can_8c/#function-mock_can_enable_drop","text":"Enables or disables frame dropping in the mock CAN driver. void mock_can_enable_drop ( int enable ) Parameters: enable - 1 to enable frame dropping, 0 to disable.","title":"function mock_can_enable_drop"},{"location":"docs/mock__can_8c/#function-mock_can_init","text":"Initializes the mock CAN driver and sets it as the active driver. void mock_can_init ( void )","title":"function mock_can_init"},{"location":"docs/mock__can_8c/#function-mock_can_set_delay_ms","text":"Sets the artificial delay for the mock CAN driver. void mock_can_set_delay_ms ( int delay ) Parameters: delay - Delay in milliseconds.","title":"function mock_can_set_delay_ms"},{"location":"docs/mock__can_8c/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"docs/mock__can_8c/#function-mock_receive","text":"Mock implementation of CAN receive function. static int mock_receive ( uint32_t * id , uint8_t * data , uint8_t * len ) Parameters: id Pointer to store the received CAN ID. data Pointer to store the received CAN data. len Pointer to store the length of the received CAN data. Returns: int 0 on success, -1 if the queue is empty.","title":"function mock_receive"},{"location":"docs/mock__can_8c/#function-mock_send","text":"Mock implementation of CAN send function. static int mock_send ( uint32_t id , const uint8_t * data , uint8_t len ) Parameters: id CAN ID to send. data Pointer to the CAN data to send. len Length of the CAN data to send. Returns: int 0 on success (including when drop is enabled and a frame is discarded), -1 if the queue is full.","title":"function mock_send"},{"location":"docs/mock__can_8c/#function-sleep_ms","text":"Sleep for a specified number of milliseconds. static void sleep_ms ( int ms ) Parameters: ms Number of milliseconds to sleep.","title":"function sleep_ms"},{"location":"docs/mock__can_8c/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"docs/mock__can_8c/#define-can_max_dlen","text":"Maximum data length for CAN frames. #define CAN_MAX_DLEN `8`","title":"define CAN_MAX_DLEN"},{"location":"docs/mock__can_8c/#define-mock_queue_size","text":"Size of the internal queue for simulating CAN frames. #define MOCK_QUEUE_SIZE `256` The documentation for this class was generated from the following file examples/python_api/src/mock_can.c","title":"define MOCK_QUEUE_SIZE"},{"location":"docs/mock__can_8c_source/","text":"File mock_can.c \u00b6 File List > examples > python_api > src > mock_can.c Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: The mock CAN driver implementation for testing purposes. * This file provides a simple in-memory queue to simulate CAN communication, * allowing for testing of the ISO-TP implementation without requiring actual CAN * hardware. It supports basic send and receive operations, as well as optional frame * dropping and artificial delays. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include \"mock_can.h\" #include \"can_driver.h\" #include <string.h> #ifdef _WIN32 #include <windows.h> #else #include <unistd.h> #endif /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ #define MOCK_QUEUE_SIZE 256 #define CAN_MAX_DLEN 8 /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ typedef struct { uint32_t id ; uint8_t data [ CAN_MAX_DLEN ]; uint8_t len ; } can_frame_t ; /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ static can_frame_t queue [ MOCK_QUEUE_SIZE ]; static int head = 0 ; static int tail = 0 ; static int drop_enabled = 0 ; static int delay_ms = 0 ; static int disable_fc = 0 ; /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ static void sleep_ms ( int ms ); static int mock_receive ( uint32_t * id , uint8_t * data , uint8_t * len ); static int mock_send ( uint32_t id , const uint8_t * data , uint8_t len ); /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ static void sleep_ms ( int ms ) { #ifdef _WIN32 Sleep ( ms ); #else if ( ms > 0 ) { usleep (( unsigned int ) ms * 1000 ); } #endif } static int mock_send ( uint32_t id , const uint8_t * data , uint8_t len ) { if ( drop_enabled ) { return 0 ; // frame dropped } if ( disable_fc && len > 0 ) { uint8_t pci_type = ( uint8_t ) (( data [ 0 ] >> 4 ) & 0x0F ); if ( pci_type == 0x3 ) { return 0 ; // flow control frame dropped } } if (( tail + 1 ) % MOCK_QUEUE_SIZE == head ) { return -1 ; // overflow } if ( delay_ms ) { sleep_ms ( delay_ms ); } queue [ tail ]. id = id ; memcpy ( queue [ tail ]. data , data , len ); queue [ tail ]. len = len ; tail = ( tail + 1 ) % MOCK_QUEUE_SIZE ; return 0 ; } static int mock_receive ( uint32_t * id , uint8_t * data , uint8_t * len ) { if ( head == tail ) { return -1 ; // empty } * id = queue [ head ]. id ; * len = queue [ head ]. len ; memcpy ( data , queue [ head ]. data , * len ); head = ( head + 1 ) % MOCK_QUEUE_SIZE ; return 0 ; } /* ============================================================================== * PUBLIC FUNCTION IMPLEMENTATIONS * =============================================================================*/ void mock_can_init ( void ) { // clang-format off static can_driver_t driver = { . send = mock_send , . receive = mock_receive }; // clang-format on head = tail = 0 ; drop_enabled = 0 ; delay_ms = 0 ; disable_fc = 0 ; can_set_driver ( & driver ); } void mock_can_enable_drop ( int enable ) { drop_enabled = enable ; } void mock_can_disable_fc ( int enable ) { disable_fc = enable ; } void mock_can_set_delay_ms ( int delay ) { delay_ms = delay ; }","title":"File mock_can.c"},{"location":"docs/mock__can_8c_source/#file-mock_canc","text":"File List > examples > python_api > src > mock_can.c Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: The mock CAN driver implementation for testing purposes. * This file provides a simple in-memory queue to simulate CAN communication, * allowing for testing of the ISO-TP implementation without requiring actual CAN * hardware. It supports basic send and receive operations, as well as optional frame * dropping and artificial delays. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include \"mock_can.h\" #include \"can_driver.h\" #include <string.h> #ifdef _WIN32 #include <windows.h> #else #include <unistd.h> #endif /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ #define MOCK_QUEUE_SIZE 256 #define CAN_MAX_DLEN 8 /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ typedef struct { uint32_t id ; uint8_t data [ CAN_MAX_DLEN ]; uint8_t len ; } can_frame_t ; /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ static can_frame_t queue [ MOCK_QUEUE_SIZE ]; static int head = 0 ; static int tail = 0 ; static int drop_enabled = 0 ; static int delay_ms = 0 ; static int disable_fc = 0 ; /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ static void sleep_ms ( int ms ); static int mock_receive ( uint32_t * id , uint8_t * data , uint8_t * len ); static int mock_send ( uint32_t id , const uint8_t * data , uint8_t len ); /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ static void sleep_ms ( int ms ) { #ifdef _WIN32 Sleep ( ms ); #else if ( ms > 0 ) { usleep (( unsigned int ) ms * 1000 ); } #endif } static int mock_send ( uint32_t id , const uint8_t * data , uint8_t len ) { if ( drop_enabled ) { return 0 ; // frame dropped } if ( disable_fc && len > 0 ) { uint8_t pci_type = ( uint8_t ) (( data [ 0 ] >> 4 ) & 0x0F ); if ( pci_type == 0x3 ) { return 0 ; // flow control frame dropped } } if (( tail + 1 ) % MOCK_QUEUE_SIZE == head ) { return -1 ; // overflow } if ( delay_ms ) { sleep_ms ( delay_ms ); } queue [ tail ]. id = id ; memcpy ( queue [ tail ]. data , data , len ); queue [ tail ]. len = len ; tail = ( tail + 1 ) % MOCK_QUEUE_SIZE ; return 0 ; } static int mock_receive ( uint32_t * id , uint8_t * data , uint8_t * len ) { if ( head == tail ) { return -1 ; // empty } * id = queue [ head ]. id ; * len = queue [ head ]. len ; memcpy ( data , queue [ head ]. data , * len ); head = ( head + 1 ) % MOCK_QUEUE_SIZE ; return 0 ; } /* ============================================================================== * PUBLIC FUNCTION IMPLEMENTATIONS * =============================================================================*/ void mock_can_init ( void ) { // clang-format off static can_driver_t driver = { . send = mock_send , . receive = mock_receive }; // clang-format on head = tail = 0 ; drop_enabled = 0 ; delay_ms = 0 ; disable_fc = 0 ; can_set_driver ( & driver ); } void mock_can_enable_drop ( int enable ) { drop_enabled = enable ; } void mock_can_disable_fc ( int enable ) { disable_fc = enable ; } void mock_can_set_delay_ms ( int delay ) { delay_ms = delay ; }","title":"File mock_can.c"},{"location":"docs/mock__time_8c/","text":"File mock_time.c \u00b6 FileList > examples > python_api > src > mock_time.c Go to the source code of this file #include \"mock_time.h\" Public Static Attributes \u00b6 Type Name uint32_t virtual_time = 0 Public Functions \u00b6 Type Name void mock_time_advance (uint32_t delta) Advances the virtual time by the specified number of microseconds. uint32_t mock_time_now (void) Returns the current virtual time in microseconds. void mock_time_reset (void) Resets the virtual time to zero. void mock_time_set (uint32_t value) Sets the virtual time to a specific value. Public Static Attributes Documentation \u00b6 variable virtual_time \u00b6 uint32_t virtual_time ; Public Functions Documentation \u00b6 function mock_time_advance \u00b6 Advances the virtual time by the specified number of microseconds. void mock_time_advance ( uint32_t delta ) Parameters: delta - Number of microseconds to advance the virtual time. function mock_time_now \u00b6 Returns the current virtual time in microseconds. uint32_t mock_time_now ( void ) Returns: uint32_t Current virtual time in microseconds. function mock_time_reset \u00b6 Resets the virtual time to zero. void mock_time_reset ( void ) function mock_time_set \u00b6 Sets the virtual time to a specific value. void mock_time_set ( uint32_t value ) Parameters: value - The value to set the virtual time to, in microseconds. The documentation for this class was generated from the following file examples/python_api/src/mock_time.c","title":"File mock_time.c"},{"location":"docs/mock__time_8c/#file-mock_timec","text":"FileList > examples > python_api > src > mock_time.c Go to the source code of this file #include \"mock_time.h\"","title":"File mock_time.c"},{"location":"docs/mock__time_8c/#public-static-attributes","text":"Type Name uint32_t virtual_time = 0","title":"Public Static Attributes"},{"location":"docs/mock__time_8c/#public-functions","text":"Type Name void mock_time_advance (uint32_t delta) Advances the virtual time by the specified number of microseconds. uint32_t mock_time_now (void) Returns the current virtual time in microseconds. void mock_time_reset (void) Resets the virtual time to zero. void mock_time_set (uint32_t value) Sets the virtual time to a specific value.","title":"Public Functions"},{"location":"docs/mock__time_8c/#public-static-attributes-documentation","text":"","title":"Public Static Attributes Documentation"},{"location":"docs/mock__time_8c/#variable-virtual_time","text":"uint32_t virtual_time ;","title":"variable virtual_time"},{"location":"docs/mock__time_8c/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/mock__time_8c/#function-mock_time_advance","text":"Advances the virtual time by the specified number of microseconds. void mock_time_advance ( uint32_t delta ) Parameters: delta - Number of microseconds to advance the virtual time.","title":"function mock_time_advance"},{"location":"docs/mock__time_8c/#function-mock_time_now","text":"Returns the current virtual time in microseconds. uint32_t mock_time_now ( void ) Returns: uint32_t Current virtual time in microseconds.","title":"function mock_time_now"},{"location":"docs/mock__time_8c/#function-mock_time_reset","text":"Resets the virtual time to zero. void mock_time_reset ( void )","title":"function mock_time_reset"},{"location":"docs/mock__time_8c/#function-mock_time_set","text":"Sets the virtual time to a specific value. void mock_time_set ( uint32_t value ) Parameters: value - The value to set the virtual time to, in microseconds. The documentation for this class was generated from the following file examples/python_api/src/mock_time.c","title":"function mock_time_set"},{"location":"docs/mock__time_8c_source/","text":"File mock_time.c \u00b6 File List > examples > python_api > src > mock_time.c Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: File description - briefly describe purpose of this source file * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include \"mock_time.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Internal macros and constants */ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Static type definitions local to this file */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ static uint32_t virtual_time = 0 ; // microseconds /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* ============================================================================== * PUBLIC FUNCTION IMPLEMENTATIONS * =============================================================================*/ uint32_t mock_time_now ( void ) { return virtual_time ; } void mock_time_advance ( uint32_t delta ) { virtual_time += delta ; } void mock_time_set ( uint32_t value ) { virtual_time = value ; } void mock_time_reset ( void ) { virtual_time = 0 ; }","title":"File mock_time.c"},{"location":"docs/mock__time_8c_source/#file-mock_timec","text":"File List > examples > python_api > src > mock_time.c Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: File description - briefly describe purpose of this source file * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include \"mock_time.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Internal macros and constants */ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Static type definitions local to this file */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ static uint32_t virtual_time = 0 ; // microseconds /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* ============================================================================== * PUBLIC FUNCTION IMPLEMENTATIONS * =============================================================================*/ uint32_t mock_time_now ( void ) { return virtual_time ; } void mock_time_advance ( uint32_t delta ) { virtual_time += delta ; } void mock_time_set ( uint32_t value ) { virtual_time = value ; } void mock_time_reset ( void ) { virtual_time = 0 ; }","title":"File mock_time.c"},{"location":"docs/pyisotp_8c/","text":"File pyisotp.c \u00b6 FileList > examples > python_api > pyisotp.c Go to the source code of this file #include <Python.h> #include \"isotp.h\" #include \"can_driver.h\" #include \"mock_can.h\" #include \"mock_time.h\" Public Static Attributes \u00b6 Type Name PyMethodDef PyIsoTpMethods = /* multi line expression */ struct PyModuleDef pyisotp_module = /* multi line expression */ Public Functions \u00b6 Type Name PyMODINIT_FUNC PyInit_pyisotp (void) Public Static Functions \u00b6 Type Name PyObject * py_get_last_protocol_result (PyObject * self, PyObject * args) Returns the last protocol result for the sender side. PyObject * py_get_last_receive_protocol_result (PyObject * self, PyObject * args) Returns the last protocol result for the receiver side. PyObject * py_inject_can (PyObject * self, PyObject * args) Injects a raw CAN frame into the ISO-TP link for testing purposes. PyObject * py_mock_disable_fc (PyObject * self, PyObject * args) Enables or disables FlowControl frames in the mock CAN driver. PyObject * py_mock_enable_drop (PyObject * self, PyObject * args) Enables or disables CAN frame dropping in the mock CAN driver. PyObject * py_set_fc_params (PyObject * self, PyObject * args) Sets the FlowControl parameters for the ISO-TP link. PyObject * py_set_timeouts (PyObject * self, PyObject * args) Sets the timeouts for the ISO-TP link. PyObject * py_time_advance (PyObject * self, PyObject * args) Advances the virtual time in the mock time implementation by a specified delta. PyObject * py_time_reset (PyObject * self, PyObject * args) Resets the virtual time in the mock time implementation to zero. PyObject * py_time_set (PyObject * self, PyObject * args) Sets the virtual time in the mock time implementation to a specific value. void pyisotp_capsule_destructor (PyObject * capsule) Releases an ISO-TP link capsule and its allocated buffers. PyObject * pyisotp_init (PyObject * self, PyObject * args) Initializes an ISO-TP link and returns a capsule containing the link pointer to Python. PyObject * pyisotp_poll (PyObject * self, PyObject * args) Polls an ISO-TP link for timeouts and state updates. PyObject * pyisotp_receive (PyObject * self, PyObject * args) Receives data from an ISO-TP link. PyObject * pyisotp_send (PyObject * self, PyObject * args) Sends data over an ISO-TP link. Macros \u00b6 Type Name define PY_SSIZE_T_CLEAN Public Static Attributes Documentation \u00b6 variable PyIsoTpMethods \u00b6 PyMethodDef PyIsoTpMethods []; variable pyisotp_module \u00b6 struct PyModuleDef pyisotp_module ; Public Functions Documentation \u00b6 function PyInit_pyisotp \u00b6 PyMODINIT_FUNC PyInit_pyisotp ( void ) Public Static Functions Documentation \u00b6 function py_get_last_protocol_result \u00b6 Returns the last protocol result for the sender side. static PyObject * py_get_last_protocol_result ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python (expected to be empty for this function) Returns: PyObject* - Python object representing the result of the operation, typically an integer status code function py_get_last_receive_protocol_result \u00b6 Returns the last protocol result for the receiver side. static PyObject * py_get_last_receive_protocol_result ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python (expected to be empty for this function) Returns: PyObject* - Python object representing the result of the operation, typically an integer status code function py_inject_can \u00b6 Injects a raw CAN frame into the ISO-TP link for testing purposes. static PyObject * py_inject_can ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: py_link (PyObject*): Capsule containing the IsoTpLink pointer data (bytes): Raw CAN frame data to inject (must be 2..8 bytes) Returns: PyObject* - Python object representing the result of the operation, typically None function py_mock_disable_fc \u00b6 Enables or disables FlowControl frames in the mock CAN driver. static PyObject * py_mock_disable_fc ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: enable (int): Flag to enable or disable FlowControl frames Returns: PyObject* - Python object representing the result of the operation, typically None function py_mock_enable_drop \u00b6 Enables or disables CAN frame dropping in the mock CAN driver. static PyObject * py_mock_enable_drop ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: enable (int): Flag to enable or disable CAN frame dropping Returns: PyObject* - Python object representing the result of the operation, typically None function py_set_fc_params \u00b6 Sets the FlowControl parameters for the ISO-TP link. static PyObject * py_set_fc_params ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: py_link (PyObject*): Capsule containing the IsoTpLink pointer block_size (uint32_t): Block size for FlowControl (0 means unlimited) st_min_ms (uint32_t): STmin in milliseconds Returns: PyObject* - Python object representing the result of the operation, typically None function py_set_timeouts \u00b6 Sets the timeouts for the ISO-TP link. static PyObject * py_set_timeouts ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: py_link (PyObject*): Capsule containing the IsoTpLink pointer n_bs_ms (uint32_t): N_Bs timeout in milliseconds n_cr_ms (uint32_t): N_Cr timeout in milliseconds Returns: PyObject* - Python object representing the result of the operation, typically None function py_time_advance \u00b6 Advances the virtual time in the mock time implementation by a specified delta. static PyObject * py_time_advance ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: delta (uint32_t): The number of milliseconds to advance the virtual time Returns: PyObject* - Python object representing the result of the operation, typically None function py_time_reset \u00b6 Resets the virtual time in the mock time implementation to zero. static PyObject * py_time_reset ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python (expected to be empty for this function) Returns: PyObject* - Python object representing the result of the operation, typically None function py_time_set \u00b6 Sets the virtual time in the mock time implementation to a specific value. static PyObject * py_time_set ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: value (uint32_t): The value to set the virtual time to, in milliseconds Returns: PyObject* - Python object representing the result of the operation, typically None function pyisotp_capsule_destructor \u00b6 Releases an ISO-TP link capsule and its allocated buffers. static void pyisotp_capsule_destructor ( PyObject * capsule ) function pyisotp_init \u00b6 Initializes an ISO-TP link and returns a capsule containing the link pointer to Python. static PyObject * pyisotp_init ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: sendid (uint32_t): CAN ID to send on Returns: PyObject* - Python object representing the result of the operation, typically a capsule containing the IsoTpLink pointer or an error indicator function pyisotp_poll \u00b6 Polls an ISO-TP link for timeouts and state updates. static PyObject * pyisotp_poll ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: py_link (PyObject*): Capsule containing the IsoTpLink pointer Returns: PyObject* - Python object representing the result of the operation, typically None function pyisotp_receive \u00b6 Receives data from an ISO-TP link. static PyObject * pyisotp_receive ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: py_link (PyObject*): Capsule containing the IsoTpLink pointer bufsize (Py_ssize_t): Size of the buffer to receive data into Returns: PyObject* - Python object representing the result of the operation, typically bytes containing received data or None if no data function pyisotp_send \u00b6 Sends data over an ISO-TP link. static PyObject * pyisotp_send ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: py_link (PyObject*): Capsule containing the IsoTpLink pointer data (bytes): Data to send Returns: PyObject* - Python object representing the result of the operation, typically an integer status code Macro Definition Documentation \u00b6 define PY_SSIZE_T_CLEAN \u00b6 #define PY_SSIZE_T_CLEAN The documentation for this class was generated from the following file examples/python_api/pyisotp.c","title":"File pyisotp.c"},{"location":"docs/pyisotp_8c/#file-pyisotpc","text":"FileList > examples > python_api > pyisotp.c Go to the source code of this file #include <Python.h> #include \"isotp.h\" #include \"can_driver.h\" #include \"mock_can.h\" #include \"mock_time.h\"","title":"File pyisotp.c"},{"location":"docs/pyisotp_8c/#public-static-attributes","text":"Type Name PyMethodDef PyIsoTpMethods = /* multi line expression */ struct PyModuleDef pyisotp_module = /* multi line expression */","title":"Public Static Attributes"},{"location":"docs/pyisotp_8c/#public-functions","text":"Type Name PyMODINIT_FUNC PyInit_pyisotp (void)","title":"Public Functions"},{"location":"docs/pyisotp_8c/#public-static-functions","text":"Type Name PyObject * py_get_last_protocol_result (PyObject * self, PyObject * args) Returns the last protocol result for the sender side. PyObject * py_get_last_receive_protocol_result (PyObject * self, PyObject * args) Returns the last protocol result for the receiver side. PyObject * py_inject_can (PyObject * self, PyObject * args) Injects a raw CAN frame into the ISO-TP link for testing purposes. PyObject * py_mock_disable_fc (PyObject * self, PyObject * args) Enables or disables FlowControl frames in the mock CAN driver. PyObject * py_mock_enable_drop (PyObject * self, PyObject * args) Enables or disables CAN frame dropping in the mock CAN driver. PyObject * py_set_fc_params (PyObject * self, PyObject * args) Sets the FlowControl parameters for the ISO-TP link. PyObject * py_set_timeouts (PyObject * self, PyObject * args) Sets the timeouts for the ISO-TP link. PyObject * py_time_advance (PyObject * self, PyObject * args) Advances the virtual time in the mock time implementation by a specified delta. PyObject * py_time_reset (PyObject * self, PyObject * args) Resets the virtual time in the mock time implementation to zero. PyObject * py_time_set (PyObject * self, PyObject * args) Sets the virtual time in the mock time implementation to a specific value. void pyisotp_capsule_destructor (PyObject * capsule) Releases an ISO-TP link capsule and its allocated buffers. PyObject * pyisotp_init (PyObject * self, PyObject * args) Initializes an ISO-TP link and returns a capsule containing the link pointer to Python. PyObject * pyisotp_poll (PyObject * self, PyObject * args) Polls an ISO-TP link for timeouts and state updates. PyObject * pyisotp_receive (PyObject * self, PyObject * args) Receives data from an ISO-TP link. PyObject * pyisotp_send (PyObject * self, PyObject * args) Sends data over an ISO-TP link.","title":"Public Static Functions"},{"location":"docs/pyisotp_8c/#macros","text":"Type Name define PY_SSIZE_T_CLEAN","title":"Macros"},{"location":"docs/pyisotp_8c/#public-static-attributes-documentation","text":"","title":"Public Static Attributes Documentation"},{"location":"docs/pyisotp_8c/#variable-pyisotpmethods","text":"PyMethodDef PyIsoTpMethods [];","title":"variable PyIsoTpMethods"},{"location":"docs/pyisotp_8c/#variable-pyisotp_module","text":"struct PyModuleDef pyisotp_module ;","title":"variable pyisotp_module"},{"location":"docs/pyisotp_8c/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/pyisotp_8c/#function-pyinit_pyisotp","text":"PyMODINIT_FUNC PyInit_pyisotp ( void )","title":"function PyInit_pyisotp"},{"location":"docs/pyisotp_8c/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"docs/pyisotp_8c/#function-py_get_last_protocol_result","text":"Returns the last protocol result for the sender side. static PyObject * py_get_last_protocol_result ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python (expected to be empty for this function) Returns: PyObject* - Python object representing the result of the operation, typically an integer status code","title":"function py_get_last_protocol_result"},{"location":"docs/pyisotp_8c/#function-py_get_last_receive_protocol_result","text":"Returns the last protocol result for the receiver side. static PyObject * py_get_last_receive_protocol_result ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python (expected to be empty for this function) Returns: PyObject* - Python object representing the result of the operation, typically an integer status code","title":"function py_get_last_receive_protocol_result"},{"location":"docs/pyisotp_8c/#function-py_inject_can","text":"Injects a raw CAN frame into the ISO-TP link for testing purposes. static PyObject * py_inject_can ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: py_link (PyObject*): Capsule containing the IsoTpLink pointer data (bytes): Raw CAN frame data to inject (must be 2..8 bytes) Returns: PyObject* - Python object representing the result of the operation, typically None","title":"function py_inject_can"},{"location":"docs/pyisotp_8c/#function-py_mock_disable_fc","text":"Enables or disables FlowControl frames in the mock CAN driver. static PyObject * py_mock_disable_fc ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: enable (int): Flag to enable or disable FlowControl frames Returns: PyObject* - Python object representing the result of the operation, typically None","title":"function py_mock_disable_fc"},{"location":"docs/pyisotp_8c/#function-py_mock_enable_drop","text":"Enables or disables CAN frame dropping in the mock CAN driver. static PyObject * py_mock_enable_drop ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: enable (int): Flag to enable or disable CAN frame dropping Returns: PyObject* - Python object representing the result of the operation, typically None","title":"function py_mock_enable_drop"},{"location":"docs/pyisotp_8c/#function-py_set_fc_params","text":"Sets the FlowControl parameters for the ISO-TP link. static PyObject * py_set_fc_params ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: py_link (PyObject*): Capsule containing the IsoTpLink pointer block_size (uint32_t): Block size for FlowControl (0 means unlimited) st_min_ms (uint32_t): STmin in milliseconds Returns: PyObject* - Python object representing the result of the operation, typically None","title":"function py_set_fc_params"},{"location":"docs/pyisotp_8c/#function-py_set_timeouts","text":"Sets the timeouts for the ISO-TP link. static PyObject * py_set_timeouts ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: py_link (PyObject*): Capsule containing the IsoTpLink pointer n_bs_ms (uint32_t): N_Bs timeout in milliseconds n_cr_ms (uint32_t): N_Cr timeout in milliseconds Returns: PyObject* - Python object representing the result of the operation, typically None","title":"function py_set_timeouts"},{"location":"docs/pyisotp_8c/#function-py_time_advance","text":"Advances the virtual time in the mock time implementation by a specified delta. static PyObject * py_time_advance ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: delta (uint32_t): The number of milliseconds to advance the virtual time Returns: PyObject* - Python object representing the result of the operation, typically None","title":"function py_time_advance"},{"location":"docs/pyisotp_8c/#function-py_time_reset","text":"Resets the virtual time in the mock time implementation to zero. static PyObject * py_time_reset ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python (expected to be empty for this function) Returns: PyObject* - Python object representing the result of the operation, typically None","title":"function py_time_reset"},{"location":"docs/pyisotp_8c/#function-py_time_set","text":"Sets the virtual time in the mock time implementation to a specific value. static PyObject * py_time_set ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: value (uint32_t): The value to set the virtual time to, in milliseconds Returns: PyObject* - Python object representing the result of the operation, typically None","title":"function py_time_set"},{"location":"docs/pyisotp_8c/#function-pyisotp_capsule_destructor","text":"Releases an ISO-TP link capsule and its allocated buffers. static void pyisotp_capsule_destructor ( PyObject * capsule )","title":"function pyisotp_capsule_destructor"},{"location":"docs/pyisotp_8c/#function-pyisotp_init","text":"Initializes an ISO-TP link and returns a capsule containing the link pointer to Python. static PyObject * pyisotp_init ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: sendid (uint32_t): CAN ID to send on Returns: PyObject* - Python object representing the result of the operation, typically a capsule containing the IsoTpLink pointer or an error indicator","title":"function pyisotp_init"},{"location":"docs/pyisotp_8c/#function-pyisotp_poll","text":"Polls an ISO-TP link for timeouts and state updates. static PyObject * pyisotp_poll ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: py_link (PyObject*): Capsule containing the IsoTpLink pointer Returns: PyObject* - Python object representing the result of the operation, typically None","title":"function pyisotp_poll"},{"location":"docs/pyisotp_8c/#function-pyisotp_receive","text":"Receives data from an ISO-TP link. static PyObject * pyisotp_receive ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: py_link (PyObject*): Capsule containing the IsoTpLink pointer bufsize (Py_ssize_t): Size of the buffer to receive data into Returns: PyObject* - Python object representing the result of the operation, typically bytes containing received data or None if no data","title":"function pyisotp_receive"},{"location":"docs/pyisotp_8c/#function-pyisotp_send","text":"Sends data over an ISO-TP link. static PyObject * pyisotp_send ( PyObject * self , PyObject * args ) Parameters: self - Pointer to the module object (unused in this context) args - Tuple of arguments passed from Python, expected to contain: py_link (PyObject*): Capsule containing the IsoTpLink pointer data (bytes): Data to send Returns: PyObject* - Python object representing the result of the operation, typically an integer status code","title":"function pyisotp_send"},{"location":"docs/pyisotp_8c/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"docs/pyisotp_8c/#define-py_ssize_t_clean","text":"#define PY_SSIZE_T_CLEAN The documentation for this class was generated from the following file examples/python_api/pyisotp.c","title":"define PY_SSIZE_T_CLEAN"},{"location":"docs/pyisotp_8c_source/","text":"File pyisotp.c \u00b6 File List > examples > python_api > pyisotp.c Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: File description - briefly describe purpose of this source file * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ #define PY_SSIZE_T_CLEAN /* ============================================================================== * INCLUDES * =============================================================================*/ #include <Python.h> #include \"isotp.h\" #include \"can_driver.h\" #include \"mock_can.h\" #include \"mock_time.h\" /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Static type definitions local to this file */ /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ static PyObject * pyisotp_init ( PyObject * self , PyObject * args ); static PyObject * pyisotp_send ( PyObject * self , PyObject * args ); static PyObject * pyisotp_poll ( PyObject * self , PyObject * args ); static PyObject * pyisotp_receive ( PyObject * self , PyObject * args ); static PyObject * py_mock_enable_drop ( PyObject * self , PyObject * args ); static PyObject * py_mock_disable_fc ( PyObject * self , PyObject * args ); static PyObject * py_get_last_protocol_result ( PyObject * self , PyObject * args ); static PyObject * py_get_last_receive_protocol_result ( PyObject * self , PyObject * args ); static PyObject * py_set_timeouts ( PyObject * self , PyObject * args ); static PyObject * py_set_fc_params ( PyObject * self , PyObject * args ); static PyObject * py_inject_can ( PyObject * self , PyObject * args ); static PyObject * py_time_advance ( PyObject * self , PyObject * args ); static PyObject * py_time_set ( PyObject * self , PyObject * args ); static PyObject * py_time_reset ( PyObject * self , PyObject * args ); static void pyisotp_capsule_destructor ( PyObject * capsule ); /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ // clang-format off static PyMethodDef PyIsoTpMethods [] = { { \"init\" , pyisotp_init , METH_VARARGS , \"Initialize ISO-TP link\" }, { \"send\" , pyisotp_send , METH_VARARGS , \"Send data over ISO-TP\" }, { \"poll\" , pyisotp_poll , METH_VARARGS , \"Poll ISO-TP link for timeouts and state updates\" }, { \"receive\" , pyisotp_receive , METH_VARARGS , \"Receive data from ISO-TP link\" }, { \"mock_enable_drop\" , py_mock_enable_drop , METH_VARARGS , \"Enable or disable CAN frame dropping in the mock CAN driver\" }, { \"mock_disable_fc\" , py_mock_disable_fc , METH_VARARGS , \"Enable or disable FlowControl frames in the mock CAN driver\" }, { \"time_advance\" , py_time_advance , METH_VARARGS , \"Advance virtual time in the mock time implementation\" }, { \"time_set\" , py_time_set , METH_VARARGS , \"Set virtual time in the mock time implementation to a specific value\" }, { \"time_reset\" , py_time_reset , METH_VARARGS , \"Reset virtual time in the mock time implementation to zero\" }, { \"get_last_protocol_result\" , py_get_last_protocol_result , METH_VARARGS , \"Get last sender protocol result\" }, { \"get_last_receive_protocol_result\" , py_get_last_receive_protocol_result , METH_VARARGS , \"Get last receiver protocol result\" }, { \"set_timeouts\" , py_set_timeouts , METH_VARARGS , \"Set N_Bs and N_Cr timeouts in milliseconds\" }, { \"set_fc_params\" , py_set_fc_params , METH_VARARGS , \"Set FlowControl block size and STmin in milliseconds\" }, { \"inject_can\" , py_inject_can , METH_VARARGS , \"Inject raw CAN frame into the ISO-TP link\" }, { NULL , NULL , 0 , NULL } // Sentinel }; static struct PyModuleDef pyisotp_module = { PyModuleDef_HEAD_INIT , \"pyisotp\" , \"Python bindings for ISO-TP-C library\" , -1 , PyIsoTpMethods }; // clang-format on /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ static PyObject * pyisotp_init ( PyObject * self , PyObject * args ) { uint32_t sendid = 0 ; Py_ssize_t sbufsz = { 0 }; Py_ssize_t rbufsz = { 0 }; if ( PyArg_ParseTuple ( args , \"Inn\" , & sendid , & sbufsz , & rbufsz )) { if (( sbufsz <= 0 ) || ( rbufsz <= 0 ) || ( sbufsz > UINT32_MAX ) || ( rbufsz > UINT32_MAX )) { PyErr_SetString ( PyExc_ValueError , \"sbufsz/rbufsz must be > 0 and <= UINT32_MAX\" ); return NULL ; } mock_can_init (); mock_time_reset (); IsoTpLink * link = PyMem_Malloc ( sizeof ( IsoTpLink )); uint8_t * sbuf = PyMem_Malloc ( sbufsz ); uint8_t * rbuf = PyMem_Malloc ( rbufsz ); if (( link == NULL ) || ( sbuf == NULL ) || ( rbuf == NULL )) { PyMem_Free ( link ); PyMem_Free ( sbuf ); PyMem_Free ( rbuf ); return PyErr_NoMemory (); } isotp_init_link ( link , sendid , sbuf , ( uint32_t ) sbufsz , rbuf , ( uint32_t ) rbufsz ); PyObject * capsule = PyCapsule_New ( link , \"IsoTpLink\" , pyisotp_capsule_destructor ); if ( capsule == NULL ) { isotp_destroy_link ( link ); PyMem_Free ( sbuf ); PyMem_Free ( rbuf ); PyMem_Free ( link ); return NULL ; } return capsule ; } return NULL ; } static PyObject * pyisotp_send ( PyObject * self , PyObject * args ) { PyObject * py_link = NULL ; const char * data = NULL ; Py_ssize_t len = { 0 }; if ( PyArg_ParseTuple ( args , \"Oy#\" , & py_link , & data , & len )) { IsoTpLink * link = PyCapsule_GetPointer ( py_link , \"IsoTpLink\" ); if ( link != NULL ) { if ( len > ( Py_ssize_t ) link -> send_buf_size ) { return PyLong_FromLong ( ISOTP_RET_OVERFLOW ); } int res = isotp_send ( link , ( const uint8_t * ) data , ( uint32_t ) len ); return PyLong_FromLong ( res ); } } return NULL ; } static PyObject * pyisotp_poll ( PyObject * self , PyObject * args ) { PyObject * py_link = NULL ; if ( PyArg_ParseTuple ( args , \"O\" , & py_link )) { IsoTpLink * link = PyCapsule_GetPointer ( py_link , \"IsoTpLink\" ); if ( link != NULL ) { isotp_poll ( link ); uint32_t id = 0 ; uint8_t len = 0 ; uint8_t data [ 8 ] = { 0 }; while ( can_receive ( & id , data , & len ) == 0 ) { isotp_on_can_message ( link , data , len ); } Py_RETURN_NONE ; } } return NULL ; } static PyObject * pyisotp_receive ( PyObject * self , PyObject * args ) { PyObject * py_link = NULL ; Py_ssize_t bufsize = { 0 }; if ( PyArg_ParseTuple ( args , \"On\" , & py_link , & bufsize )) { if ( bufsize <= 0 || bufsize > UINT32_MAX ) { PyErr_SetString ( PyExc_ValueError , \"bufsize must be > 0 and <= UINT32_MAX\" ); return NULL ; } IsoTpLink * link = PyCapsule_GetPointer ( py_link , \"IsoTpLink\" ); if ( link != NULL ) { uint8_t * buf = PyMem_Malloc ( bufsize ); if ( buf == NULL ) { return PyErr_NoMemory (); } uint32_t outsz = 0 ; int ret = isotp_receive ( link , buf , ( uint32_t ) bufsize , & outsz ); if ( ret == ISOTP_RET_OK ) { if ( outsz > ( uint32_t ) PY_SSIZE_T_MAX ) { PyMem_Free ( buf ); PyErr_SetString ( PyExc_OverflowError , \"received size exceeds Python maximum size\" ); return NULL ; } PyObject * result = Py_BuildValue ( \"y#\" , buf , ( Py_ssize_t ) outsz ); PyMem_Free ( buf ); return result ; } PyMem_Free ( buf ); Py_RETURN_NONE ; } } return NULL ; } static PyObject * py_mock_enable_drop ( PyObject * self , PyObject * args ) { int enable = 0 ; if ( PyArg_ParseTuple ( args , \"p\" , & enable )) { mock_can_enable_drop ( enable ); Py_RETURN_NONE ; } return NULL ; } static PyObject * py_mock_disable_fc ( PyObject * self , PyObject * args ) { int enable = 0 ; if ( PyArg_ParseTuple ( args , \"p\" , & enable )) { mock_can_disable_fc ( enable ); Py_RETURN_NONE ; } return NULL ; } static PyObject * py_time_advance ( PyObject * self , PyObject * args ) { uint32_t delta_ms = 0 ; if ( PyArg_ParseTuple ( args , \"I\" , & delta_ms )) { if ( delta_ms > ( UINT32_MAX / 1000U )) { PyErr_SetString ( PyExc_OverflowError , \"delta_ms too large to convert to microseconds\" ); return NULL ; } uint32_t delta_us = ( delta_ms * 1000U ); mock_time_advance ( delta_us ); Py_RETURN_NONE ; } return NULL ; } static PyObject * py_time_set ( PyObject * self , PyObject * args ) { uint32_t value = 0 ; if ( PyArg_ParseTuple ( args , \"I\" , & value )) { if ( value > ( UINT32_MAX / 1000U )) { PyErr_SetString ( PyExc_OverflowError , \"value too large to convert to microseconds\" ); return NULL ; } mock_time_set ( value * 1000U ); Py_RETURN_NONE ; } return NULL ; } static PyObject * py_time_reset ( PyObject * self , PyObject * args ) { mock_time_reset (); Py_RETURN_NONE ; } static PyObject * py_get_last_protocol_result ( PyObject * self , PyObject * args ) { PyObject * py_link = NULL ; if ( PyArg_ParseTuple ( args , \"O\" , & py_link )) { IsoTpLink * link = PyCapsule_GetPointer ( py_link , \"IsoTpLink\" ); if ( link != NULL ) { return PyLong_FromLong ( link -> send_protocol_result ); } } return NULL ; } static PyObject * py_get_last_receive_protocol_result ( PyObject * self , PyObject * args ) { PyObject * py_link = NULL ; if ( PyArg_ParseTuple ( args , \"O\" , & py_link )) { IsoTpLink * link = PyCapsule_GetPointer ( py_link , \"IsoTpLink\" ); if ( link != NULL ) { return PyLong_FromLong ( link -> receive_protocol_result ); } } return NULL ; } static PyObject * py_set_timeouts ( PyObject * self , PyObject * args ) { PyObject * py_link = NULL ; uint32_t n_bs_ms = 0 ; uint32_t n_cr_ms = 0 ; if ( PyArg_ParseTuple ( args , \"OII\" , & py_link , & n_bs_ms , & n_cr_ms )) { if (( n_bs_ms > ( UINT32_MAX / 1000U )) || ( n_cr_ms > ( UINT32_MAX / 1000U ))) { PyErr_SetString ( PyExc_OverflowError , \"timeout too large to convert to microseconds\" ); return NULL ; } IsoTpLink * link = PyCapsule_GetPointer ( py_link , \"IsoTpLink\" ); if ( link != NULL ) { isotp_set_timeouts ( link , n_bs_ms * 1000U , n_cr_ms * 1000U ); Py_RETURN_NONE ; } } return NULL ; } static PyObject * py_set_fc_params ( PyObject * self , PyObject * args ) { PyObject * py_link = NULL ; uint32_t block_size = 0 ; uint32_t st_min_ms = 0 ; if ( PyArg_ParseTuple ( args , \"OII\" , & py_link , & block_size , & st_min_ms )) { if ( block_size > 0xFF ) { PyErr_SetString ( PyExc_ValueError , \"block_size must be <= 255\" ); return NULL ; } if ( st_min_ms > ( UINT32_MAX / 1000U )) { PyErr_SetString ( PyExc_OverflowError , \"st_min_ms too large to convert to microseconds\" ); return NULL ; } IsoTpLink * link = PyCapsule_GetPointer ( py_link , \"IsoTpLink\" ); if ( link != NULL ) { isotp_set_fc_params ( link , ( uint8_t ) block_size , st_min_ms * 1000U ); Py_RETURN_NONE ; } } return NULL ; } static PyObject * py_inject_can ( PyObject * self , PyObject * args ) { PyObject * py_link = NULL ; const char * data = NULL ; Py_ssize_t len = 0 ; if ( PyArg_ParseTuple ( args , \"Oy#\" , & py_link , & data , & len )) { if ( len < 2 || len > 8 ) { PyErr_SetString ( PyExc_ValueError , \"frame length must be 2..8\" ); return NULL ; } IsoTpLink * link = PyCapsule_GetPointer ( py_link , \"IsoTpLink\" ); if ( link != NULL ) { isotp_on_can_message ( link , ( const uint8_t * ) data , ( uint8_t ) len ); Py_RETURN_NONE ; } } return NULL ; } static void pyisotp_capsule_destructor ( PyObject * capsule ) { IsoTpLink * link = PyCapsule_GetPointer ( capsule , \"IsoTpLink\" ); if ( link == NULL ) { return ; } uint8_t * sbuf = link -> send_buffer ; uint8_t * rbuf = link -> receive_buffer ; isotp_destroy_link ( link ); PyMem_Free ( sbuf ); PyMem_Free ( rbuf ); PyMem_Free ( link ); } /* ============================================================================== * PUBLIC FUNCTION IMPLEMENTATIONS * =============================================================================*/ PyMODINIT_FUNC PyInit_pyisotp ( void ) { PyObject * module = PyModule_Create ( & pyisotp_module ); if ( module != NULL ) { mock_can_init (); mock_time_reset (); // clang-format off if ( PyModule_AddIntConstant ( module , \"ISOTP_PROTOCOL_RESULT_TIMEOUT_BS\" , ISOTP_PROTOCOL_RESULT_TIMEOUT_BS ) < 0 ) { Py_DECREF ( module ); return NULL ; } if ( PyModule_AddIntConstant ( module , \"ISOTP_PROTOCOL_RESULT_TIMEOUT_CR\" , ISOTP_PROTOCOL_RESULT_TIMEOUT_CR ) < 0 ) { Py_DECREF ( module ); return NULL ; } if ( PyModule_AddIntConstant ( module , \"ISOTP_PROTOCOL_RESULT_OK\" , ISOTP_PROTOCOL_RESULT_OK ) < 0 ) // clang-format on { Py_DECREF ( module ); return NULL ; } // clang-format off if ( PyModule_AddIntConstant ( module , \"ISOTP_PROTOCOL_RESULT_WRONG_SN\" , ISOTP_PROTOCOL_RESULT_WRONG_SN ) < 0 ) // clang-format on { Py_DECREF ( module ); return NULL ; } // clang-format off if ( PyModule_AddIntConstant ( module , \"ISOTP_PROTOCOL_RESULT_UNEXP_PDU\" , ISOTP_PROTOCOL_RESULT_UNEXP_PDU ) < 0 ) // clang-format on { Py_DECREF ( module ); return NULL ; } // clang-format off if ( PyModule_AddIntConstant ( module , \"ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW\" , ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW ) < 0 ) // clang-format on { Py_DECREF ( module ); return NULL ; } // clang-format off if ( PyModule_AddIntConstant ( module , \"ISOTP_PROTOCOL_RESULT_WFT_OVRN\" , ISOTP_PROTOCOL_RESULT_WFT_OVRN ) < 0 ) // clang-format on { Py_DECREF ( module ); return NULL ; } // clang-format off if ( PyModule_AddIntConstant ( module , \"ISOTP_RET_INPROGRESS\" , ISOTP_RET_INPROGRESS ) < 0 ) // clang-format on { Py_DECREF ( module ); return NULL ; } // clang-format off if ( PyModule_AddIntConstant ( module , \"ISOTP_RET_OVERFLOW\" , ISOTP_RET_OVERFLOW ) < 0 ) // clang-format on { Py_DECREF ( module ); return NULL ; } } return module ; }","title":"File pyisotp.c"},{"location":"docs/pyisotp_8c_source/#file-pyisotpc","text":"File List > examples > python_api > pyisotp.c Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: File description - briefly describe purpose of this source file * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ #define PY_SSIZE_T_CLEAN /* ============================================================================== * INCLUDES * =============================================================================*/ #include <Python.h> #include \"isotp.h\" #include \"can_driver.h\" #include \"mock_can.h\" #include \"mock_time.h\" /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Static type definitions local to this file */ /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ static PyObject * pyisotp_init ( PyObject * self , PyObject * args ); static PyObject * pyisotp_send ( PyObject * self , PyObject * args ); static PyObject * pyisotp_poll ( PyObject * self , PyObject * args ); static PyObject * pyisotp_receive ( PyObject * self , PyObject * args ); static PyObject * py_mock_enable_drop ( PyObject * self , PyObject * args ); static PyObject * py_mock_disable_fc ( PyObject * self , PyObject * args ); static PyObject * py_get_last_protocol_result ( PyObject * self , PyObject * args ); static PyObject * py_get_last_receive_protocol_result ( PyObject * self , PyObject * args ); static PyObject * py_set_timeouts ( PyObject * self , PyObject * args ); static PyObject * py_set_fc_params ( PyObject * self , PyObject * args ); static PyObject * py_inject_can ( PyObject * self , PyObject * args ); static PyObject * py_time_advance ( PyObject * self , PyObject * args ); static PyObject * py_time_set ( PyObject * self , PyObject * args ); static PyObject * py_time_reset ( PyObject * self , PyObject * args ); static void pyisotp_capsule_destructor ( PyObject * capsule ); /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ // clang-format off static PyMethodDef PyIsoTpMethods [] = { { \"init\" , pyisotp_init , METH_VARARGS , \"Initialize ISO-TP link\" }, { \"send\" , pyisotp_send , METH_VARARGS , \"Send data over ISO-TP\" }, { \"poll\" , pyisotp_poll , METH_VARARGS , \"Poll ISO-TP link for timeouts and state updates\" }, { \"receive\" , pyisotp_receive , METH_VARARGS , \"Receive data from ISO-TP link\" }, { \"mock_enable_drop\" , py_mock_enable_drop , METH_VARARGS , \"Enable or disable CAN frame dropping in the mock CAN driver\" }, { \"mock_disable_fc\" , py_mock_disable_fc , METH_VARARGS , \"Enable or disable FlowControl frames in the mock CAN driver\" }, { \"time_advance\" , py_time_advance , METH_VARARGS , \"Advance virtual time in the mock time implementation\" }, { \"time_set\" , py_time_set , METH_VARARGS , \"Set virtual time in the mock time implementation to a specific value\" }, { \"time_reset\" , py_time_reset , METH_VARARGS , \"Reset virtual time in the mock time implementation to zero\" }, { \"get_last_protocol_result\" , py_get_last_protocol_result , METH_VARARGS , \"Get last sender protocol result\" }, { \"get_last_receive_protocol_result\" , py_get_last_receive_protocol_result , METH_VARARGS , \"Get last receiver protocol result\" }, { \"set_timeouts\" , py_set_timeouts , METH_VARARGS , \"Set N_Bs and N_Cr timeouts in milliseconds\" }, { \"set_fc_params\" , py_set_fc_params , METH_VARARGS , \"Set FlowControl block size and STmin in milliseconds\" }, { \"inject_can\" , py_inject_can , METH_VARARGS , \"Inject raw CAN frame into the ISO-TP link\" }, { NULL , NULL , 0 , NULL } // Sentinel }; static struct PyModuleDef pyisotp_module = { PyModuleDef_HEAD_INIT , \"pyisotp\" , \"Python bindings for ISO-TP-C library\" , -1 , PyIsoTpMethods }; // clang-format on /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ static PyObject * pyisotp_init ( PyObject * self , PyObject * args ) { uint32_t sendid = 0 ; Py_ssize_t sbufsz = { 0 }; Py_ssize_t rbufsz = { 0 }; if ( PyArg_ParseTuple ( args , \"Inn\" , & sendid , & sbufsz , & rbufsz )) { if (( sbufsz <= 0 ) || ( rbufsz <= 0 ) || ( sbufsz > UINT32_MAX ) || ( rbufsz > UINT32_MAX )) { PyErr_SetString ( PyExc_ValueError , \"sbufsz/rbufsz must be > 0 and <= UINT32_MAX\" ); return NULL ; } mock_can_init (); mock_time_reset (); IsoTpLink * link = PyMem_Malloc ( sizeof ( IsoTpLink )); uint8_t * sbuf = PyMem_Malloc ( sbufsz ); uint8_t * rbuf = PyMem_Malloc ( rbufsz ); if (( link == NULL ) || ( sbuf == NULL ) || ( rbuf == NULL )) { PyMem_Free ( link ); PyMem_Free ( sbuf ); PyMem_Free ( rbuf ); return PyErr_NoMemory (); } isotp_init_link ( link , sendid , sbuf , ( uint32_t ) sbufsz , rbuf , ( uint32_t ) rbufsz ); PyObject * capsule = PyCapsule_New ( link , \"IsoTpLink\" , pyisotp_capsule_destructor ); if ( capsule == NULL ) { isotp_destroy_link ( link ); PyMem_Free ( sbuf ); PyMem_Free ( rbuf ); PyMem_Free ( link ); return NULL ; } return capsule ; } return NULL ; } static PyObject * pyisotp_send ( PyObject * self , PyObject * args ) { PyObject * py_link = NULL ; const char * data = NULL ; Py_ssize_t len = { 0 }; if ( PyArg_ParseTuple ( args , \"Oy#\" , & py_link , & data , & len )) { IsoTpLink * link = PyCapsule_GetPointer ( py_link , \"IsoTpLink\" ); if ( link != NULL ) { if ( len > ( Py_ssize_t ) link -> send_buf_size ) { return PyLong_FromLong ( ISOTP_RET_OVERFLOW ); } int res = isotp_send ( link , ( const uint8_t * ) data , ( uint32_t ) len ); return PyLong_FromLong ( res ); } } return NULL ; } static PyObject * pyisotp_poll ( PyObject * self , PyObject * args ) { PyObject * py_link = NULL ; if ( PyArg_ParseTuple ( args , \"O\" , & py_link )) { IsoTpLink * link = PyCapsule_GetPointer ( py_link , \"IsoTpLink\" ); if ( link != NULL ) { isotp_poll ( link ); uint32_t id = 0 ; uint8_t len = 0 ; uint8_t data [ 8 ] = { 0 }; while ( can_receive ( & id , data , & len ) == 0 ) { isotp_on_can_message ( link , data , len ); } Py_RETURN_NONE ; } } return NULL ; } static PyObject * pyisotp_receive ( PyObject * self , PyObject * args ) { PyObject * py_link = NULL ; Py_ssize_t bufsize = { 0 }; if ( PyArg_ParseTuple ( args , \"On\" , & py_link , & bufsize )) { if ( bufsize <= 0 || bufsize > UINT32_MAX ) { PyErr_SetString ( PyExc_ValueError , \"bufsize must be > 0 and <= UINT32_MAX\" ); return NULL ; } IsoTpLink * link = PyCapsule_GetPointer ( py_link , \"IsoTpLink\" ); if ( link != NULL ) { uint8_t * buf = PyMem_Malloc ( bufsize ); if ( buf == NULL ) { return PyErr_NoMemory (); } uint32_t outsz = 0 ; int ret = isotp_receive ( link , buf , ( uint32_t ) bufsize , & outsz ); if ( ret == ISOTP_RET_OK ) { if ( outsz > ( uint32_t ) PY_SSIZE_T_MAX ) { PyMem_Free ( buf ); PyErr_SetString ( PyExc_OverflowError , \"received size exceeds Python maximum size\" ); return NULL ; } PyObject * result = Py_BuildValue ( \"y#\" , buf , ( Py_ssize_t ) outsz ); PyMem_Free ( buf ); return result ; } PyMem_Free ( buf ); Py_RETURN_NONE ; } } return NULL ; } static PyObject * py_mock_enable_drop ( PyObject * self , PyObject * args ) { int enable = 0 ; if ( PyArg_ParseTuple ( args , \"p\" , & enable )) { mock_can_enable_drop ( enable ); Py_RETURN_NONE ; } return NULL ; } static PyObject * py_mock_disable_fc ( PyObject * self , PyObject * args ) { int enable = 0 ; if ( PyArg_ParseTuple ( args , \"p\" , & enable )) { mock_can_disable_fc ( enable ); Py_RETURN_NONE ; } return NULL ; } static PyObject * py_time_advance ( PyObject * self , PyObject * args ) { uint32_t delta_ms = 0 ; if ( PyArg_ParseTuple ( args , \"I\" , & delta_ms )) { if ( delta_ms > ( UINT32_MAX / 1000U )) { PyErr_SetString ( PyExc_OverflowError , \"delta_ms too large to convert to microseconds\" ); return NULL ; } uint32_t delta_us = ( delta_ms * 1000U ); mock_time_advance ( delta_us ); Py_RETURN_NONE ; } return NULL ; } static PyObject * py_time_set ( PyObject * self , PyObject * args ) { uint32_t value = 0 ; if ( PyArg_ParseTuple ( args , \"I\" , & value )) { if ( value > ( UINT32_MAX / 1000U )) { PyErr_SetString ( PyExc_OverflowError , \"value too large to convert to microseconds\" ); return NULL ; } mock_time_set ( value * 1000U ); Py_RETURN_NONE ; } return NULL ; } static PyObject * py_time_reset ( PyObject * self , PyObject * args ) { mock_time_reset (); Py_RETURN_NONE ; } static PyObject * py_get_last_protocol_result ( PyObject * self , PyObject * args ) { PyObject * py_link = NULL ; if ( PyArg_ParseTuple ( args , \"O\" , & py_link )) { IsoTpLink * link = PyCapsule_GetPointer ( py_link , \"IsoTpLink\" ); if ( link != NULL ) { return PyLong_FromLong ( link -> send_protocol_result ); } } return NULL ; } static PyObject * py_get_last_receive_protocol_result ( PyObject * self , PyObject * args ) { PyObject * py_link = NULL ; if ( PyArg_ParseTuple ( args , \"O\" , & py_link )) { IsoTpLink * link = PyCapsule_GetPointer ( py_link , \"IsoTpLink\" ); if ( link != NULL ) { return PyLong_FromLong ( link -> receive_protocol_result ); } } return NULL ; } static PyObject * py_set_timeouts ( PyObject * self , PyObject * args ) { PyObject * py_link = NULL ; uint32_t n_bs_ms = 0 ; uint32_t n_cr_ms = 0 ; if ( PyArg_ParseTuple ( args , \"OII\" , & py_link , & n_bs_ms , & n_cr_ms )) { if (( n_bs_ms > ( UINT32_MAX / 1000U )) || ( n_cr_ms > ( UINT32_MAX / 1000U ))) { PyErr_SetString ( PyExc_OverflowError , \"timeout too large to convert to microseconds\" ); return NULL ; } IsoTpLink * link = PyCapsule_GetPointer ( py_link , \"IsoTpLink\" ); if ( link != NULL ) { isotp_set_timeouts ( link , n_bs_ms * 1000U , n_cr_ms * 1000U ); Py_RETURN_NONE ; } } return NULL ; } static PyObject * py_set_fc_params ( PyObject * self , PyObject * args ) { PyObject * py_link = NULL ; uint32_t block_size = 0 ; uint32_t st_min_ms = 0 ; if ( PyArg_ParseTuple ( args , \"OII\" , & py_link , & block_size , & st_min_ms )) { if ( block_size > 0xFF ) { PyErr_SetString ( PyExc_ValueError , \"block_size must be <= 255\" ); return NULL ; } if ( st_min_ms > ( UINT32_MAX / 1000U )) { PyErr_SetString ( PyExc_OverflowError , \"st_min_ms too large to convert to microseconds\" ); return NULL ; } IsoTpLink * link = PyCapsule_GetPointer ( py_link , \"IsoTpLink\" ); if ( link != NULL ) { isotp_set_fc_params ( link , ( uint8_t ) block_size , st_min_ms * 1000U ); Py_RETURN_NONE ; } } return NULL ; } static PyObject * py_inject_can ( PyObject * self , PyObject * args ) { PyObject * py_link = NULL ; const char * data = NULL ; Py_ssize_t len = 0 ; if ( PyArg_ParseTuple ( args , \"Oy#\" , & py_link , & data , & len )) { if ( len < 2 || len > 8 ) { PyErr_SetString ( PyExc_ValueError , \"frame length must be 2..8\" ); return NULL ; } IsoTpLink * link = PyCapsule_GetPointer ( py_link , \"IsoTpLink\" ); if ( link != NULL ) { isotp_on_can_message ( link , ( const uint8_t * ) data , ( uint8_t ) len ); Py_RETURN_NONE ; } } return NULL ; } static void pyisotp_capsule_destructor ( PyObject * capsule ) { IsoTpLink * link = PyCapsule_GetPointer ( capsule , \"IsoTpLink\" ); if ( link == NULL ) { return ; } uint8_t * sbuf = link -> send_buffer ; uint8_t * rbuf = link -> receive_buffer ; isotp_destroy_link ( link ); PyMem_Free ( sbuf ); PyMem_Free ( rbuf ); PyMem_Free ( link ); } /* ============================================================================== * PUBLIC FUNCTION IMPLEMENTATIONS * =============================================================================*/ PyMODINIT_FUNC PyInit_pyisotp ( void ) { PyObject * module = PyModule_Create ( & pyisotp_module ); if ( module != NULL ) { mock_can_init (); mock_time_reset (); // clang-format off if ( PyModule_AddIntConstant ( module , \"ISOTP_PROTOCOL_RESULT_TIMEOUT_BS\" , ISOTP_PROTOCOL_RESULT_TIMEOUT_BS ) < 0 ) { Py_DECREF ( module ); return NULL ; } if ( PyModule_AddIntConstant ( module , \"ISOTP_PROTOCOL_RESULT_TIMEOUT_CR\" , ISOTP_PROTOCOL_RESULT_TIMEOUT_CR ) < 0 ) { Py_DECREF ( module ); return NULL ; } if ( PyModule_AddIntConstant ( module , \"ISOTP_PROTOCOL_RESULT_OK\" , ISOTP_PROTOCOL_RESULT_OK ) < 0 ) // clang-format on { Py_DECREF ( module ); return NULL ; } // clang-format off if ( PyModule_AddIntConstant ( module , \"ISOTP_PROTOCOL_RESULT_WRONG_SN\" , ISOTP_PROTOCOL_RESULT_WRONG_SN ) < 0 ) // clang-format on { Py_DECREF ( module ); return NULL ; } // clang-format off if ( PyModule_AddIntConstant ( module , \"ISOTP_PROTOCOL_RESULT_UNEXP_PDU\" , ISOTP_PROTOCOL_RESULT_UNEXP_PDU ) < 0 ) // clang-format on { Py_DECREF ( module ); return NULL ; } // clang-format off if ( PyModule_AddIntConstant ( module , \"ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW\" , ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW ) < 0 ) // clang-format on { Py_DECREF ( module ); return NULL ; } // clang-format off if ( PyModule_AddIntConstant ( module , \"ISOTP_PROTOCOL_RESULT_WFT_OVRN\" , ISOTP_PROTOCOL_RESULT_WFT_OVRN ) < 0 ) // clang-format on { Py_DECREF ( module ); return NULL ; } // clang-format off if ( PyModule_AddIntConstant ( module , \"ISOTP_RET_INPROGRESS\" , ISOTP_RET_INPROGRESS ) < 0 ) // clang-format on { Py_DECREF ( module ); return NULL ; } // clang-format off if ( PyModule_AddIntConstant ( module , \"ISOTP_RET_OVERFLOW\" , ISOTP_RET_OVERFLOW ) < 0 ) // clang-format on { Py_DECREF ( module ); return NULL ; } } return module ; }","title":"File pyisotp.c"},{"location":"docs/dir_bfccd401955b95cf8c75461437045ac0/","text":"Dir inc \u00b6 FileList > inc Files \u00b6 Type Name file isotp_config.h ISO-TP configuration parameters and feature toggles. file isotp_defines.h Internal protocol definitions and type structures for ISO-TP. file isotp_user.h User callback interfaces and platform abstraction layer. The documentation for this class was generated from the following file inc/","title":"Dir inc"},{"location":"docs/dir_bfccd401955b95cf8c75461437045ac0/#dir-inc","text":"FileList > inc","title":"Dir inc"},{"location":"docs/dir_bfccd401955b95cf8c75461437045ac0/#files","text":"Type Name file isotp_config.h ISO-TP configuration parameters and feature toggles. file isotp_defines.h Internal protocol definitions and type structures for ISO-TP. file isotp_user.h User callback interfaces and platform abstraction layer. The documentation for this class was generated from the following file inc/","title":"Files"},{"location":"docs/isotp__config_8h/","text":"File isotp_config.h \u00b6 FileList > inc > isotp_config.h Go to the source code of this file ISO-TP configuration parameters and feature toggles. More... Macros \u00b6 Type Name define ISO_TP_DEFAULT_BLOCK_SIZE (8) Max number of messages the receiver can receive at one time. define ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US (100000) Default timeout while waiting for a response during a multi-frame transfer. define ISO_TP_DEFAULT_ST_MIN_US (0) Minimum time gap allowed between consecutive frame N_PDUs. define ISO_TP_FRAME_PADDING_VALUE (0xAA) Padding byte value when ISO_TP_FRAME_PADDING is enabled. define ISO_TP_MAX_WFT_NUMBER (1) Number of FC N_PDU WTs that can be transmitted by the receiver in a row. Detailed Description \u00b6 Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization Author: Anton Vynohradov Email: avynohradov@systemfromscratch.com Copyright: Copyright (c) 2026 Anton Vynohradov @license MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. SPDX-License-Identifier: MIT Macro Definition Documentation \u00b6 define ISO_TP_DEFAULT_BLOCK_SIZE \u00b6 Max number of messages the receiver can receive at one time. #define ISO_TP_DEFAULT_BLOCK_SIZE `(8)` This value is affected by CAN driver queue length. define ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US \u00b6 Default timeout while waiting for a response during a multi-frame transfer. #define ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US `(100000)` define ISO_TP_DEFAULT_ST_MIN_US \u00b6 Minimum time gap allowed between consecutive frame N_PDUs. #define ISO_TP_DEFAULT_ST_MIN_US `(0)` define ISO_TP_FRAME_PADDING_VALUE \u00b6 Padding byte value when ISO_TP_FRAME_PADDING is enabled. #define ISO_TP_FRAME_PADDING_VALUE `(0xAA)` define ISO_TP_MAX_WFT_NUMBER \u00b6 Number of FC N_PDU WTs that can be transmitted by the receiver in a row. #define ISO_TP_MAX_WFT_NUMBER `(1)` The documentation for this class was generated from the following file inc/isotp_config.h","title":"File isotp_config.h"},{"location":"docs/isotp__config_8h/#file-isotp_configh","text":"FileList > inc > isotp_config.h Go to the source code of this file ISO-TP configuration parameters and feature toggles. More...","title":"File isotp_config.h"},{"location":"docs/isotp__config_8h/#macros","text":"Type Name define ISO_TP_DEFAULT_BLOCK_SIZE (8) Max number of messages the receiver can receive at one time. define ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US (100000) Default timeout while waiting for a response during a multi-frame transfer. define ISO_TP_DEFAULT_ST_MIN_US (0) Minimum time gap allowed between consecutive frame N_PDUs. define ISO_TP_FRAME_PADDING_VALUE (0xAA) Padding byte value when ISO_TP_FRAME_PADDING is enabled. define ISO_TP_MAX_WFT_NUMBER (1) Number of FC N_PDU WTs that can be transmitted by the receiver in a row.","title":"Macros"},{"location":"docs/isotp__config_8h/#detailed-description","text":"Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization Author: Anton Vynohradov Email: avynohradov@systemfromscratch.com Copyright: Copyright (c) 2026 Anton Vynohradov @license MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. SPDX-License-Identifier: MIT","title":"Detailed Description"},{"location":"docs/isotp__config_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"docs/isotp__config_8h/#define-iso_tp_default_block_size","text":"Max number of messages the receiver can receive at one time. #define ISO_TP_DEFAULT_BLOCK_SIZE `(8)` This value is affected by CAN driver queue length.","title":"define ISO_TP_DEFAULT_BLOCK_SIZE"},{"location":"docs/isotp__config_8h/#define-iso_tp_default_response_timeout_us","text":"Default timeout while waiting for a response during a multi-frame transfer. #define ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US `(100000)`","title":"define ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US"},{"location":"docs/isotp__config_8h/#define-iso_tp_default_st_min_us","text":"Minimum time gap allowed between consecutive frame N_PDUs. #define ISO_TP_DEFAULT_ST_MIN_US `(0)`","title":"define ISO_TP_DEFAULT_ST_MIN_US"},{"location":"docs/isotp__config_8h/#define-iso_tp_frame_padding_value","text":"Padding byte value when ISO_TP_FRAME_PADDING is enabled. #define ISO_TP_FRAME_PADDING_VALUE `(0xAA)`","title":"define ISO_TP_FRAME_PADDING_VALUE"},{"location":"docs/isotp__config_8h/#define-iso_tp_max_wft_number","text":"Number of FC N_PDU WTs that can be transmitted by the receiver in a row. #define ISO_TP_MAX_WFT_NUMBER `(1)` The documentation for this class was generated from the following file inc/isotp_config.h","title":"define ISO_TP_MAX_WFT_NUMBER"},{"location":"docs/isotp__config_8h_source/","text":"File isotp_config.h \u00b6 File List > inc > isotp_config.h Go to the documentation of this file #ifndef ISOTPC_CONFIG_H #define ISOTPC_CONFIG_H #ifndef ISO_TP_DEFAULT_BLOCK_SIZE #define ISO_TP_DEFAULT_BLOCK_SIZE (8) #endif #ifndef ISO_TP_DEFAULT_ST_MIN_US #define ISO_TP_DEFAULT_ST_MIN_US (0) #endif #ifndef ISO_TP_MAX_WFT_NUMBER #define ISO_TP_MAX_WFT_NUMBER (1) #endif #ifndef ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US #define ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US (100000) #endif /* #define ISO_TP_FRAME_PADDING */ #ifndef ISO_TP_FRAME_PADDING_VALUE #define ISO_TP_FRAME_PADDING_VALUE (0xAA) #endif /* #define ISO_TP_USER_SEND_CAN_ARG */ /* #define ISO_TP_TRANSMIT_COMPLETE_CALLBACK */ /* #define ISO_TP_RECEIVE_COMPLETE_CALLBACK */ #endif /* ISOTPC_CONFIG_H */","title":"File isotp_config.h"},{"location":"docs/isotp__config_8h_source/#file-isotp_configh","text":"File List > inc > isotp_config.h Go to the documentation of this file #ifndef ISOTPC_CONFIG_H #define ISOTPC_CONFIG_H #ifndef ISO_TP_DEFAULT_BLOCK_SIZE #define ISO_TP_DEFAULT_BLOCK_SIZE (8) #endif #ifndef ISO_TP_DEFAULT_ST_MIN_US #define ISO_TP_DEFAULT_ST_MIN_US (0) #endif #ifndef ISO_TP_MAX_WFT_NUMBER #define ISO_TP_MAX_WFT_NUMBER (1) #endif #ifndef ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US #define ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US (100000) #endif /* #define ISO_TP_FRAME_PADDING */ #ifndef ISO_TP_FRAME_PADDING_VALUE #define ISO_TP_FRAME_PADDING_VALUE (0xAA) #endif /* #define ISO_TP_USER_SEND_CAN_ARG */ /* #define ISO_TP_TRANSMIT_COMPLETE_CALLBACK */ /* #define ISO_TP_RECEIVE_COMPLETE_CALLBACK */ #endif /* ISOTPC_CONFIG_H */","title":"File isotp_config.h"},{"location":"docs/isotp__defines_8h/","text":"File isotp_defines.h \u00b6 FileList > inc > isotp_defines.h Go to the source code of this file Internal protocol definitions and type structures for ISO-TP. More... #include <stdint.h> Classes \u00b6 Type Name struct IsoTpCanMessage struct IsoTpConsecutiveFrame Consecutive frame layout. struct IsoTpDataArray struct IsoTpFirstFrameShort First frame (short) layout. struct IsoTpFlowControl Flow control frame layout. struct IsoTpPciType CAN frame definitions. struct IsoTpSingleFrame Single frame layout. Public Types \u00b6 Type Name enum IsoTpFlowStatus Protocol Control Information (PCI) flow control identifiers. enum IsoTpProtocolControlInformation Protocol-specific defines. enum IsoTpReceiveStatusTypes ISOTP receiver status. enum IsoTpSendStatusTypes ISOTP sender status. Public Functions \u00b6 Type Name ISOTP_PACKED_STRUCT ({ uint8_t set_to_zero_high :4;uint8_t type :4;uint8_t set_to_zero_low;uint32_t FF_DL;uint8_t data[2];} IsoTpFirstFrameLong) First frame (long) layout. Macros \u00b6 Type Name define ISOTP_INVALID_BS 0xFFFF Invalid block size marker. define ISOTP_MAX_ERROR_MSG_SIZE 128 Max number of characters allowed in an error message. define ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW -8 define ISOTP_PROTOCOL_RESULT_ERROR -9 define ISOTP_PROTOCOL_RESULT_INVALID_FS -5 define ISOTP_PROTOCOL_RESULT_OK 0 Network layer result codes. define ISOTP_PROTOCOL_RESULT_TIMEOUT_A -1 define ISOTP_PROTOCOL_RESULT_TIMEOUT_BS -2 define ISOTP_PROTOCOL_RESULT_TIMEOUT_CR -3 define ISOTP_PROTOCOL_RESULT_UNEXP_PDU -6 define ISOTP_PROTOCOL_RESULT_WFT_OVRN -7 define ISOTP_PROTOCOL_RESULT_WRONG_SN -4 define ISOTP_RET_ERROR -1 define ISOTP_RET_INPROGRESS -2 define ISOTP_RET_LENGTH -7 define ISOTP_RET_NOSPACE -8 define ISOTP_RET_NO_DATA -5 define ISOTP_RET_OK 0 Internal return codes. define ISOTP_RET_OVERFLOW -3 define ISOTP_RET_TIMEOUT -6 define ISOTP_RET_WRONG_SN -4 define IsoTpTimeAfter (a, b) ((int32\\_t) ((int32\\_t) (b) - (int32\\_t) (a)) &lt; 0) Returns true if time a is after time b . define LE32TOH (le) /* multi line expression */ Compiler-specific defines. Detailed Description \u00b6 Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization Author: Anton Vynohradov Email: avynohradov@systemfromscratch.com Copyright: Copyright (c) 2026 Anton Vynohradov @license MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. SPDX-License-Identifier: MIT Public Types Documentation \u00b6 enum IsoTpFlowStatus \u00b6 Protocol Control Information (PCI) flow control identifiers. enum IsoTpFlowStatus { PCI_FLOW_STATUS_CONTINUE = 0x0 , PCI_FLOW_STATUS_WAIT = 0x1 , PCI_FLOW_STATUS_OVERFLOW = 0x2 }; enum IsoTpProtocolControlInformation \u00b6 Protocol-specific defines. enum IsoTpProtocolControlInformation { ISOTP_PCI_TYPE_SINGLE = 0x0 , ISOTP_PCI_TYPE_FIRST_FRAME = 0x1 , TSOTP_PCI_TYPE_CONSECUTIVE_FRAME = 0x2 , ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME = 0x3 , ISOTP_PCI_TYPE_CONSECUTIVE_FRAME = 0x2 }; Protocol Control Information (PCI) types for identifying ISO-TP frames. enum IsoTpReceiveStatusTypes \u00b6 ISOTP receiver status. enum IsoTpReceiveStatusTypes { ISOTP_RECEIVE_STATUS_IDLE , ISOTP_RECEIVE_STATUS_INPROGRESS , ISOTP_RECEIVE_STATUS_FULL }; enum IsoTpSendStatusTypes \u00b6 ISOTP sender status. enum IsoTpSendStatusTypes { ISOTP_SEND_STATUS_IDLE , ISOTP_SEND_STATUS_INPROGRESS , ISOTP_SEND_STATUS_ERROR }; Public Functions Documentation \u00b6 function ISOTP_PACKED_STRUCT \u00b6 First frame (long) layout. ISOTP_PACKED_STRUCT ( { uint8_t set_to_zero_high : 4 ; uint8_t type : 4 ; uint8_t set_to_zero_low ; uint32_t FF_DL ; uint8_t data [ 2 ];} IsoTpFirstFrameLong ) +-------------------------+-----------------------+---------+---------+---------+---------+ | byte # 0 | byte # 1 | byte # 2 | byte # 3 | byte # 4 | byte # 5 | +-------------------------+-----------+-----------+---------+---------+---------+---------+ | nibble # 0 | nibble # 1 | nibble # 2 | nibble # 3 | ... | +-------------+-----------+-----------+-----------+---------------------------------------+ | PCIType = 1 | unused = 0 | escape sequence = 0 | FF_DL | +-------------+-----------+-----------------------+---------------------------------------+ Macro Definition Documentation \u00b6 define ISOTP_INVALID_BS \u00b6 Invalid block size marker. #define ISOTP_INVALID_BS `0xFFFF` define ISOTP_MAX_ERROR_MSG_SIZE \u00b6 Max number of characters allowed in an error message. #define ISOTP_MAX_ERROR_MSG_SIZE `128` define ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW \u00b6 #define ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW `-8` define ISOTP_PROTOCOL_RESULT_ERROR \u00b6 #define ISOTP_PROTOCOL_RESULT_ERROR `-9` define ISOTP_PROTOCOL_RESULT_INVALID_FS \u00b6 #define ISOTP_PROTOCOL_RESULT_INVALID_FS `-5` define ISOTP_PROTOCOL_RESULT_OK \u00b6 Network layer result codes. #define ISOTP_PROTOCOL_RESULT_OK `0` define ISOTP_PROTOCOL_RESULT_TIMEOUT_A \u00b6 #define ISOTP_PROTOCOL_RESULT_TIMEOUT_A `-1` define ISOTP_PROTOCOL_RESULT_TIMEOUT_BS \u00b6 #define ISOTP_PROTOCOL_RESULT_TIMEOUT_BS `-2` define ISOTP_PROTOCOL_RESULT_TIMEOUT_CR \u00b6 #define ISOTP_PROTOCOL_RESULT_TIMEOUT_CR `-3` define ISOTP_PROTOCOL_RESULT_UNEXP_PDU \u00b6 #define ISOTP_PROTOCOL_RESULT_UNEXP_PDU `-6` define ISOTP_PROTOCOL_RESULT_WFT_OVRN \u00b6 #define ISOTP_PROTOCOL_RESULT_WFT_OVRN `-7` define ISOTP_PROTOCOL_RESULT_WRONG_SN \u00b6 #define ISOTP_PROTOCOL_RESULT_WRONG_SN `-4` define ISOTP_RET_ERROR \u00b6 #define ISOTP_RET_ERROR `-1` define ISOTP_RET_INPROGRESS \u00b6 #define ISOTP_RET_INPROGRESS `-2` define ISOTP_RET_LENGTH \u00b6 #define ISOTP_RET_LENGTH `-7` define ISOTP_RET_NOSPACE \u00b6 #define ISOTP_RET_NOSPACE `-8` define ISOTP_RET_NO_DATA \u00b6 #define ISOTP_RET_NO_DATA `-5` define ISOTP_RET_OK \u00b6 Internal return codes. #define ISOTP_RET_OK `0` define ISOTP_RET_OVERFLOW \u00b6 #define ISOTP_RET_OVERFLOW `-3` define ISOTP_RET_TIMEOUT \u00b6 #define ISOTP_RET_TIMEOUT `-6` define ISOTP_RET_WRONG_SN \u00b6 #define ISOTP_RET_WRONG_SN `-4` define IsoTpTimeAfter \u00b6 Returns true if time a is after time b . #define IsoTpTimeAfter ( a , b ) ` (( int32_t ) (( int32_t ) ( b ) - ( int32_t ) ( a )) < 0 ) ` define LE32TOH \u00b6 Compiler-specific defines. #define LE32TOH ( le ) ` /* multi line expression */ ` OS-specific defines. Convert a 32-bit value from little-endian to host byte order. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"File isotp_defines.h"},{"location":"docs/isotp__defines_8h/#file-isotp_definesh","text":"FileList > inc > isotp_defines.h Go to the source code of this file Internal protocol definitions and type structures for ISO-TP. More... #include <stdint.h>","title":"File isotp_defines.h"},{"location":"docs/isotp__defines_8h/#classes","text":"Type Name struct IsoTpCanMessage struct IsoTpConsecutiveFrame Consecutive frame layout. struct IsoTpDataArray struct IsoTpFirstFrameShort First frame (short) layout. struct IsoTpFlowControl Flow control frame layout. struct IsoTpPciType CAN frame definitions. struct IsoTpSingleFrame Single frame layout.","title":"Classes"},{"location":"docs/isotp__defines_8h/#public-types","text":"Type Name enum IsoTpFlowStatus Protocol Control Information (PCI) flow control identifiers. enum IsoTpProtocolControlInformation Protocol-specific defines. enum IsoTpReceiveStatusTypes ISOTP receiver status. enum IsoTpSendStatusTypes ISOTP sender status.","title":"Public Types"},{"location":"docs/isotp__defines_8h/#public-functions","text":"Type Name ISOTP_PACKED_STRUCT ({ uint8_t set_to_zero_high :4;uint8_t type :4;uint8_t set_to_zero_low;uint32_t FF_DL;uint8_t data[2];} IsoTpFirstFrameLong) First frame (long) layout.","title":"Public Functions"},{"location":"docs/isotp__defines_8h/#macros","text":"Type Name define ISOTP_INVALID_BS 0xFFFF Invalid block size marker. define ISOTP_MAX_ERROR_MSG_SIZE 128 Max number of characters allowed in an error message. define ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW -8 define ISOTP_PROTOCOL_RESULT_ERROR -9 define ISOTP_PROTOCOL_RESULT_INVALID_FS -5 define ISOTP_PROTOCOL_RESULT_OK 0 Network layer result codes. define ISOTP_PROTOCOL_RESULT_TIMEOUT_A -1 define ISOTP_PROTOCOL_RESULT_TIMEOUT_BS -2 define ISOTP_PROTOCOL_RESULT_TIMEOUT_CR -3 define ISOTP_PROTOCOL_RESULT_UNEXP_PDU -6 define ISOTP_PROTOCOL_RESULT_WFT_OVRN -7 define ISOTP_PROTOCOL_RESULT_WRONG_SN -4 define ISOTP_RET_ERROR -1 define ISOTP_RET_INPROGRESS -2 define ISOTP_RET_LENGTH -7 define ISOTP_RET_NOSPACE -8 define ISOTP_RET_NO_DATA -5 define ISOTP_RET_OK 0 Internal return codes. define ISOTP_RET_OVERFLOW -3 define ISOTP_RET_TIMEOUT -6 define ISOTP_RET_WRONG_SN -4 define IsoTpTimeAfter (a, b) ((int32\\_t) ((int32\\_t) (b) - (int32\\_t) (a)) &lt; 0) Returns true if time a is after time b . define LE32TOH (le) /* multi line expression */ Compiler-specific defines.","title":"Macros"},{"location":"docs/isotp__defines_8h/#detailed-description","text":"Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization Author: Anton Vynohradov Email: avynohradov@systemfromscratch.com Copyright: Copyright (c) 2026 Anton Vynohradov @license MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. SPDX-License-Identifier: MIT","title":"Detailed Description"},{"location":"docs/isotp__defines_8h/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"docs/isotp__defines_8h/#enum-isotpflowstatus","text":"Protocol Control Information (PCI) flow control identifiers. enum IsoTpFlowStatus { PCI_FLOW_STATUS_CONTINUE = 0x0 , PCI_FLOW_STATUS_WAIT = 0x1 , PCI_FLOW_STATUS_OVERFLOW = 0x2 };","title":"enum IsoTpFlowStatus"},{"location":"docs/isotp__defines_8h/#enum-isotpprotocolcontrolinformation","text":"Protocol-specific defines. enum IsoTpProtocolControlInformation { ISOTP_PCI_TYPE_SINGLE = 0x0 , ISOTP_PCI_TYPE_FIRST_FRAME = 0x1 , TSOTP_PCI_TYPE_CONSECUTIVE_FRAME = 0x2 , ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME = 0x3 , ISOTP_PCI_TYPE_CONSECUTIVE_FRAME = 0x2 }; Protocol Control Information (PCI) types for identifying ISO-TP frames.","title":"enum IsoTpProtocolControlInformation"},{"location":"docs/isotp__defines_8h/#enum-isotpreceivestatustypes","text":"ISOTP receiver status. enum IsoTpReceiveStatusTypes { ISOTP_RECEIVE_STATUS_IDLE , ISOTP_RECEIVE_STATUS_INPROGRESS , ISOTP_RECEIVE_STATUS_FULL };","title":"enum IsoTpReceiveStatusTypes"},{"location":"docs/isotp__defines_8h/#enum-isotpsendstatustypes","text":"ISOTP sender status. enum IsoTpSendStatusTypes { ISOTP_SEND_STATUS_IDLE , ISOTP_SEND_STATUS_INPROGRESS , ISOTP_SEND_STATUS_ERROR };","title":"enum IsoTpSendStatusTypes"},{"location":"docs/isotp__defines_8h/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/isotp__defines_8h/#function-isotp_packed_struct","text":"First frame (long) layout. ISOTP_PACKED_STRUCT ( { uint8_t set_to_zero_high : 4 ; uint8_t type : 4 ; uint8_t set_to_zero_low ; uint32_t FF_DL ; uint8_t data [ 2 ];} IsoTpFirstFrameLong ) +-------------------------+-----------------------+---------+---------+---------+---------+ | byte # 0 | byte # 1 | byte # 2 | byte # 3 | byte # 4 | byte # 5 | +-------------------------+-----------+-----------+---------+---------+---------+---------+ | nibble # 0 | nibble # 1 | nibble # 2 | nibble # 3 | ... | +-------------+-----------+-----------+-----------+---------------------------------------+ | PCIType = 1 | unused = 0 | escape sequence = 0 | FF_DL | +-------------+-----------+-----------------------+---------------------------------------+","title":"function ISOTP_PACKED_STRUCT"},{"location":"docs/isotp__defines_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"docs/isotp__defines_8h/#define-isotp_invalid_bs","text":"Invalid block size marker. #define ISOTP_INVALID_BS `0xFFFF`","title":"define ISOTP_INVALID_BS"},{"location":"docs/isotp__defines_8h/#define-isotp_max_error_msg_size","text":"Max number of characters allowed in an error message. #define ISOTP_MAX_ERROR_MSG_SIZE `128`","title":"define ISOTP_MAX_ERROR_MSG_SIZE"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_buffer_ovflw","text":"#define ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW `-8`","title":"define ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_error","text":"#define ISOTP_PROTOCOL_RESULT_ERROR `-9`","title":"define ISOTP_PROTOCOL_RESULT_ERROR"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_invalid_fs","text":"#define ISOTP_PROTOCOL_RESULT_INVALID_FS `-5`","title":"define ISOTP_PROTOCOL_RESULT_INVALID_FS"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_ok","text":"Network layer result codes. #define ISOTP_PROTOCOL_RESULT_OK `0`","title":"define ISOTP_PROTOCOL_RESULT_OK"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_timeout_a","text":"#define ISOTP_PROTOCOL_RESULT_TIMEOUT_A `-1`","title":"define ISOTP_PROTOCOL_RESULT_TIMEOUT_A"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_timeout_bs","text":"#define ISOTP_PROTOCOL_RESULT_TIMEOUT_BS `-2`","title":"define ISOTP_PROTOCOL_RESULT_TIMEOUT_BS"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_timeout_cr","text":"#define ISOTP_PROTOCOL_RESULT_TIMEOUT_CR `-3`","title":"define ISOTP_PROTOCOL_RESULT_TIMEOUT_CR"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_unexp_pdu","text":"#define ISOTP_PROTOCOL_RESULT_UNEXP_PDU `-6`","title":"define ISOTP_PROTOCOL_RESULT_UNEXP_PDU"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_wft_ovrn","text":"#define ISOTP_PROTOCOL_RESULT_WFT_OVRN `-7`","title":"define ISOTP_PROTOCOL_RESULT_WFT_OVRN"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_wrong_sn","text":"#define ISOTP_PROTOCOL_RESULT_WRONG_SN `-4`","title":"define ISOTP_PROTOCOL_RESULT_WRONG_SN"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_error","text":"#define ISOTP_RET_ERROR `-1`","title":"define ISOTP_RET_ERROR"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_inprogress","text":"#define ISOTP_RET_INPROGRESS `-2`","title":"define ISOTP_RET_INPROGRESS"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_length","text":"#define ISOTP_RET_LENGTH `-7`","title":"define ISOTP_RET_LENGTH"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_nospace","text":"#define ISOTP_RET_NOSPACE `-8`","title":"define ISOTP_RET_NOSPACE"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_no_data","text":"#define ISOTP_RET_NO_DATA `-5`","title":"define ISOTP_RET_NO_DATA"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_ok","text":"Internal return codes. #define ISOTP_RET_OK `0`","title":"define ISOTP_RET_OK"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_overflow","text":"#define ISOTP_RET_OVERFLOW `-3`","title":"define ISOTP_RET_OVERFLOW"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_timeout","text":"#define ISOTP_RET_TIMEOUT `-6`","title":"define ISOTP_RET_TIMEOUT"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_wrong_sn","text":"#define ISOTP_RET_WRONG_SN `-4`","title":"define ISOTP_RET_WRONG_SN"},{"location":"docs/isotp__defines_8h/#define-isotptimeafter","text":"Returns true if time a is after time b . #define IsoTpTimeAfter ( a , b ) ` (( int32_t ) (( int32_t ) ( b ) - ( int32_t ) ( a )) < 0 ) `","title":"define IsoTpTimeAfter"},{"location":"docs/isotp__defines_8h/#define-le32toh","text":"Compiler-specific defines. #define LE32TOH ( le ) ` /* multi line expression */ ` OS-specific defines. Convert a 32-bit value from little-endian to host byte order. The documentation for this class was generated from the following file inc/isotp_defines.h","title":"define LE32TOH"},{"location":"docs/isotp__defines_8h_source/","text":"File isotp_defines.h \u00b6 File List > inc > isotp_defines.h Go to the documentation of this file #ifndef ISOTPC_USER_DEFINITIONS_H #define ISOTPC_USER_DEFINITIONS_H #include <stdint.h> #ifdef __GNUC__ #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ #define ISOTP_BYTE_ORDER_LITTLE_ENDIAN #elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ #else #error \"unsupported byte ordering\" #endif #define ISOTP_PACKED_STRUCT(content) typedef struct __attribute__((packed)) content #endif #ifdef _MSC_VER #define ISOTP_PACKED_STRUCT(content) \\ __pragma(pack(push, 1)) typedef struct content __pragma(pack(pop)) #define snprintf _snprintf #include <windows.h> #define ISOTP_BYTE_ORDER_LITTLE_ENDIAN #define __builtin_bswap8 _byteswap_uint8 #define __builtin_bswap16 _byteswap_uint16 #define __builtin_bswap32 _byteswap_uint32 #define __builtin_bswap64 _byteswap_uint64 #endif #define LE32TOH(le) \\ ((uint32_t) (((le) << 24) | (((le) & 0x0000FF00) << 8) | (((le) & 0x00FF0000) >> 8) \\ | ((le) >> 24))) #define ISOTP_RET_OK 0 #define ISOTP_RET_ERROR -1 #define ISOTP_RET_INPROGRESS -2 #define ISOTP_RET_OVERFLOW -3 #define ISOTP_RET_WRONG_SN -4 #define ISOTP_RET_NO_DATA -5 #define ISOTP_RET_TIMEOUT -6 #define ISOTP_RET_LENGTH -7 #define ISOTP_RET_NOSPACE -8 #define IsoTpTimeAfter(a, b) ((int32_t) ((int32_t) (b) - (int32_t) (a)) < 0) #define ISOTP_INVALID_BS 0xFFFF #define ISOTP_MAX_ERROR_MSG_SIZE 128 typedef enum { ISOTP_SEND_STATUS_IDLE , ISOTP_SEND_STATUS_INPROGRESS , ISOTP_SEND_STATUS_ERROR , } IsoTpSendStatusTypes ; typedef enum { ISOTP_RECEIVE_STATUS_IDLE , ISOTP_RECEIVE_STATUS_INPROGRESS , ISOTP_RECEIVE_STATUS_FULL , } IsoTpReceiveStatusTypes ; #if defined(ISOTP_BYTE_ORDER_LITTLE_ENDIAN) typedef struct { uint8_t reserve_1 : 4 ; uint8_t type : 4 ; uint8_t reserve_2 [ 7 ]; } IsoTpPciType ; typedef struct { uint8_t SF_DL : 4 ; uint8_t type : 4 ; uint8_t data [ 7 ]; } IsoTpSingleFrame ; typedef struct { uint8_t FF_DL_high : 4 ; uint8_t type : 4 ; uint8_t FF_DL_low ; uint8_t data [ 6 ]; } IsoTpFirstFrameShort ; ISOTP_PACKED_STRUCT ({ uint8_t set_to_zero_high : 4 ; uint8_t type : 4 ; uint8_t set_to_zero_low ; uint32_t FF_DL ; uint8_t data [ 2 ]; } IsoTpFirstFrameLong ); typedef struct { uint8_t SN : 4 ; uint8_t type : 4 ; uint8_t data [ 7 ]; } IsoTpConsecutiveFrame ; typedef struct { uint8_t FS : 4 ; uint8_t type : 4 ; uint8_t BS ; uint8_t STmin ; uint8_t reserve [ 5 ]; } IsoTpFlowControl ; #else typedef struct { uint8_t type : 4 ; uint8_t reserve_1 : 4 ; uint8_t reserve_2 [ 7 ]; } IsoTpPciType ; typedef struct { uint8_t type : 4 ; uint8_t SF_DL : 4 ; uint8_t data [ 7 ]; } IsoTpSingleFrame ; typedef struct { uint8_t FF_DL_high : 4 ; uint8_t type : 4 ; uint8_t FF_DL_low ; uint8_t data [ 6 ]; } IsoTpFirstFrameShort ; ISOTP_PACKED_STRUCT ({ uint8_t set_to_zero_high : 4 ; uint8_t type : 4 ; uint8_t set_to_zero_low ; uint32_t FF_DL ; uint8_t data [ 2 ]; } IsoTpFirstFrameLong ); typedef struct { uint8_t type : 4 ; uint8_t SN : 4 ; uint8_t data [ 7 ]; } IsoTpConsecutiveFrame ; typedef struct { uint8_t type : 4 ; uint8_t FS : 4 ; uint8_t BS ; uint8_t STmin ; uint8_t reserve [ 5 ]; } IsoTpFlowControl ; #endif typedef struct { uint8_t ptr [ 8 ]; } IsoTpDataArray ; typedef struct { union { IsoTpPciType common ; IsoTpSingleFrame single_frame ; IsoTpFirstFrameShort first_frame_short ; IsoTpFirstFrameLong first_frame_long ; IsoTpConsecutiveFrame consecutive_frame ; IsoTpFlowControl flow_control ; IsoTpDataArray data_array ; } as ; } IsoTpCanMessage ; #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK typedef void ( * isotp_tx_done_cb )( void * link , uint32_t tx_size , void * user_arg ); #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK typedef void ( * isotp_rx_done_cb )( void * link , const uint8_t * data , uint32_t size , void * user_arg ); #endif typedef enum { ISOTP_PCI_TYPE_SINGLE = 0x0 , ISOTP_PCI_TYPE_FIRST_FRAME = 0x1 , TSOTP_PCI_TYPE_CONSECUTIVE_FRAME = 0x2 , ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME = 0x3 , ISOTP_PCI_TYPE_CONSECUTIVE_FRAME = 0x2 , } IsoTpProtocolControlInformation ; typedef enum { PCI_FLOW_STATUS_CONTINUE = 0x0 , PCI_FLOW_STATUS_WAIT = 0x1 , PCI_FLOW_STATUS_OVERFLOW = 0x2 } IsoTpFlowStatus ; #define ISOTP_PROTOCOL_RESULT_OK 0 #define ISOTP_PROTOCOL_RESULT_TIMEOUT_A -1 #define ISOTP_PROTOCOL_RESULT_TIMEOUT_BS -2 #define ISOTP_PROTOCOL_RESULT_TIMEOUT_CR -3 #define ISOTP_PROTOCOL_RESULT_WRONG_SN -4 #define ISOTP_PROTOCOL_RESULT_INVALID_FS -5 #define ISOTP_PROTOCOL_RESULT_UNEXP_PDU -6 #define ISOTP_PROTOCOL_RESULT_WFT_OVRN -7 #define ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW -8 #define ISOTP_PROTOCOL_RESULT_ERROR -9 #endif /* ISOTPC_USER_DEFINITIONS_H */","title":"File isotp_defines.h"},{"location":"docs/isotp__defines_8h_source/#file-isotp_definesh","text":"File List > inc > isotp_defines.h Go to the documentation of this file #ifndef ISOTPC_USER_DEFINITIONS_H #define ISOTPC_USER_DEFINITIONS_H #include <stdint.h> #ifdef __GNUC__ #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ #define ISOTP_BYTE_ORDER_LITTLE_ENDIAN #elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ #else #error \"unsupported byte ordering\" #endif #define ISOTP_PACKED_STRUCT(content) typedef struct __attribute__((packed)) content #endif #ifdef _MSC_VER #define ISOTP_PACKED_STRUCT(content) \\ __pragma(pack(push, 1)) typedef struct content __pragma(pack(pop)) #define snprintf _snprintf #include <windows.h> #define ISOTP_BYTE_ORDER_LITTLE_ENDIAN #define __builtin_bswap8 _byteswap_uint8 #define __builtin_bswap16 _byteswap_uint16 #define __builtin_bswap32 _byteswap_uint32 #define __builtin_bswap64 _byteswap_uint64 #endif #define LE32TOH(le) \\ ((uint32_t) (((le) << 24) | (((le) & 0x0000FF00) << 8) | (((le) & 0x00FF0000) >> 8) \\ | ((le) >> 24))) #define ISOTP_RET_OK 0 #define ISOTP_RET_ERROR -1 #define ISOTP_RET_INPROGRESS -2 #define ISOTP_RET_OVERFLOW -3 #define ISOTP_RET_WRONG_SN -4 #define ISOTP_RET_NO_DATA -5 #define ISOTP_RET_TIMEOUT -6 #define ISOTP_RET_LENGTH -7 #define ISOTP_RET_NOSPACE -8 #define IsoTpTimeAfter(a, b) ((int32_t) ((int32_t) (b) - (int32_t) (a)) < 0) #define ISOTP_INVALID_BS 0xFFFF #define ISOTP_MAX_ERROR_MSG_SIZE 128 typedef enum { ISOTP_SEND_STATUS_IDLE , ISOTP_SEND_STATUS_INPROGRESS , ISOTP_SEND_STATUS_ERROR , } IsoTpSendStatusTypes ; typedef enum { ISOTP_RECEIVE_STATUS_IDLE , ISOTP_RECEIVE_STATUS_INPROGRESS , ISOTP_RECEIVE_STATUS_FULL , } IsoTpReceiveStatusTypes ; #if defined(ISOTP_BYTE_ORDER_LITTLE_ENDIAN) typedef struct { uint8_t reserve_1 : 4 ; uint8_t type : 4 ; uint8_t reserve_2 [ 7 ]; } IsoTpPciType ; typedef struct { uint8_t SF_DL : 4 ; uint8_t type : 4 ; uint8_t data [ 7 ]; } IsoTpSingleFrame ; typedef struct { uint8_t FF_DL_high : 4 ; uint8_t type : 4 ; uint8_t FF_DL_low ; uint8_t data [ 6 ]; } IsoTpFirstFrameShort ; ISOTP_PACKED_STRUCT ({ uint8_t set_to_zero_high : 4 ; uint8_t type : 4 ; uint8_t set_to_zero_low ; uint32_t FF_DL ; uint8_t data [ 2 ]; } IsoTpFirstFrameLong ); typedef struct { uint8_t SN : 4 ; uint8_t type : 4 ; uint8_t data [ 7 ]; } IsoTpConsecutiveFrame ; typedef struct { uint8_t FS : 4 ; uint8_t type : 4 ; uint8_t BS ; uint8_t STmin ; uint8_t reserve [ 5 ]; } IsoTpFlowControl ; #else typedef struct { uint8_t type : 4 ; uint8_t reserve_1 : 4 ; uint8_t reserve_2 [ 7 ]; } IsoTpPciType ; typedef struct { uint8_t type : 4 ; uint8_t SF_DL : 4 ; uint8_t data [ 7 ]; } IsoTpSingleFrame ; typedef struct { uint8_t FF_DL_high : 4 ; uint8_t type : 4 ; uint8_t FF_DL_low ; uint8_t data [ 6 ]; } IsoTpFirstFrameShort ; ISOTP_PACKED_STRUCT ({ uint8_t set_to_zero_high : 4 ; uint8_t type : 4 ; uint8_t set_to_zero_low ; uint32_t FF_DL ; uint8_t data [ 2 ]; } IsoTpFirstFrameLong ); typedef struct { uint8_t type : 4 ; uint8_t SN : 4 ; uint8_t data [ 7 ]; } IsoTpConsecutiveFrame ; typedef struct { uint8_t type : 4 ; uint8_t FS : 4 ; uint8_t BS ; uint8_t STmin ; uint8_t reserve [ 5 ]; } IsoTpFlowControl ; #endif typedef struct { uint8_t ptr [ 8 ]; } IsoTpDataArray ; typedef struct { union { IsoTpPciType common ; IsoTpSingleFrame single_frame ; IsoTpFirstFrameShort first_frame_short ; IsoTpFirstFrameLong first_frame_long ; IsoTpConsecutiveFrame consecutive_frame ; IsoTpFlowControl flow_control ; IsoTpDataArray data_array ; } as ; } IsoTpCanMessage ; #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK typedef void ( * isotp_tx_done_cb )( void * link , uint32_t tx_size , void * user_arg ); #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK typedef void ( * isotp_rx_done_cb )( void * link , const uint8_t * data , uint32_t size , void * user_arg ); #endif typedef enum { ISOTP_PCI_TYPE_SINGLE = 0x0 , ISOTP_PCI_TYPE_FIRST_FRAME = 0x1 , TSOTP_PCI_TYPE_CONSECUTIVE_FRAME = 0x2 , ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME = 0x3 , ISOTP_PCI_TYPE_CONSECUTIVE_FRAME = 0x2 , } IsoTpProtocolControlInformation ; typedef enum { PCI_FLOW_STATUS_CONTINUE = 0x0 , PCI_FLOW_STATUS_WAIT = 0x1 , PCI_FLOW_STATUS_OVERFLOW = 0x2 } IsoTpFlowStatus ; #define ISOTP_PROTOCOL_RESULT_OK 0 #define ISOTP_PROTOCOL_RESULT_TIMEOUT_A -1 #define ISOTP_PROTOCOL_RESULT_TIMEOUT_BS -2 #define ISOTP_PROTOCOL_RESULT_TIMEOUT_CR -3 #define ISOTP_PROTOCOL_RESULT_WRONG_SN -4 #define ISOTP_PROTOCOL_RESULT_INVALID_FS -5 #define ISOTP_PROTOCOL_RESULT_UNEXP_PDU -6 #define ISOTP_PROTOCOL_RESULT_WFT_OVRN -7 #define ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW -8 #define ISOTP_PROTOCOL_RESULT_ERROR -9 #endif /* ISOTPC_USER_DEFINITIONS_H */","title":"File isotp_defines.h"},{"location":"docs/isotp__user_8h/","text":"File isotp_user.h \u00b6 FileList > inc > isotp_user.h Go to the source code of this file User callback interfaces and platform abstraction layer. More... #include <stdint.h> Detailed Description \u00b6 Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization Author: Anton Vynohradov Email: avynohradov@systemfromscratch.com Copyright: Copyright (c) 2026 Anton Vynohradov @license MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. SPDX-License-Identifier: MIT The documentation for this class was generated from the following file inc/isotp_user.h","title":"File isotp_user.h"},{"location":"docs/isotp__user_8h/#file-isotp_userh","text":"FileList > inc > isotp_user.h Go to the source code of this file User callback interfaces and platform abstraction layer. More... #include <stdint.h>","title":"File isotp_user.h"},{"location":"docs/isotp__user_8h/#detailed-description","text":"Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization Author: Anton Vynohradov Email: avynohradov@systemfromscratch.com Copyright: Copyright (c) 2026 Anton Vynohradov @license MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. SPDX-License-Identifier: MIT The documentation for this class was generated from the following file inc/isotp_user.h","title":"Detailed Description"},{"location":"docs/isotp__user_8h_source/","text":"File isotp_user.h \u00b6 File List > inc > isotp_user.h Go to the documentation of this file #ifndef ISOTPC_USER_H #define ISOTPC_USER_H #include <stdint.h> #ifdef __cplusplus extern \"C\" { #endif void isotp_user_debug ( const char * message , ...); int isotp_user_send_can ( const uint32_t arbitration_id , const uint8_t * data , const uint8_t size #ifdef ISO_TP_USER_SEND_CAN_ARG , void * arg #endif ); uint32_t isotp_user_get_us ( void ); #ifdef __cplusplus } #endif #endif /* ISOTPC_USER_H */","title":"File isotp_user.h"},{"location":"docs/isotp__user_8h_source/#file-isotp_userh","text":"File List > inc > isotp_user.h Go to the documentation of this file #ifndef ISOTPC_USER_H #define ISOTPC_USER_H #include <stdint.h> #ifdef __cplusplus extern \"C\" { #endif void isotp_user_debug ( const char * message , ...); int isotp_user_send_can ( const uint32_t arbitration_id , const uint8_t * data , const uint8_t size #ifdef ISO_TP_USER_SEND_CAN_ARG , void * arg #endif ); uint32_t isotp_user_get_us ( void ); #ifdef __cplusplus } #endif #endif /* ISOTPC_USER_H */","title":"File isotp_user.h"},{"location":"docs/isotp_8h/","text":"File isotp.h \u00b6 FileList > isotp.h Go to the source code of this file Core ISO-TP protocol API with link management and message handling. More... #include <stdint.h> #include <stdbool.h> #include <stddef.h> #include <stdio.h> #include <string.h> #include \"isotp_config.h\" #include \"isotp_defines.h\" #include \"isotp_user.h\" Classes \u00b6 Type Name struct IsoTpLink Link state for a single ISO-TP connection. Detailed Description \u00b6 Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization Author: Anton Vynohradov Email: avynohradov@systemfromscratch.com Copyright: Copyright (c) 2026 Anton Vynohradov @license MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. SPDX-License-Identifier: MIT The documentation for this class was generated from the following file isotp.h","title":"File isotp.h"},{"location":"docs/isotp_8h/#file-isotph","text":"FileList > isotp.h Go to the source code of this file Core ISO-TP protocol API with link management and message handling. More... #include <stdint.h> #include <stdbool.h> #include <stddef.h> #include <stdio.h> #include <string.h> #include \"isotp_config.h\" #include \"isotp_defines.h\" #include \"isotp_user.h\"","title":"File isotp.h"},{"location":"docs/isotp_8h/#classes","text":"Type Name struct IsoTpLink Link state for a single ISO-TP connection.","title":"Classes"},{"location":"docs/isotp_8h/#detailed-description","text":"Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization Author: Anton Vynohradov Email: avynohradov@systemfromscratch.com Copyright: Copyright (c) 2026 Anton Vynohradov @license MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. SPDX-License-Identifier: MIT The documentation for this class was generated from the following file isotp.h","title":"Detailed Description"},{"location":"docs/isotp_8h_source/","text":"File isotp.h \u00b6 File List > isotp.h Go to the documentation of this file #ifndef ISOTPC_H #define ISOTPC_H #include <stdint.h> #include <stdbool.h> #include <stddef.h> #include <stdio.h> #include <string.h> #ifdef __cplusplus extern \"C\" { #endif #include \"isotp_config.h\" #include \"isotp_defines.h\" #include \"isotp_user.h\" typedef struct IsoTpLink { /* sender parameters */ uint32_t send_arbitration_id ; /* message buffer */ uint8_t * send_buffer ; uint32_t send_buf_size ; uint32_t send_size ; uint32_t send_offset ; /* multi-frame flags */ uint8_t send_sn ; uint32_t send_bs_remain ; uint32_t send_st_min_us ; uint8_t send_wtf_count ; uint32_t send_timer_st ; uint32_t send_timer_bs ; int32_t send_protocol_result ; uint8_t send_status ; /* receiver parameters */ uint32_t receive_arbitration_id ; /* message buffer */ uint8_t * receive_buffer ; uint32_t receive_buf_size ; uint32_t receive_size ; uint32_t receive_offset ; /* multi-frame control */ uint8_t receive_sn ; uint8_t receive_bs_count ; uint32_t receive_timer_cr ; int receive_protocol_result ; uint8_t receive_status ; /* timing and flow control parameters */ uint32_t param_n_bs_us ; uint32_t param_n_cr_us ; uint32_t param_st_min_us ; uint8_t param_block_size ; #if defined(ISO_TP_USER_SEND_CAN_ARG) void * user_send_can_arg ; #endif #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK isotp_tx_done_cb tx_done_cb ; void * tx_done_cb_arg ; #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK isotp_rx_done_cb rx_done_cb ; void * rx_done_cb_arg ; #endif } IsoTpLink ; void isotp_init_link ( IsoTpLink * link , uint32_t sendid , uint8_t * sendbuf , uint32_t sendbufsize , uint8_t * recvbuf , uint32_t recvbufsize ); void isotp_destroy_link ( IsoTpLink * link ); void isotp_poll ( IsoTpLink * link ); void isotp_on_can_message ( IsoTpLink * link , const uint8_t * data , uint8_t len ); int isotp_send ( IsoTpLink * link , const uint8_t payload [], uint32_t size ); int isotp_send_with_id ( IsoTpLink * link , uint32_t id , const uint8_t payload [], uint32_t size ); int isotp_receive ( IsoTpLink * link , uint8_t * payload , const uint32_t payload_size , uint32_t * out_size ); void isotp_set_timeouts ( IsoTpLink * link , uint32_t n_bs_us , uint32_t n_cr_us ); void isotp_set_fc_params ( IsoTpLink * link , uint8_t block_size , uint32_t st_min_us ); #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK void isotp_set_tx_done_cb ( IsoTpLink * link , isotp_tx_done_cb cb , void * arg ); #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK void isotp_set_rx_done_cb ( IsoTpLink * link , isotp_rx_done_cb cb , void * arg ); #endif #ifdef __cplusplus } #endif #endif /* ISOTPC_H */","title":"File isotp.h"},{"location":"docs/isotp_8h_source/#file-isotph","text":"File List > isotp.h Go to the documentation of this file #ifndef ISOTPC_H #define ISOTPC_H #include <stdint.h> #include <stdbool.h> #include <stddef.h> #include <stdio.h> #include <string.h> #ifdef __cplusplus extern \"C\" { #endif #include \"isotp_config.h\" #include \"isotp_defines.h\" #include \"isotp_user.h\" typedef struct IsoTpLink { /* sender parameters */ uint32_t send_arbitration_id ; /* message buffer */ uint8_t * send_buffer ; uint32_t send_buf_size ; uint32_t send_size ; uint32_t send_offset ; /* multi-frame flags */ uint8_t send_sn ; uint32_t send_bs_remain ; uint32_t send_st_min_us ; uint8_t send_wtf_count ; uint32_t send_timer_st ; uint32_t send_timer_bs ; int32_t send_protocol_result ; uint8_t send_status ; /* receiver parameters */ uint32_t receive_arbitration_id ; /* message buffer */ uint8_t * receive_buffer ; uint32_t receive_buf_size ; uint32_t receive_size ; uint32_t receive_offset ; /* multi-frame control */ uint8_t receive_sn ; uint8_t receive_bs_count ; uint32_t receive_timer_cr ; int receive_protocol_result ; uint8_t receive_status ; /* timing and flow control parameters */ uint32_t param_n_bs_us ; uint32_t param_n_cr_us ; uint32_t param_st_min_us ; uint8_t param_block_size ; #if defined(ISO_TP_USER_SEND_CAN_ARG) void * user_send_can_arg ; #endif #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK isotp_tx_done_cb tx_done_cb ; void * tx_done_cb_arg ; #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK isotp_rx_done_cb rx_done_cb ; void * rx_done_cb_arg ; #endif } IsoTpLink ; void isotp_init_link ( IsoTpLink * link , uint32_t sendid , uint8_t * sendbuf , uint32_t sendbufsize , uint8_t * recvbuf , uint32_t recvbufsize ); void isotp_destroy_link ( IsoTpLink * link ); void isotp_poll ( IsoTpLink * link ); void isotp_on_can_message ( IsoTpLink * link , const uint8_t * data , uint8_t len ); int isotp_send ( IsoTpLink * link , const uint8_t payload [], uint32_t size ); int isotp_send_with_id ( IsoTpLink * link , uint32_t id , const uint8_t payload [], uint32_t size ); int isotp_receive ( IsoTpLink * link , uint8_t * payload , const uint32_t payload_size , uint32_t * out_size ); void isotp_set_timeouts ( IsoTpLink * link , uint32_t n_bs_us , uint32_t n_cr_us ); void isotp_set_fc_params ( IsoTpLink * link , uint8_t block_size , uint32_t st_min_us ); #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK void isotp_set_tx_done_cb ( IsoTpLink * link , isotp_tx_done_cb cb , void * arg ); #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK void isotp_set_rx_done_cb ( IsoTpLink * link , isotp_rx_done_cb cb , void * arg ); #endif #ifdef __cplusplus } #endif #endif /* ISOTPC_H */","title":"File isotp.h"},{"location":"docs/dir_68267d1309a1af8e8297ef4c3efbcdba/","text":"Dir src \u00b6 FileList > src Files \u00b6 Type Name file isotp.c The documentation for this class was generated from the following file src/","title":"Dir src"},{"location":"docs/dir_68267d1309a1af8e8297ef4c3efbcdba/#dir-src","text":"FileList > src","title":"Dir src"},{"location":"docs/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","text":"Type Name file isotp.c The documentation for this class was generated from the following file src/","title":"Files"},{"location":"docs/isotp_8c/","text":"File isotp.c \u00b6 FileList > src > isotp.c Go to the source code of this file #include <assert.h> #include <stdint.h> #include \"isotp.h\" Public Static Functions \u00b6 Type Name int isotp_receive_consecutive_frame ( IsoTpLink * link, const IsoTpCanMessage * message, uint8_t len) Receive ISO-TP consecutive frame. int isotp_receive_first_frame ( IsoTpLink * link, IsoTpCanMessage * message, uint8_t len) Receive ISO-TP first frame of multi-frame message. int isotp_receive_flow_control_frame ( IsoTpLink * link, IsoTpCanMessage * message, uint8_t len) Receive ISO-TP flow control frame. int isotp_receive_single_frame ( IsoTpLink * link, const IsoTpCanMessage * message, uint8_t len) Receive ISO-TP single frame. int isotp_send_consecutive_frame ( IsoTpLink * link) Send ISO-TP consecutive frame. int isotp_send_first_frame ( IsoTpLink * link, uint32_t id) Send ISO-TP first frame of multi-frame message. int isotp_send_flow_control (const IsoTpLink * link, uint8_t flow_status, uint8_t block_size, uint32_t st_min_us) Send ISO-TP flow control frame. int isotp_send_single_frame (const IsoTpLink * link, uint32_t id) Send ISO-TP single frame. uint32_t isotp_st_min_to_us (uint8_t st_min) Convert ST_min encoding format to microseconds. uint8_t isotp_us_to_st_min (uint32_t us) Convert microseconds to ST_min encoding format. Public Static Functions Documentation \u00b6 function isotp_receive_consecutive_frame \u00b6 Receive ISO-TP consecutive frame. static int isotp_receive_consecutive_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ) Parameters: link - ISO-TP link instance message - Received CAN message len - Message length in bytes Returns: ISOTP_RET_OK on success, error code on failure function isotp_receive_first_frame \u00b6 Receive ISO-TP first frame of multi-frame message. static int isotp_receive_first_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ) Parameters: link - ISO-TP link instance message - Received CAN message len - Message length in bytes Returns: ISOTP_RET_OK on success, error code on failure function isotp_receive_flow_control_frame \u00b6 Receive ISO-TP flow control frame. static int isotp_receive_flow_control_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ) Parameters: link - ISO-TP link instance message - Received CAN message len - Message length in bytes Returns: ISOTP_RET_OK on success, error code on failure function isotp_receive_single_frame \u00b6 Receive ISO-TP single frame. static int isotp_receive_single_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ) Parameters: link - ISO-TP link instance message - Received CAN message len - Message length in bytes Returns: ISOTP_RET_OK on success, error code on failure function isotp_send_consecutive_frame \u00b6 Send ISO-TP consecutive frame. static int isotp_send_consecutive_frame ( IsoTpLink * link ) Parameters: link - ISO-TP link instance Returns: ISOTP_RET_OK on success, error code on failure function isotp_send_first_frame \u00b6 Send ISO-TP first frame of multi-frame message. static int isotp_send_first_frame ( IsoTpLink * link , uint32_t id ) Parameters: link - ISO-TP link instance id - CAN arbitration ID Returns: ISOTP_RET_OK on success, error code on failure function isotp_send_flow_control \u00b6 Send ISO-TP flow control frame. static int isotp_send_flow_control ( const IsoTpLink * link , uint8_t flow_status , uint8_t block_size , uint32_t st_min_us ) Parameters: link - ISO-TP link instance flow_status - Flow control status block_size - Block size for flow control st_min_us - Minimum separation time in microseconds Returns: ISOTP_RET_OK on success, error code on failure function isotp_send_single_frame \u00b6 Send ISO-TP single frame. static int isotp_send_single_frame ( const IsoTpLink * link , uint32_t id ) Parameters: link - ISO-TP link instance id - CAN arbitration ID Returns: ISOTP_RET_OK on success, error code on failure function isotp_st_min_to_us \u00b6 Convert ST_min encoding format to microseconds. static uint32_t isotp_st_min_to_us ( uint8_t st_min ) Parameters: st_min - Encoded ST_min value Returns: Time in microseconds function isotp_us_to_st_min \u00b6 Convert microseconds to ST_min encoding format. static uint8_t isotp_us_to_st_min ( uint32_t us ) Parameters: us - Time in microseconds Returns: Encoded ST_min value The documentation for this class was generated from the following file src/isotp.c","title":"File isotp.c"},{"location":"docs/isotp_8c/#file-isotpc","text":"FileList > src > isotp.c Go to the source code of this file #include <assert.h> #include <stdint.h> #include \"isotp.h\"","title":"File isotp.c"},{"location":"docs/isotp_8c/#public-static-functions","text":"Type Name int isotp_receive_consecutive_frame ( IsoTpLink * link, const IsoTpCanMessage * message, uint8_t len) Receive ISO-TP consecutive frame. int isotp_receive_first_frame ( IsoTpLink * link, IsoTpCanMessage * message, uint8_t len) Receive ISO-TP first frame of multi-frame message. int isotp_receive_flow_control_frame ( IsoTpLink * link, IsoTpCanMessage * message, uint8_t len) Receive ISO-TP flow control frame. int isotp_receive_single_frame ( IsoTpLink * link, const IsoTpCanMessage * message, uint8_t len) Receive ISO-TP single frame. int isotp_send_consecutive_frame ( IsoTpLink * link) Send ISO-TP consecutive frame. int isotp_send_first_frame ( IsoTpLink * link, uint32_t id) Send ISO-TP first frame of multi-frame message. int isotp_send_flow_control (const IsoTpLink * link, uint8_t flow_status, uint8_t block_size, uint32_t st_min_us) Send ISO-TP flow control frame. int isotp_send_single_frame (const IsoTpLink * link, uint32_t id) Send ISO-TP single frame. uint32_t isotp_st_min_to_us (uint8_t st_min) Convert ST_min encoding format to microseconds. uint8_t isotp_us_to_st_min (uint32_t us) Convert microseconds to ST_min encoding format.","title":"Public Static Functions"},{"location":"docs/isotp_8c/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"docs/isotp_8c/#function-isotp_receive_consecutive_frame","text":"Receive ISO-TP consecutive frame. static int isotp_receive_consecutive_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ) Parameters: link - ISO-TP link instance message - Received CAN message len - Message length in bytes Returns: ISOTP_RET_OK on success, error code on failure","title":"function isotp_receive_consecutive_frame"},{"location":"docs/isotp_8c/#function-isotp_receive_first_frame","text":"Receive ISO-TP first frame of multi-frame message. static int isotp_receive_first_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ) Parameters: link - ISO-TP link instance message - Received CAN message len - Message length in bytes Returns: ISOTP_RET_OK on success, error code on failure","title":"function isotp_receive_first_frame"},{"location":"docs/isotp_8c/#function-isotp_receive_flow_control_frame","text":"Receive ISO-TP flow control frame. static int isotp_receive_flow_control_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ) Parameters: link - ISO-TP link instance message - Received CAN message len - Message length in bytes Returns: ISOTP_RET_OK on success, error code on failure","title":"function isotp_receive_flow_control_frame"},{"location":"docs/isotp_8c/#function-isotp_receive_single_frame","text":"Receive ISO-TP single frame. static int isotp_receive_single_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ) Parameters: link - ISO-TP link instance message - Received CAN message len - Message length in bytes Returns: ISOTP_RET_OK on success, error code on failure","title":"function isotp_receive_single_frame"},{"location":"docs/isotp_8c/#function-isotp_send_consecutive_frame","text":"Send ISO-TP consecutive frame. static int isotp_send_consecutive_frame ( IsoTpLink * link ) Parameters: link - ISO-TP link instance Returns: ISOTP_RET_OK on success, error code on failure","title":"function isotp_send_consecutive_frame"},{"location":"docs/isotp_8c/#function-isotp_send_first_frame","text":"Send ISO-TP first frame of multi-frame message. static int isotp_send_first_frame ( IsoTpLink * link , uint32_t id ) Parameters: link - ISO-TP link instance id - CAN arbitration ID Returns: ISOTP_RET_OK on success, error code on failure","title":"function isotp_send_first_frame"},{"location":"docs/isotp_8c/#function-isotp_send_flow_control","text":"Send ISO-TP flow control frame. static int isotp_send_flow_control ( const IsoTpLink * link , uint8_t flow_status , uint8_t block_size , uint32_t st_min_us ) Parameters: link - ISO-TP link instance flow_status - Flow control status block_size - Block size for flow control st_min_us - Minimum separation time in microseconds Returns: ISOTP_RET_OK on success, error code on failure","title":"function isotp_send_flow_control"},{"location":"docs/isotp_8c/#function-isotp_send_single_frame","text":"Send ISO-TP single frame. static int isotp_send_single_frame ( const IsoTpLink * link , uint32_t id ) Parameters: link - ISO-TP link instance id - CAN arbitration ID Returns: ISOTP_RET_OK on success, error code on failure","title":"function isotp_send_single_frame"},{"location":"docs/isotp_8c/#function-isotp_st_min_to_us","text":"Convert ST_min encoding format to microseconds. static uint32_t isotp_st_min_to_us ( uint8_t st_min ) Parameters: st_min - Encoded ST_min value Returns: Time in microseconds","title":"function isotp_st_min_to_us"},{"location":"docs/isotp_8c/#function-isotp_us_to_st_min","text":"Convert microseconds to ST_min encoding format. static uint8_t isotp_us_to_st_min ( uint32_t us ) Parameters: us - Time in microseconds Returns: Encoded ST_min value The documentation for this class was generated from the following file src/isotp.c","title":"function isotp_us_to_st_min"},{"location":"docs/isotp_8c_source/","text":"File isotp.c \u00b6 File List > src > isotp.c Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Core ISO-TP protocol implementation with multi-frame support * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <assert.h> #include <stdint.h> #include \"isotp.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ static uint8_t isotp_us_to_st_min ( uint32_t us ); static uint32_t isotp_st_min_to_us ( uint8_t st_min ); static int isotp_send_flow_control ( const IsoTpLink * link , uint8_t flow_status , uint8_t block_size , uint32_t st_min_us ); static int isotp_send_single_frame ( const IsoTpLink * link , uint32_t id ); static int isotp_send_first_frame ( IsoTpLink * link , uint32_t id ); static int isotp_send_consecutive_frame ( IsoTpLink * link ); static int isotp_receive_single_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ); static int isotp_receive_first_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ); static int isotp_receive_consecutive_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ); static int isotp_receive_flow_control_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ); /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* st_min to microsecond */ static uint8_t isotp_us_to_st_min ( uint32_t us ) { // ISO 15765-2:2016 defines STmin encoding: // 0x00..0x7F: value in milliseconds (0..127 ms) // 0xF1..0xF9: value in 100 microsecond steps (100..900 us) const uint32_t STMIN_MS_MAX = 127000 ; // 127 ms in us const uint32_t STMIN_US_MIN = 100 ; // 100 us const uint32_t STMIN_US_MAX = 900 ; // 900 us const uint8_t STMIN_US_BASE = 0xF0 ; // base for 100us steps if ( us <= STMIN_MS_MAX ) { if ( us >= STMIN_US_MIN && us <= STMIN_US_MAX ) { return ( uint8_t ) ( STMIN_US_BASE + ( us / 100 )); } else { return ( uint8_t ) ( us / 1000u ); } } return 0 ; } /* st_min to usec */ static uint32_t isotp_st_min_to_us ( uint8_t st_min ) { // ISO 15765-2:2016 defines STmin encoding: // 0x00..0x7F: value in milliseconds (0..127 ms) // 0xF1..0xF9: value in 100 microsecond steps (100..900 us) const uint8_t STMIN_MS_MAX = 0x7F ; // 127 ms const uint8_t STMIN_US_MIN_CODE = 0xF1 ; // 100 us const uint8_t STMIN_US_MAX_CODE = 0xF9 ; // 900 us const uint8_t STMIN_US_BASE = 0xF0 ; // base for 100us steps const uint32_t US_PER_MS = 1000 ; const uint32_t US_STEP = 100 ; if ( st_min <= STMIN_MS_MAX ) { return st_min * US_PER_MS ; } else if ( st_min >= STMIN_US_MIN_CODE && st_min <= STMIN_US_MAX_CODE ) { return ( st_min - STMIN_US_BASE ) * US_STEP ; } return 0 ; } static int isotp_send_flow_control ( const IsoTpLink * link , uint8_t flow_status , uint8_t block_size , uint32_t st_min_us ) { IsoTpCanMessage message ; ( void ) memset ( & message , 0 , sizeof ( message )); int ret ; uint8_t size = 0 ; /* setup message */ message . as . flow_control . type = ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME ; message . as . flow_control . FS = flow_status ; message . as . flow_control . BS = block_size ; message . as . flow_control . STmin = isotp_us_to_st_min ( st_min_us ); /* send message */ #ifdef ISO_TP_FRAME_PADDING ( void ) memset ( message . as . flow_control . reserve , ISO_TP_FRAME_PADDING_VALUE , sizeof ( message . as . flow_control . reserve )); size = sizeof ( message ); #else size = 3 ; #endif ret = isotp_user_send_can ( link -> send_arbitration_id , message . as . data_array . ptr , size #if defined(ISO_TP_USER_SEND_CAN_ARG) , link -> user_send_can_arg #endif ); return ret ; } static int isotp_send_single_frame ( const IsoTpLink * link , uint32_t id ) { ( void ) id ; // Prevent unused variable warning IsoTpCanMessage message ; int ret ; uint8_t size = 0 ; /* multi frame message length must greater than 7 */ assert ( link -> send_size <= 7 ); /* setup message */ message . as . single_frame . type = ISOTP_PCI_TYPE_SINGLE ; message . as . single_frame . SF_DL = ( uint8_t ) link -> send_size ; ( void ) memcpy ( message . as . single_frame . data , link -> send_buffer , link -> send_size ); /* send message */ #ifdef ISO_TP_FRAME_PADDING ( void ) memset ( message . as . single_frame . data + link -> send_size , ISO_TP_FRAME_PADDING_VALUE , sizeof ( message . as . single_frame . data ) - link -> send_size ); size = sizeof ( message ); #else size = link -> send_size + ( uint8_t ) 1 ; #endif ret = isotp_user_send_can ( link -> send_arbitration_id , message . as . data_array . ptr , size #if defined(ISO_TP_USER_SEND_CAN_ARG) , link -> user_send_can_arg #endif ); return ret ; } static int isotp_send_first_frame ( IsoTpLink * link , uint32_t id ) { IsoTpCanMessage message = { 0 }; int ret = 0 ; /* multi frame message length must greater than 7 */ assert ( link -> send_size > 7 ); if ( link -> send_size <= 4095 ) { /* setup 'short' message */ message . as . first_frame_short . type = ISOTP_PCI_TYPE_FIRST_FRAME ; message . as . first_frame_short . FF_DL_low = ( uint8_t ) link -> send_size ; message . as . first_frame_short . FF_DL_high = ( uint8_t ) ( 0x0F & ( link -> send_size >> 8 )); ( void ) memcpy ( message . as . first_frame_short . data , link -> send_buffer , sizeof ( message . as . first_frame_short . data )); /* send 'short' message */ ret = isotp_user_send_can ( id , message . as . data_array . ptr , sizeof ( message ) #if defined(ISO_TP_USER_SEND_CAN_ARG) , link -> user_send_can_arg #endif ); if ( ISOTP_RET_OK == ret ) { link -> send_offset += sizeof ( message . as . first_frame_short . data ); } } else { // ISO15765-2:2016 /* setup 'long' message */ message . as . first_frame_long . set_to_zero_high = 0 ; message . as . first_frame_long . set_to_zero_low = 0 ; message . as . first_frame_long . type = ISOTP_PCI_TYPE_FIRST_FRAME ; message . as . first_frame_long . FF_DL = LE32TOH ( link -> send_size ); ( void ) memcpy ( message . as . first_frame_long . data , link -> send_buffer , sizeof ( message . as . first_frame_long . data )); /* send 'long' message */ ret = isotp_user_send_can ( id , message . as . data_array . ptr , sizeof ( message ) #if defined(ISO_TP_USER_SEND_CAN_ARG) , link -> user_send_can_arg #endif ); if ( ISOTP_RET_OK == ret ) { link -> send_offset += sizeof ( message . as . first_frame_long . data ); } } link -> send_sn = 1 ; return ret ; } static int isotp_send_consecutive_frame ( IsoTpLink * link ) { IsoTpCanMessage message ; uint32_t data_length ; int ret ; uint8_t size = 0 ; /* multi frame message length must greater than 7 */ assert ( link -> send_size > 7 ); /* setup message */ message . as . consecutive_frame . type = ISOTP_PCI_TYPE_CONSECUTIVE_FRAME ; message . as . consecutive_frame . SN = link -> send_sn ; data_length = link -> send_size - link -> send_offset ; if ( data_length > sizeof ( message . as . consecutive_frame . data )) { data_length = sizeof ( message . as . consecutive_frame . data ); } ( void ) memcpy ( message . as . consecutive_frame . data , link -> send_buffer + link -> send_offset , data_length ); /* send message */ #ifdef ISO_TP_FRAME_PADDING ( void ) memset ( message . as . consecutive_frame . data + data_length , ISO_TP_FRAME_PADDING_VALUE , sizeof ( message . as . consecutive_frame . data ) - data_length ); size = sizeof ( message ); #else size = data_length + 1 ; #endif ret = isotp_user_send_can ( link -> send_arbitration_id , message . as . data_array . ptr , size #if defined(ISO_TP_USER_SEND_CAN_ARG) , link -> user_send_can_arg #endif ); if ( ISOTP_RET_OK == ret ) { link -> send_offset += data_length ; if ( ++ ( link -> send_sn ) > 0x0F ) { link -> send_sn = 0 ; } } return ret ; } static int isotp_receive_single_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ) { /* check data length */ if (( 0 == message -> as . single_frame . SF_DL ) || ( message -> as . single_frame . SF_DL > ( len - 1 ))) { isotp_user_debug ( \"Single-frame length too small.\" ); return ISOTP_RET_LENGTH ; } /* copying data */ ( void ) memcpy ( link -> receive_buffer , message -> as . single_frame . data , message -> as . single_frame . SF_DL ); link -> receive_size = message -> as . single_frame . SF_DL ; return ISOTP_RET_OK ; } static int isotp_receive_first_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ) { uint8_t is_long_packet = 0 ; uint32_t payload_length ; if ( 8 != len ) { isotp_user_debug ( \"First frame should be 8 bytes in length.\" ); return ISOTP_RET_LENGTH ; } /* check data length */ payload_length = message -> as . first_frame_short . FF_DL_high ; payload_length = ( payload_length << 8 ) + message -> as . first_frame_short . FF_DL_low ; /* if length is ZERO we get a long message > 4095bytes of payload */ if ( payload_length == 0 ) { is_long_packet = 1 ; payload_length = LE32TOH ( message -> as . first_frame_long . FF_DL ); } /* should not use multiple frame transmition */ if ( payload_length <= 7 ) { isotp_user_debug ( \"Should not use multiple frame transmission.\" ); return ISOTP_RET_LENGTH ; } if ( payload_length > link -> receive_buf_size ) { isotp_user_debug ( \"Multi-frame response too large for receiving buffer.\" ); return ISOTP_RET_OVERFLOW ; } /* copying data */ if ( is_long_packet ) { ( void ) memcpy ( link -> receive_buffer , message -> as . first_frame_long . data , sizeof ( message -> as . first_frame_long . data )); link -> receive_offset = sizeof ( message -> as . first_frame_long . data ); } else { ( void ) memcpy ( link -> receive_buffer , message -> as . first_frame_short . data , sizeof ( message -> as . first_frame_short . data )); link -> receive_offset = sizeof ( message -> as . first_frame_short . data ); } link -> receive_size = payload_length ; link -> receive_sn = 1 ; return ISOTP_RET_OK ; } static int isotp_receive_consecutive_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ) { uint32_t remaining_bytes ; /* check sn */ if ( link -> receive_sn != message -> as . consecutive_frame . SN ) { return ISOTP_RET_WRONG_SN ; } /* check data length */ remaining_bytes = link -> receive_size - link -> receive_offset ; if ( remaining_bytes > sizeof ( message -> as . consecutive_frame . data )) { remaining_bytes = sizeof ( message -> as . consecutive_frame . data ); } if ( remaining_bytes > ( uint32_t ) ( len - 1 )) { isotp_user_debug ( \"Consecutive frame too short.\" ); return ISOTP_RET_LENGTH ; } /* copying data */ ( void ) memcpy ( link -> receive_buffer + link -> receive_offset , message -> as . consecutive_frame . data , remaining_bytes ); link -> receive_offset += remaining_bytes ; if ( ++ ( link -> receive_sn ) > 0x0F ) { link -> receive_sn = 0 ; } return ISOTP_RET_OK ; } static int isotp_receive_flow_control_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ) { /* unused args */ ( void ) link ; ( void ) message ; /* check message length */ if ( len < 3 ) { isotp_user_debug ( \"Flow control frame too short.\" ); return ISOTP_RET_LENGTH ; } return ISOTP_RET_OK ; } /* ============================================================================== * PUBLIC FUNCTION IMPLEMENTATIONS * =============================================================================*/ int isotp_send ( IsoTpLink * link , const uint8_t payload [], uint32_t size ) { return isotp_send_with_id ( link , link -> send_arbitration_id , payload , size ); } int isotp_send_with_id ( IsoTpLink * link , uint32_t id , const uint8_t payload [], uint32_t size ) { int ret ; if ( link == 0x0 ) { isotp_user_debug ( \"Link is null!\" ); return ISOTP_RET_ERROR ; } if ( size > link -> send_buf_size ) { isotp_user_debug ( \"Message size too large. Increase ISO_TP_MAX_MESSAGE_SIZE to set \" \"a larger buffer \\n \" ); char message [ ISOTP_MAX_ERROR_MSG_SIZE ] = { 0 }; int32_t writtenChars = snprintf ( & message [ 0 ], ISOTP_MAX_ERROR_MSG_SIZE , \"Attempted to send %u bytes; max size is %u! \\n \" , ( unsigned int ) size , ( unsigned int ) link -> send_buf_size ); assert ( writtenChars <= ISOTP_MAX_ERROR_MSG_SIZE ); ( void ) writtenChars ; isotp_user_debug ( message ); return ISOTP_RET_OVERFLOW ; } if ( ISOTP_SEND_STATUS_INPROGRESS == link -> send_status ) { isotp_user_debug ( \"Abort previous message, transmission in progress. \\n \" ); return ISOTP_RET_INPROGRESS ; } /* copy into local buffer */ link -> send_size = size ; link -> send_offset = 0 ; ( void ) memcpy ( link -> send_buffer , payload , size ); if ( link -> send_size < 8 ) { /* send single frame */ ret = isotp_send_single_frame ( link , id ); #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK if ( ret == ISOTP_RET_OK && link -> tx_done_cb ) { link -> tx_done_cb ( link , link -> send_size , link -> tx_done_cb_arg ); } #endif } else { /* send multi-frame */ ret = isotp_send_first_frame ( link , id ); /* init multi-frame control flags */ if ( ISOTP_RET_OK == ret ) { link -> send_bs_remain = 0 ; link -> send_st_min_us = 0 ; link -> send_wtf_count = 0 ; link -> send_timer_st = isotp_user_get_us (); link -> send_timer_bs = isotp_user_get_us () + link -> param_n_bs_us ; link -> send_protocol_result = ISOTP_PROTOCOL_RESULT_OK ; link -> send_status = ISOTP_SEND_STATUS_INPROGRESS ; } } return ret ; } void isotp_on_can_message ( IsoTpLink * link , const uint8_t * data , uint8_t len ) { IsoTpCanMessage message ; int ret ; if ( len < 2 || len > 8 ) { return ; } memcpy ( message . as . data_array . ptr , data , len ); memset ( message . as . data_array . ptr + len , 0 , sizeof ( message . as . data_array . ptr ) - len ); switch ( message . as . common . type ) { case ISOTP_PCI_TYPE_SINGLE : { /* update protocol result */ if ( ISOTP_RECEIVE_STATUS_INPROGRESS == link -> receive_status ) { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_UNEXP_PDU ; } else { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_OK ; } /* handle message */ ret = isotp_receive_single_frame ( link , & message , len ); if ( ISOTP_RET_OK == ret ) { /* change status */ link -> receive_status = ISOTP_RECEIVE_STATUS_FULL ; } break ; } case ISOTP_PCI_TYPE_FIRST_FRAME : { /* update protocol result */ if ( ISOTP_RECEIVE_STATUS_INPROGRESS == link -> receive_status ) { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_UNEXP_PDU ; } else { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_OK ; } /* handle message */ ret = isotp_receive_first_frame ( link , & message , len ); /* if overflow happened */ if ( ISOTP_RET_OVERFLOW == ret ) { /* update protocol result */ link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW ; /* change status */ link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; /* send error message */ isotp_send_flow_control ( link , PCI_FLOW_STATUS_OVERFLOW , 0 , 0 ); break ; } /* if receive successful */ if ( ISOTP_RET_OK == ret ) { /* change status */ link -> receive_status = ISOTP_RECEIVE_STATUS_INPROGRESS ; /* send fc frame */ link -> receive_bs_count = link -> param_block_size ; isotp_send_flow_control ( link , PCI_FLOW_STATUS_CONTINUE , link -> receive_bs_count , link -> param_st_min_us ); /* refresh timer cs */ link -> receive_timer_cr = isotp_user_get_us () + link -> param_n_cr_us ; } break ; } case ISOTP_PCI_TYPE_CONSECUTIVE_FRAME : { /* check if in receiving status */ if ( ISOTP_RECEIVE_STATUS_INPROGRESS != link -> receive_status ) { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_UNEXP_PDU ; break ; } /* handle message */ ret = isotp_receive_consecutive_frame ( link , & message , len ); /* if wrong sn */ if ( ISOTP_RET_WRONG_SN == ret ) { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_WRONG_SN ; link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; break ; } /* if success */ if ( ISOTP_RET_OK == ret ) { /* refresh timer cs */ link -> receive_timer_cr = isotp_user_get_us () + link -> param_n_cr_us ; /* receive finished */ if ( link -> receive_offset >= link -> receive_size ) { link -> receive_status = ISOTP_RECEIVE_STATUS_FULL ; } else { /* send fc when bs reaches limit */ if ( link -> receive_bs_count > 0 && 0 == -- link -> receive_bs_count ) { link -> receive_bs_count = link -> param_block_size ; isotp_send_flow_control ( link , PCI_FLOW_STATUS_CONTINUE , link -> receive_bs_count , link -> param_st_min_us ); } } } break ; } case ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME : /* handle fc frame only when sending in progress */ if ( ISOTP_SEND_STATUS_INPROGRESS != link -> send_status ) { break ; } /* handle message */ ret = isotp_receive_flow_control_frame ( link , & message , len ); if ( ISOTP_RET_OK == ret ) { /* refresh bs timer */ link -> send_timer_bs = isotp_user_get_us () + link -> param_n_bs_us ; /* overflow */ if ( PCI_FLOW_STATUS_OVERFLOW == message . as . flow_control . FS ) { link -> send_protocol_result = ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW ; link -> send_status = ISOTP_SEND_STATUS_ERROR ; } /* wait */ else if ( PCI_FLOW_STATUS_WAIT == message . as . flow_control . FS ) { link -> send_wtf_count += 1 ; /* wait exceed allowed count */ if ( link -> send_wtf_count > ISO_TP_MAX_WFT_NUMBER ) { link -> send_protocol_result = ISOTP_PROTOCOL_RESULT_WFT_OVRN ; link -> send_status = ISOTP_SEND_STATUS_ERROR ; } } /* permit send */ else if ( PCI_FLOW_STATUS_CONTINUE == message . as . flow_control . FS ) { if ( 0 == message . as . flow_control . BS ) { link -> send_bs_remain = ISOTP_INVALID_BS ; } else { link -> send_bs_remain = message . as . flow_control . BS ; } uint32_t message_st_min_us = isotp_st_min_to_us ( message . as . flow_control . STmin ); link -> send_st_min_us = message_st_min_us > ISO_TP_DEFAULT_ST_MIN_US ? message_st_min_us : ISO_TP_DEFAULT_ST_MIN_US ; // prefer as much st_min as possible // for stability? link -> send_wtf_count = 0 ; } } break ; default : break ; }; #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK /* Notify user via callback if registered */ if ( link -> receive_status == ISOTP_RECEIVE_STATUS_FULL && link -> rx_done_cb != NULL ) { link -> rx_done_cb ( link , link -> receive_buffer , link -> receive_size , link -> rx_done_cb_arg ); link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; } #endif return ; } int isotp_receive ( IsoTpLink * link , uint8_t * payload , const uint32_t payload_size , uint32_t * out_size ) { uint32_t copylen ; #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK /* If callback is registered, isotp_receive should not be used */ if ( link -> rx_done_cb != NULL ) { return ISOTP_RET_ERROR ; /* Callback mode active, use callback instead */ } #endif if ( ISOTP_RECEIVE_STATUS_FULL != link -> receive_status ) { return ISOTP_RET_NO_DATA ; } copylen = link -> receive_size ; if ( copylen > payload_size ) { copylen = payload_size ; } memcpy ( payload , link -> receive_buffer , copylen ); * out_size = copylen ; link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; return ISOTP_RET_OK ; } void isotp_init_link ( IsoTpLink * link , uint32_t sendid , uint8_t * sendbuf , uint32_t sendbufsize , uint8_t * recvbuf , uint32_t recvbufsize ) { memset ( link , 0 , sizeof ( * link )); link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; link -> send_status = ISOTP_SEND_STATUS_IDLE ; link -> send_arbitration_id = sendid ; link -> send_buffer = sendbuf ; link -> send_buf_size = sendbufsize ; link -> receive_buffer = recvbuf ; link -> receive_buf_size = recvbufsize ; link -> param_n_bs_us = ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ; link -> param_n_cr_us = ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ; link -> param_st_min_us = ISO_TP_DEFAULT_ST_MIN_US ; link -> param_block_size = ISO_TP_DEFAULT_BLOCK_SIZE ; #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK link -> tx_done_cb = NULL ; link -> tx_done_cb_arg = NULL ; #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK link -> rx_done_cb = NULL ; link -> rx_done_cb_arg = NULL ; #endif return ; } void isotp_destroy_link ( IsoTpLink * link ) { if ( link == NULL ) { return ; } // Clear callbacks #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK link -> tx_done_cb = NULL ; link -> tx_done_cb_arg = NULL ; #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK link -> rx_done_cb = NULL ; link -> rx_done_cb_arg = NULL ; #endif // Reset link state (optional, but good practice) memset ( link , 0 , sizeof ( IsoTpLink )); } void isotp_set_timeouts ( IsoTpLink * link , uint32_t n_bs_us , uint32_t n_cr_us ) { if ( link != NULL ) { link -> param_n_bs_us = n_bs_us ; link -> param_n_cr_us = n_cr_us ; } } void isotp_set_fc_params ( IsoTpLink * link , uint8_t block_size , uint32_t st_min_us ) { if ( link != NULL ) { link -> param_block_size = block_size ; link -> param_st_min_us = st_min_us ; } } void isotp_poll ( IsoTpLink * link ) { int ret = 0 ; /* only polling when operation in progress */ if ( ISOTP_SEND_STATUS_INPROGRESS == link -> send_status ) { /* continue send data */ if ( /* send data if bs_remain is invalid or bs_remain large than zero */ ( ISOTP_INVALID_BS == link -> send_bs_remain || link -> send_bs_remain > 0 ) && /* and if st_min is zero or go beyond interval time */ ( 0 == link -> send_st_min_us || IsoTpTimeAfter ( isotp_user_get_us (), link -> send_timer_st ))) { ret = isotp_send_consecutive_frame ( link ); if ( ISOTP_RET_OK == ret ) { if ( ISOTP_INVALID_BS != link -> send_bs_remain ) { link -> send_bs_remain -= 1 ; } link -> send_timer_bs = isotp_user_get_us () + link -> param_n_bs_us ; link -> send_timer_st = isotp_user_get_us () + link -> send_st_min_us ; /* check if send finish */ if ( link -> send_offset >= link -> send_size ) { link -> send_status = ISOTP_SEND_STATUS_IDLE ; #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK if ( link -> tx_done_cb != NULL ) { link -> tx_done_cb ( link , link -> send_size , link -> tx_done_cb_arg ); } #endif } } else if ( ISOTP_RET_NOSPACE == ret ) { /* shim reported that it isn't able to send a frame at present, retry on * next call */ } else { link -> send_status = ISOTP_SEND_STATUS_ERROR ; } } /* check timeout */ if ( IsoTpTimeAfter ( isotp_user_get_us (), link -> send_timer_bs )) { link -> send_protocol_result = ISOTP_PROTOCOL_RESULT_TIMEOUT_BS ; link -> send_status = ISOTP_SEND_STATUS_ERROR ; } } /* only polling when operation in progress */ if ( ISOTP_RECEIVE_STATUS_INPROGRESS == link -> receive_status ) { /* check timeout */ if (( link -> receive_timer_cr > 0 ) && IsoTpTimeAfter ( isotp_user_get_us (), link -> receive_timer_cr )) { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_TIMEOUT_CR ; link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; } } return ; } #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK void isotp_set_tx_done_cb ( IsoTpLink * link , isotp_tx_done_cb cb , void * arg ) { if ( link != NULL ) { link -> tx_done_cb = cb ; link -> tx_done_cb_arg = arg ; } } #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK void isotp_set_rx_done_cb ( IsoTpLink * link , isotp_rx_done_cb cb , void * arg ) { if ( link != NULL ) { link -> rx_done_cb = cb ; link -> rx_done_cb_arg = arg ; } } #endif","title":"File isotp.c"},{"location":"docs/isotp_8c_source/#file-isotpc","text":"File List > src > isotp.c Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Core ISO-TP protocol implementation with multi-frame support * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <assert.h> #include <stdint.h> #include \"isotp.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ static uint8_t isotp_us_to_st_min ( uint32_t us ); static uint32_t isotp_st_min_to_us ( uint8_t st_min ); static int isotp_send_flow_control ( const IsoTpLink * link , uint8_t flow_status , uint8_t block_size , uint32_t st_min_us ); static int isotp_send_single_frame ( const IsoTpLink * link , uint32_t id ); static int isotp_send_first_frame ( IsoTpLink * link , uint32_t id ); static int isotp_send_consecutive_frame ( IsoTpLink * link ); static int isotp_receive_single_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ); static int isotp_receive_first_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ); static int isotp_receive_consecutive_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ); static int isotp_receive_flow_control_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ); /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* st_min to microsecond */ static uint8_t isotp_us_to_st_min ( uint32_t us ) { // ISO 15765-2:2016 defines STmin encoding: // 0x00..0x7F: value in milliseconds (0..127 ms) // 0xF1..0xF9: value in 100 microsecond steps (100..900 us) const uint32_t STMIN_MS_MAX = 127000 ; // 127 ms in us const uint32_t STMIN_US_MIN = 100 ; // 100 us const uint32_t STMIN_US_MAX = 900 ; // 900 us const uint8_t STMIN_US_BASE = 0xF0 ; // base for 100us steps if ( us <= STMIN_MS_MAX ) { if ( us >= STMIN_US_MIN && us <= STMIN_US_MAX ) { return ( uint8_t ) ( STMIN_US_BASE + ( us / 100 )); } else { return ( uint8_t ) ( us / 1000u ); } } return 0 ; } /* st_min to usec */ static uint32_t isotp_st_min_to_us ( uint8_t st_min ) { // ISO 15765-2:2016 defines STmin encoding: // 0x00..0x7F: value in milliseconds (0..127 ms) // 0xF1..0xF9: value in 100 microsecond steps (100..900 us) const uint8_t STMIN_MS_MAX = 0x7F ; // 127 ms const uint8_t STMIN_US_MIN_CODE = 0xF1 ; // 100 us const uint8_t STMIN_US_MAX_CODE = 0xF9 ; // 900 us const uint8_t STMIN_US_BASE = 0xF0 ; // base for 100us steps const uint32_t US_PER_MS = 1000 ; const uint32_t US_STEP = 100 ; if ( st_min <= STMIN_MS_MAX ) { return st_min * US_PER_MS ; } else if ( st_min >= STMIN_US_MIN_CODE && st_min <= STMIN_US_MAX_CODE ) { return ( st_min - STMIN_US_BASE ) * US_STEP ; } return 0 ; } static int isotp_send_flow_control ( const IsoTpLink * link , uint8_t flow_status , uint8_t block_size , uint32_t st_min_us ) { IsoTpCanMessage message ; ( void ) memset ( & message , 0 , sizeof ( message )); int ret ; uint8_t size = 0 ; /* setup message */ message . as . flow_control . type = ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME ; message . as . flow_control . FS = flow_status ; message . as . flow_control . BS = block_size ; message . as . flow_control . STmin = isotp_us_to_st_min ( st_min_us ); /* send message */ #ifdef ISO_TP_FRAME_PADDING ( void ) memset ( message . as . flow_control . reserve , ISO_TP_FRAME_PADDING_VALUE , sizeof ( message . as . flow_control . reserve )); size = sizeof ( message ); #else size = 3 ; #endif ret = isotp_user_send_can ( link -> send_arbitration_id , message . as . data_array . ptr , size #if defined(ISO_TP_USER_SEND_CAN_ARG) , link -> user_send_can_arg #endif ); return ret ; } static int isotp_send_single_frame ( const IsoTpLink * link , uint32_t id ) { ( void ) id ; // Prevent unused variable warning IsoTpCanMessage message ; int ret ; uint8_t size = 0 ; /* multi frame message length must greater than 7 */ assert ( link -> send_size <= 7 ); /* setup message */ message . as . single_frame . type = ISOTP_PCI_TYPE_SINGLE ; message . as . single_frame . SF_DL = ( uint8_t ) link -> send_size ; ( void ) memcpy ( message . as . single_frame . data , link -> send_buffer , link -> send_size ); /* send message */ #ifdef ISO_TP_FRAME_PADDING ( void ) memset ( message . as . single_frame . data + link -> send_size , ISO_TP_FRAME_PADDING_VALUE , sizeof ( message . as . single_frame . data ) - link -> send_size ); size = sizeof ( message ); #else size = link -> send_size + ( uint8_t ) 1 ; #endif ret = isotp_user_send_can ( link -> send_arbitration_id , message . as . data_array . ptr , size #if defined(ISO_TP_USER_SEND_CAN_ARG) , link -> user_send_can_arg #endif ); return ret ; } static int isotp_send_first_frame ( IsoTpLink * link , uint32_t id ) { IsoTpCanMessage message = { 0 }; int ret = 0 ; /* multi frame message length must greater than 7 */ assert ( link -> send_size > 7 ); if ( link -> send_size <= 4095 ) { /* setup 'short' message */ message . as . first_frame_short . type = ISOTP_PCI_TYPE_FIRST_FRAME ; message . as . first_frame_short . FF_DL_low = ( uint8_t ) link -> send_size ; message . as . first_frame_short . FF_DL_high = ( uint8_t ) ( 0x0F & ( link -> send_size >> 8 )); ( void ) memcpy ( message . as . first_frame_short . data , link -> send_buffer , sizeof ( message . as . first_frame_short . data )); /* send 'short' message */ ret = isotp_user_send_can ( id , message . as . data_array . ptr , sizeof ( message ) #if defined(ISO_TP_USER_SEND_CAN_ARG) , link -> user_send_can_arg #endif ); if ( ISOTP_RET_OK == ret ) { link -> send_offset += sizeof ( message . as . first_frame_short . data ); } } else { // ISO15765-2:2016 /* setup 'long' message */ message . as . first_frame_long . set_to_zero_high = 0 ; message . as . first_frame_long . set_to_zero_low = 0 ; message . as . first_frame_long . type = ISOTP_PCI_TYPE_FIRST_FRAME ; message . as . first_frame_long . FF_DL = LE32TOH ( link -> send_size ); ( void ) memcpy ( message . as . first_frame_long . data , link -> send_buffer , sizeof ( message . as . first_frame_long . data )); /* send 'long' message */ ret = isotp_user_send_can ( id , message . as . data_array . ptr , sizeof ( message ) #if defined(ISO_TP_USER_SEND_CAN_ARG) , link -> user_send_can_arg #endif ); if ( ISOTP_RET_OK == ret ) { link -> send_offset += sizeof ( message . as . first_frame_long . data ); } } link -> send_sn = 1 ; return ret ; } static int isotp_send_consecutive_frame ( IsoTpLink * link ) { IsoTpCanMessage message ; uint32_t data_length ; int ret ; uint8_t size = 0 ; /* multi frame message length must greater than 7 */ assert ( link -> send_size > 7 ); /* setup message */ message . as . consecutive_frame . type = ISOTP_PCI_TYPE_CONSECUTIVE_FRAME ; message . as . consecutive_frame . SN = link -> send_sn ; data_length = link -> send_size - link -> send_offset ; if ( data_length > sizeof ( message . as . consecutive_frame . data )) { data_length = sizeof ( message . as . consecutive_frame . data ); } ( void ) memcpy ( message . as . consecutive_frame . data , link -> send_buffer + link -> send_offset , data_length ); /* send message */ #ifdef ISO_TP_FRAME_PADDING ( void ) memset ( message . as . consecutive_frame . data + data_length , ISO_TP_FRAME_PADDING_VALUE , sizeof ( message . as . consecutive_frame . data ) - data_length ); size = sizeof ( message ); #else size = data_length + 1 ; #endif ret = isotp_user_send_can ( link -> send_arbitration_id , message . as . data_array . ptr , size #if defined(ISO_TP_USER_SEND_CAN_ARG) , link -> user_send_can_arg #endif ); if ( ISOTP_RET_OK == ret ) { link -> send_offset += data_length ; if ( ++ ( link -> send_sn ) > 0x0F ) { link -> send_sn = 0 ; } } return ret ; } static int isotp_receive_single_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ) { /* check data length */ if (( 0 == message -> as . single_frame . SF_DL ) || ( message -> as . single_frame . SF_DL > ( len - 1 ))) { isotp_user_debug ( \"Single-frame length too small.\" ); return ISOTP_RET_LENGTH ; } /* copying data */ ( void ) memcpy ( link -> receive_buffer , message -> as . single_frame . data , message -> as . single_frame . SF_DL ); link -> receive_size = message -> as . single_frame . SF_DL ; return ISOTP_RET_OK ; } static int isotp_receive_first_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ) { uint8_t is_long_packet = 0 ; uint32_t payload_length ; if ( 8 != len ) { isotp_user_debug ( \"First frame should be 8 bytes in length.\" ); return ISOTP_RET_LENGTH ; } /* check data length */ payload_length = message -> as . first_frame_short . FF_DL_high ; payload_length = ( payload_length << 8 ) + message -> as . first_frame_short . FF_DL_low ; /* if length is ZERO we get a long message > 4095bytes of payload */ if ( payload_length == 0 ) { is_long_packet = 1 ; payload_length = LE32TOH ( message -> as . first_frame_long . FF_DL ); } /* should not use multiple frame transmition */ if ( payload_length <= 7 ) { isotp_user_debug ( \"Should not use multiple frame transmission.\" ); return ISOTP_RET_LENGTH ; } if ( payload_length > link -> receive_buf_size ) { isotp_user_debug ( \"Multi-frame response too large for receiving buffer.\" ); return ISOTP_RET_OVERFLOW ; } /* copying data */ if ( is_long_packet ) { ( void ) memcpy ( link -> receive_buffer , message -> as . first_frame_long . data , sizeof ( message -> as . first_frame_long . data )); link -> receive_offset = sizeof ( message -> as . first_frame_long . data ); } else { ( void ) memcpy ( link -> receive_buffer , message -> as . first_frame_short . data , sizeof ( message -> as . first_frame_short . data )); link -> receive_offset = sizeof ( message -> as . first_frame_short . data ); } link -> receive_size = payload_length ; link -> receive_sn = 1 ; return ISOTP_RET_OK ; } static int isotp_receive_consecutive_frame ( IsoTpLink * link , const IsoTpCanMessage * message , uint8_t len ) { uint32_t remaining_bytes ; /* check sn */ if ( link -> receive_sn != message -> as . consecutive_frame . SN ) { return ISOTP_RET_WRONG_SN ; } /* check data length */ remaining_bytes = link -> receive_size - link -> receive_offset ; if ( remaining_bytes > sizeof ( message -> as . consecutive_frame . data )) { remaining_bytes = sizeof ( message -> as . consecutive_frame . data ); } if ( remaining_bytes > ( uint32_t ) ( len - 1 )) { isotp_user_debug ( \"Consecutive frame too short.\" ); return ISOTP_RET_LENGTH ; } /* copying data */ ( void ) memcpy ( link -> receive_buffer + link -> receive_offset , message -> as . consecutive_frame . data , remaining_bytes ); link -> receive_offset += remaining_bytes ; if ( ++ ( link -> receive_sn ) > 0x0F ) { link -> receive_sn = 0 ; } return ISOTP_RET_OK ; } static int isotp_receive_flow_control_frame ( IsoTpLink * link , IsoTpCanMessage * message , uint8_t len ) { /* unused args */ ( void ) link ; ( void ) message ; /* check message length */ if ( len < 3 ) { isotp_user_debug ( \"Flow control frame too short.\" ); return ISOTP_RET_LENGTH ; } return ISOTP_RET_OK ; } /* ============================================================================== * PUBLIC FUNCTION IMPLEMENTATIONS * =============================================================================*/ int isotp_send ( IsoTpLink * link , const uint8_t payload [], uint32_t size ) { return isotp_send_with_id ( link , link -> send_arbitration_id , payload , size ); } int isotp_send_with_id ( IsoTpLink * link , uint32_t id , const uint8_t payload [], uint32_t size ) { int ret ; if ( link == 0x0 ) { isotp_user_debug ( \"Link is null!\" ); return ISOTP_RET_ERROR ; } if ( size > link -> send_buf_size ) { isotp_user_debug ( \"Message size too large. Increase ISO_TP_MAX_MESSAGE_SIZE to set \" \"a larger buffer \\n \" ); char message [ ISOTP_MAX_ERROR_MSG_SIZE ] = { 0 }; int32_t writtenChars = snprintf ( & message [ 0 ], ISOTP_MAX_ERROR_MSG_SIZE , \"Attempted to send %u bytes; max size is %u! \\n \" , ( unsigned int ) size , ( unsigned int ) link -> send_buf_size ); assert ( writtenChars <= ISOTP_MAX_ERROR_MSG_SIZE ); ( void ) writtenChars ; isotp_user_debug ( message ); return ISOTP_RET_OVERFLOW ; } if ( ISOTP_SEND_STATUS_INPROGRESS == link -> send_status ) { isotp_user_debug ( \"Abort previous message, transmission in progress. \\n \" ); return ISOTP_RET_INPROGRESS ; } /* copy into local buffer */ link -> send_size = size ; link -> send_offset = 0 ; ( void ) memcpy ( link -> send_buffer , payload , size ); if ( link -> send_size < 8 ) { /* send single frame */ ret = isotp_send_single_frame ( link , id ); #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK if ( ret == ISOTP_RET_OK && link -> tx_done_cb ) { link -> tx_done_cb ( link , link -> send_size , link -> tx_done_cb_arg ); } #endif } else { /* send multi-frame */ ret = isotp_send_first_frame ( link , id ); /* init multi-frame control flags */ if ( ISOTP_RET_OK == ret ) { link -> send_bs_remain = 0 ; link -> send_st_min_us = 0 ; link -> send_wtf_count = 0 ; link -> send_timer_st = isotp_user_get_us (); link -> send_timer_bs = isotp_user_get_us () + link -> param_n_bs_us ; link -> send_protocol_result = ISOTP_PROTOCOL_RESULT_OK ; link -> send_status = ISOTP_SEND_STATUS_INPROGRESS ; } } return ret ; } void isotp_on_can_message ( IsoTpLink * link , const uint8_t * data , uint8_t len ) { IsoTpCanMessage message ; int ret ; if ( len < 2 || len > 8 ) { return ; } memcpy ( message . as . data_array . ptr , data , len ); memset ( message . as . data_array . ptr + len , 0 , sizeof ( message . as . data_array . ptr ) - len ); switch ( message . as . common . type ) { case ISOTP_PCI_TYPE_SINGLE : { /* update protocol result */ if ( ISOTP_RECEIVE_STATUS_INPROGRESS == link -> receive_status ) { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_UNEXP_PDU ; } else { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_OK ; } /* handle message */ ret = isotp_receive_single_frame ( link , & message , len ); if ( ISOTP_RET_OK == ret ) { /* change status */ link -> receive_status = ISOTP_RECEIVE_STATUS_FULL ; } break ; } case ISOTP_PCI_TYPE_FIRST_FRAME : { /* update protocol result */ if ( ISOTP_RECEIVE_STATUS_INPROGRESS == link -> receive_status ) { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_UNEXP_PDU ; } else { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_OK ; } /* handle message */ ret = isotp_receive_first_frame ( link , & message , len ); /* if overflow happened */ if ( ISOTP_RET_OVERFLOW == ret ) { /* update protocol result */ link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW ; /* change status */ link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; /* send error message */ isotp_send_flow_control ( link , PCI_FLOW_STATUS_OVERFLOW , 0 , 0 ); break ; } /* if receive successful */ if ( ISOTP_RET_OK == ret ) { /* change status */ link -> receive_status = ISOTP_RECEIVE_STATUS_INPROGRESS ; /* send fc frame */ link -> receive_bs_count = link -> param_block_size ; isotp_send_flow_control ( link , PCI_FLOW_STATUS_CONTINUE , link -> receive_bs_count , link -> param_st_min_us ); /* refresh timer cs */ link -> receive_timer_cr = isotp_user_get_us () + link -> param_n_cr_us ; } break ; } case ISOTP_PCI_TYPE_CONSECUTIVE_FRAME : { /* check if in receiving status */ if ( ISOTP_RECEIVE_STATUS_INPROGRESS != link -> receive_status ) { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_UNEXP_PDU ; break ; } /* handle message */ ret = isotp_receive_consecutive_frame ( link , & message , len ); /* if wrong sn */ if ( ISOTP_RET_WRONG_SN == ret ) { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_WRONG_SN ; link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; break ; } /* if success */ if ( ISOTP_RET_OK == ret ) { /* refresh timer cs */ link -> receive_timer_cr = isotp_user_get_us () + link -> param_n_cr_us ; /* receive finished */ if ( link -> receive_offset >= link -> receive_size ) { link -> receive_status = ISOTP_RECEIVE_STATUS_FULL ; } else { /* send fc when bs reaches limit */ if ( link -> receive_bs_count > 0 && 0 == -- link -> receive_bs_count ) { link -> receive_bs_count = link -> param_block_size ; isotp_send_flow_control ( link , PCI_FLOW_STATUS_CONTINUE , link -> receive_bs_count , link -> param_st_min_us ); } } } break ; } case ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME : /* handle fc frame only when sending in progress */ if ( ISOTP_SEND_STATUS_INPROGRESS != link -> send_status ) { break ; } /* handle message */ ret = isotp_receive_flow_control_frame ( link , & message , len ); if ( ISOTP_RET_OK == ret ) { /* refresh bs timer */ link -> send_timer_bs = isotp_user_get_us () + link -> param_n_bs_us ; /* overflow */ if ( PCI_FLOW_STATUS_OVERFLOW == message . as . flow_control . FS ) { link -> send_protocol_result = ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW ; link -> send_status = ISOTP_SEND_STATUS_ERROR ; } /* wait */ else if ( PCI_FLOW_STATUS_WAIT == message . as . flow_control . FS ) { link -> send_wtf_count += 1 ; /* wait exceed allowed count */ if ( link -> send_wtf_count > ISO_TP_MAX_WFT_NUMBER ) { link -> send_protocol_result = ISOTP_PROTOCOL_RESULT_WFT_OVRN ; link -> send_status = ISOTP_SEND_STATUS_ERROR ; } } /* permit send */ else if ( PCI_FLOW_STATUS_CONTINUE == message . as . flow_control . FS ) { if ( 0 == message . as . flow_control . BS ) { link -> send_bs_remain = ISOTP_INVALID_BS ; } else { link -> send_bs_remain = message . as . flow_control . BS ; } uint32_t message_st_min_us = isotp_st_min_to_us ( message . as . flow_control . STmin ); link -> send_st_min_us = message_st_min_us > ISO_TP_DEFAULT_ST_MIN_US ? message_st_min_us : ISO_TP_DEFAULT_ST_MIN_US ; // prefer as much st_min as possible // for stability? link -> send_wtf_count = 0 ; } } break ; default : break ; }; #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK /* Notify user via callback if registered */ if ( link -> receive_status == ISOTP_RECEIVE_STATUS_FULL && link -> rx_done_cb != NULL ) { link -> rx_done_cb ( link , link -> receive_buffer , link -> receive_size , link -> rx_done_cb_arg ); link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; } #endif return ; } int isotp_receive ( IsoTpLink * link , uint8_t * payload , const uint32_t payload_size , uint32_t * out_size ) { uint32_t copylen ; #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK /* If callback is registered, isotp_receive should not be used */ if ( link -> rx_done_cb != NULL ) { return ISOTP_RET_ERROR ; /* Callback mode active, use callback instead */ } #endif if ( ISOTP_RECEIVE_STATUS_FULL != link -> receive_status ) { return ISOTP_RET_NO_DATA ; } copylen = link -> receive_size ; if ( copylen > payload_size ) { copylen = payload_size ; } memcpy ( payload , link -> receive_buffer , copylen ); * out_size = copylen ; link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; return ISOTP_RET_OK ; } void isotp_init_link ( IsoTpLink * link , uint32_t sendid , uint8_t * sendbuf , uint32_t sendbufsize , uint8_t * recvbuf , uint32_t recvbufsize ) { memset ( link , 0 , sizeof ( * link )); link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; link -> send_status = ISOTP_SEND_STATUS_IDLE ; link -> send_arbitration_id = sendid ; link -> send_buffer = sendbuf ; link -> send_buf_size = sendbufsize ; link -> receive_buffer = recvbuf ; link -> receive_buf_size = recvbufsize ; link -> param_n_bs_us = ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ; link -> param_n_cr_us = ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ; link -> param_st_min_us = ISO_TP_DEFAULT_ST_MIN_US ; link -> param_block_size = ISO_TP_DEFAULT_BLOCK_SIZE ; #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK link -> tx_done_cb = NULL ; link -> tx_done_cb_arg = NULL ; #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK link -> rx_done_cb = NULL ; link -> rx_done_cb_arg = NULL ; #endif return ; } void isotp_destroy_link ( IsoTpLink * link ) { if ( link == NULL ) { return ; } // Clear callbacks #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK link -> tx_done_cb = NULL ; link -> tx_done_cb_arg = NULL ; #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK link -> rx_done_cb = NULL ; link -> rx_done_cb_arg = NULL ; #endif // Reset link state (optional, but good practice) memset ( link , 0 , sizeof ( IsoTpLink )); } void isotp_set_timeouts ( IsoTpLink * link , uint32_t n_bs_us , uint32_t n_cr_us ) { if ( link != NULL ) { link -> param_n_bs_us = n_bs_us ; link -> param_n_cr_us = n_cr_us ; } } void isotp_set_fc_params ( IsoTpLink * link , uint8_t block_size , uint32_t st_min_us ) { if ( link != NULL ) { link -> param_block_size = block_size ; link -> param_st_min_us = st_min_us ; } } void isotp_poll ( IsoTpLink * link ) { int ret = 0 ; /* only polling when operation in progress */ if ( ISOTP_SEND_STATUS_INPROGRESS == link -> send_status ) { /* continue send data */ if ( /* send data if bs_remain is invalid or bs_remain large than zero */ ( ISOTP_INVALID_BS == link -> send_bs_remain || link -> send_bs_remain > 0 ) && /* and if st_min is zero or go beyond interval time */ ( 0 == link -> send_st_min_us || IsoTpTimeAfter ( isotp_user_get_us (), link -> send_timer_st ))) { ret = isotp_send_consecutive_frame ( link ); if ( ISOTP_RET_OK == ret ) { if ( ISOTP_INVALID_BS != link -> send_bs_remain ) { link -> send_bs_remain -= 1 ; } link -> send_timer_bs = isotp_user_get_us () + link -> param_n_bs_us ; link -> send_timer_st = isotp_user_get_us () + link -> send_st_min_us ; /* check if send finish */ if ( link -> send_offset >= link -> send_size ) { link -> send_status = ISOTP_SEND_STATUS_IDLE ; #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK if ( link -> tx_done_cb != NULL ) { link -> tx_done_cb ( link , link -> send_size , link -> tx_done_cb_arg ); } #endif } } else if ( ISOTP_RET_NOSPACE == ret ) { /* shim reported that it isn't able to send a frame at present, retry on * next call */ } else { link -> send_status = ISOTP_SEND_STATUS_ERROR ; } } /* check timeout */ if ( IsoTpTimeAfter ( isotp_user_get_us (), link -> send_timer_bs )) { link -> send_protocol_result = ISOTP_PROTOCOL_RESULT_TIMEOUT_BS ; link -> send_status = ISOTP_SEND_STATUS_ERROR ; } } /* only polling when operation in progress */ if ( ISOTP_RECEIVE_STATUS_INPROGRESS == link -> receive_status ) { /* check timeout */ if (( link -> receive_timer_cr > 0 ) && IsoTpTimeAfter ( isotp_user_get_us (), link -> receive_timer_cr )) { link -> receive_protocol_result = ISOTP_PROTOCOL_RESULT_TIMEOUT_CR ; link -> receive_status = ISOTP_RECEIVE_STATUS_IDLE ; } } return ; } #ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK void isotp_set_tx_done_cb ( IsoTpLink * link , isotp_tx_done_cb cb , void * arg ) { if ( link != NULL ) { link -> tx_done_cb = cb ; link -> tx_done_cb_arg = arg ; } } #endif #ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK void isotp_set_rx_done_cb ( IsoTpLink * link , isotp_rx_done_cb cb , void * arg ) { if ( link != NULL ) { link -> rx_done_cb = cb ; link -> rx_done_cb_arg = arg ; } } #endif","title":"File isotp.c"},{"location":"docs/dir_59425e443f801f1f2fd8bbe4959a3ccf/","text":"Dir tests \u00b6 FileList > tests Directories \u00b6 Type Name dir integration dir unit The documentation for this class was generated from the following file tests/","title":"Dir tests"},{"location":"docs/dir_59425e443f801f1f2fd8bbe4959a3ccf/#dir-tests","text":"FileList > tests","title":"Dir tests"},{"location":"docs/dir_59425e443f801f1f2fd8bbe4959a3ccf/#directories","text":"Type Name dir integration dir unit The documentation for this class was generated from the following file tests/","title":"Directories"},{"location":"docs/dir_9ddfaab4002c4e8cb6c25cc17bdef75b/","text":"Dir tests/integration \u00b6 FileList > integration Files \u00b6 Type Name file conftest.py Pytest fixtures for ISO-TP integration tests. file test_api_endpoints.py Integration smoke tests for public API endpoints. file test_api_validation.py Integration tests for API input validation. file test_buffer_limits.py Integration tests for buffer limit behavior. file test_cantp.py Integration tests for CAN TP and ISO-TP behavior. file test_flow_control.py Integration tests for flow control handling. file test_multi_frame.py Integration tests for multi-frame ISO-TP transfers. file test_timing.py Integration tests for timing-related ISO-TP behavior. The documentation for this class was generated from the following file tests/integration/","title":"Dir tests/integration"},{"location":"docs/dir_9ddfaab4002c4e8cb6c25cc17bdef75b/#dir-testsintegration","text":"FileList > integration","title":"Dir tests/integration"},{"location":"docs/dir_9ddfaab4002c4e8cb6c25cc17bdef75b/#files","text":"Type Name file conftest.py Pytest fixtures for ISO-TP integration tests. file test_api_endpoints.py Integration smoke tests for public API endpoints. file test_api_validation.py Integration tests for API input validation. file test_buffer_limits.py Integration tests for buffer limit behavior. file test_cantp.py Integration tests for CAN TP and ISO-TP behavior. file test_flow_control.py Integration tests for flow control handling. file test_multi_frame.py Integration tests for multi-frame ISO-TP transfers. file test_timing.py Integration tests for timing-related ISO-TP behavior. The documentation for this class was generated from the following file tests/integration/","title":"Files"},{"location":"docs/conftest_8py/","text":"File conftest.py \u00b6 FileList > integration > conftest.py Go to the source code of this file Pytest fixtures for ISO-TP integration tests. More... Namespaces \u00b6 Type Name namespace conftest Detailed Description \u00b6 Provides common setup/teardown for mock CAN state. Note: The fixture runs automatically for each integration test. The documentation for this class was generated from the following file tests/integration/conftest.py","title":"File conftest.py"},{"location":"docs/conftest_8py/#file-conftestpy","text":"FileList > integration > conftest.py Go to the source code of this file Pytest fixtures for ISO-TP integration tests. More...","title":"File conftest.py"},{"location":"docs/conftest_8py/#namespaces","text":"Type Name namespace conftest","title":"Namespaces"},{"location":"docs/conftest_8py/#detailed-description","text":"Provides common setup/teardown for mock CAN state. Note: The fixture runs automatically for each integration test. The documentation for this class was generated from the following file tests/integration/conftest.py","title":"Detailed Description"},{"location":"docs/conftest_8py_source/","text":"File conftest.py \u00b6 File List > integration > conftest.py Go to the documentation of this file #****************************************************************************** # ISO-TP-C: ISO 15765-2 Protocol Implementation # # Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization # Description: A high-performance, embedded-grade implementation of the ISO 15765-2 (ISO-TP) protocol in C, # designed for automotive and industrial applications. This project focuses on refactoring and optimizing # the codebase to achieve maximum efficiency, reliability, and maintainability while adhering to the ISO-TP standard. # # Author: Anton Vynohradov # Email: avynohradov@systemfromscratch.com # # License: MIT License # # Copyright (c) 2026 Anton Vynohradov # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. # # SPDX-License-Identifier: MIT #***************************************************************************** \"\"\"! @file conftest.py @brief Pytest fixtures for ISO-TP integration tests. @details Provides common setup/teardown for mock CAN state. @note The fixture runs automatically for each integration test. \"\"\" # ============================================================================= # IMPORTS # ============================================================================= import pyisotp import pytest # ============================================================================= # FUNCTION PROTOTYPES # ============================================================================= @pytest . fixture ( autouse = True ) def reset_mock_can_state (): \"\"\"! @brief Ensure mock CAN state is reset around each test. @details Disables FC mocks before and after each test run. \"\"\" pyisotp . mock_enable_drop ( False ) pyisotp . mock_disable_fc ( False ) pyisotp . time_reset () yield pyisotp . mock_enable_drop ( False ) pyisotp . mock_disable_fc ( False ) pyisotp . time_reset ()","title":"File conftest.py"},{"location":"docs/conftest_8py_source/#file-conftestpy","text":"File List > integration > conftest.py Go to the documentation of this file #****************************************************************************** # ISO-TP-C: ISO 15765-2 Protocol Implementation # # Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization # Description: A high-performance, embedded-grade implementation of the ISO 15765-2 (ISO-TP) protocol in C, # designed for automotive and industrial applications. This project focuses on refactoring and optimizing # the codebase to achieve maximum efficiency, reliability, and maintainability while adhering to the ISO-TP standard. # # Author: Anton Vynohradov # Email: avynohradov@systemfromscratch.com # # License: MIT License # # Copyright (c) 2026 Anton Vynohradov # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. # # SPDX-License-Identifier: MIT #***************************************************************************** \"\"\"! @file conftest.py @brief Pytest fixtures for ISO-TP integration tests. @details Provides common setup/teardown for mock CAN state. @note The fixture runs automatically for each integration test. \"\"\" # ============================================================================= # IMPORTS # ============================================================================= import pyisotp import pytest # ============================================================================= # FUNCTION PROTOTYPES # ============================================================================= @pytest . fixture ( autouse = True ) def reset_mock_can_state (): \"\"\"! @brief Ensure mock CAN state is reset around each test. @details Disables FC mocks before and after each test run. \"\"\" pyisotp . mock_enable_drop ( False ) pyisotp . mock_disable_fc ( False ) pyisotp . time_reset () yield pyisotp . mock_enable_drop ( False ) pyisotp . mock_disable_fc ( False ) pyisotp . time_reset ()","title":"File conftest.py"},{"location":"docs/test__api__endpoints_8py/","text":"File test_api_endpoints.py \u00b6 FileList > integration > test_api_endpoints.py Go to the source code of this file Integration smoke tests for public API endpoints. Namespaces \u00b6 Type Name namespace test_api_endpoints The documentation for this class was generated from the following file tests/integration/test_api_endpoints.py","title":"File test_api_endpoints.py"},{"location":"docs/test__api__endpoints_8py/#file-test_api_endpointspy","text":"FileList > integration > test_api_endpoints.py Go to the source code of this file Integration smoke tests for public API endpoints.","title":"File test_api_endpoints.py"},{"location":"docs/test__api__endpoints_8py/#namespaces","text":"Type Name namespace test_api_endpoints The documentation for this class was generated from the following file tests/integration/test_api_endpoints.py","title":"Namespaces"},{"location":"docs/test__api__endpoints_8py_source/","text":"File test_api_endpoints.py \u00b6 File List > integration > test_api_endpoints.py Go to the documentation of this file #****************************************************************************** # ISO-TP-C: ISO 15765-2 Protocol Implementation # # Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization # Description: A high-performance, embedded-grade implementation of the ISO 15765-2 (ISO-TP) protocol in C, # designed for automotive and industrial applications. This project focuses on refactoring and optimizing # the codebase to achieve maximum efficiency, reliability, and maintainability while adhering to the ISO-TP standard. # # Author: Anton Vynohradov # Email: avynohradov@systemfromscratch.com # # License: MIT License # # Copyright (c) 2026 Anton Vynohradov # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. # # SPDX-License-Identifier: MIT #***************************************************************************** \"\"\"! @file test_api_endpoints.py @brief Integration smoke tests for public API endpoints. \"\"\" # ============================================================================= # IMPORTS # ============================================================================= import pyisotp import pytest # ============================================================================= # FUNCTION PROTOTYPES # ============================================================================= def _poll_until_receive ( link , payload_size , steps , advance_ms = 0 ): \"\"\"! @brief Poll the link until a response is received or steps are exhausted. @param link ISO-TP link handle. @param payload_size Expected payload size for receive. @param steps Maximum number of poll iterations. @param advance_ms Optional time advance per step in milliseconds. @return Received payload bytes or None when nothing is received. \"\"\" resp = None for _ in range ( steps ): if advance_ms : pyisotp . time_advance ( advance_ms ) pyisotp . poll ( link ) resp = pyisotp . receive ( link , payload_size ) if resp is not None : break return resp def _make_payload ( size ): \"\"\"! @brief Build a deterministic payload of a given size. @param size Number of bytes to generate. @return Payload bytes. \"\"\" return bytes (( idx % 256 for idx in range ( size ))) def _ff_frame ( payload_size , payload ): \"\"\"! @brief Build a First Frame (FF) for an ISO-TP multi-frame transfer. @param payload_size Total payload size. @param payload Payload bytes to embed in FF. @return CAN frame bytes representing the FF. \"\"\" ff_dl_high = ( payload_size >> 8 ) & 0x0F ff_dl_low = payload_size & 0xFF return bytes ([ 0x10 | ff_dl_high , ff_dl_low ]) + payload [: 6 ] def _cf_frame ( sn , payload ): \"\"\"! @brief Build a Consecutive Frame (CF) with a given sequence number. @param sn Sequence number (0-15). @param payload Payload bytes to embed in CF. @return CAN frame bytes representing the CF. \"\"\" return bytes ([ 0x20 | ( sn & 0x0F )]) + payload [: 7 ] def test_api_endpoints_smoke (): \"\"\"! @brief Verify basic API calls and protocol result handling.\"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) assert isinstance ( pyisotp . ISOTP_PROTOCOL_RESULT_TIMEOUT_BS , int ) pyisotp . time_reset () pyisotp . time_set ( 1 ) pyisotp . time_advance ( 1 ) payload = b \" \\x01\\x02\\x03 \" pyisotp . send ( link , payload ) pyisotp . poll ( link ) resp = pyisotp . receive ( link , 1024 ) assert resp == payload pyisotp . mock_enable_drop ( True ) pyisotp . send ( link , payload ) pyisotp . poll ( link ) resp = pyisotp . receive ( link , 1024 ) assert resp is None pyisotp . mock_enable_drop ( False ) pyisotp . mock_disable_fc ( True ) pyisotp . time_set ( 0 ) pyisotp . send ( link , bytes ( range ( 12 ))) for _ in range ( 101 ): pyisotp . time_advance ( 1 ) pyisotp . poll ( link ) assert ( pyisotp . get_last_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_TIMEOUT_BS ) pyisotp . mock_disable_fc ( False ) def test_api_endpoints_smoke_multi_frame (): \"\"\"! @brief Verify multi-frame send/receive path.\"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) payload = _make_payload ( 20 ) pyisotp . send ( link , payload ) resp = _poll_until_receive ( link , 1024 , 5 ) assert resp == payload def test_api_endpoints_return_codes (): \"\"\"! @brief Validate return codes for overflow and in-progress sends.\"\"\" link = pyisotp . init ( 0x700 , 16 , 16 ) payload = _make_payload ( 20 ) ret = pyisotp . send ( link , payload ) assert ret == pyisotp . ISOTP_RET_OVERFLOW payload = _make_payload ( 12 ) first = pyisotp . send ( link , payload ) second = pyisotp . send ( link , payload ) assert first == 0 assert second == pyisotp . ISOTP_RET_INPROGRESS def test_api_endpoints_validation_errors (): \"\"\"! @brief Validate input checks and error signaling in API.\"\"\" with pytest . raises ( ValueError ): pyisotp . init ( 0x700 , 0 , 16 ) link = pyisotp . init ( 0x700 , 64 , 64 ) with pytest . raises ( ValueError ): pyisotp . receive ( link , 0 ) with pytest . raises ( ValueError ): pyisotp . set_fc_params ( link , 256 , 0 ) def test_api_endpoints_inject_unexpected_cf (): \"\"\"! @brief Validate unexpected CF injection handling.\"\"\" link = pyisotp . init ( 0x700 , 64 , 64 ) pyisotp . inject_can ( link , _cf_frame ( 1 , b \" \\xAA \" * 7 )) assert ( pyisotp . get_last_receive_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_UNEXP_PDU ) def test_api_endpoints_inject_wrong_sn (): \"\"\"! @brief Validate wrong sequence number handling.\"\"\" link = pyisotp . init ( 0x700 , 64 , 64 ) payload = _make_payload ( 20 ) pyisotp . inject_can ( link , _ff_frame ( len ( payload ), payload )) pyisotp . inject_can ( link , _cf_frame ( 5 , payload [ 6 : 13 ])) assert ( pyisotp . get_last_receive_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_WRONG_SN )","title":"File test_api_endpoints.py"},{"location":"docs/test__api__endpoints_8py_source/#file-test_api_endpointspy","text":"File List > integration > test_api_endpoints.py Go to the documentation of this file #****************************************************************************** # ISO-TP-C: ISO 15765-2 Protocol Implementation # # Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization # Description: A high-performance, embedded-grade implementation of the ISO 15765-2 (ISO-TP) protocol in C, # designed for automotive and industrial applications. This project focuses on refactoring and optimizing # the codebase to achieve maximum efficiency, reliability, and maintainability while adhering to the ISO-TP standard. # # Author: Anton Vynohradov # Email: avynohradov@systemfromscratch.com # # License: MIT License # # Copyright (c) 2026 Anton Vynohradov # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. # # SPDX-License-Identifier: MIT #***************************************************************************** \"\"\"! @file test_api_endpoints.py @brief Integration smoke tests for public API endpoints. \"\"\" # ============================================================================= # IMPORTS # ============================================================================= import pyisotp import pytest # ============================================================================= # FUNCTION PROTOTYPES # ============================================================================= def _poll_until_receive ( link , payload_size , steps , advance_ms = 0 ): \"\"\"! @brief Poll the link until a response is received or steps are exhausted. @param link ISO-TP link handle. @param payload_size Expected payload size for receive. @param steps Maximum number of poll iterations. @param advance_ms Optional time advance per step in milliseconds. @return Received payload bytes or None when nothing is received. \"\"\" resp = None for _ in range ( steps ): if advance_ms : pyisotp . time_advance ( advance_ms ) pyisotp . poll ( link ) resp = pyisotp . receive ( link , payload_size ) if resp is not None : break return resp def _make_payload ( size ): \"\"\"! @brief Build a deterministic payload of a given size. @param size Number of bytes to generate. @return Payload bytes. \"\"\" return bytes (( idx % 256 for idx in range ( size ))) def _ff_frame ( payload_size , payload ): \"\"\"! @brief Build a First Frame (FF) for an ISO-TP multi-frame transfer. @param payload_size Total payload size. @param payload Payload bytes to embed in FF. @return CAN frame bytes representing the FF. \"\"\" ff_dl_high = ( payload_size >> 8 ) & 0x0F ff_dl_low = payload_size & 0xFF return bytes ([ 0x10 | ff_dl_high , ff_dl_low ]) + payload [: 6 ] def _cf_frame ( sn , payload ): \"\"\"! @brief Build a Consecutive Frame (CF) with a given sequence number. @param sn Sequence number (0-15). @param payload Payload bytes to embed in CF. @return CAN frame bytes representing the CF. \"\"\" return bytes ([ 0x20 | ( sn & 0x0F )]) + payload [: 7 ] def test_api_endpoints_smoke (): \"\"\"! @brief Verify basic API calls and protocol result handling.\"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) assert isinstance ( pyisotp . ISOTP_PROTOCOL_RESULT_TIMEOUT_BS , int ) pyisotp . time_reset () pyisotp . time_set ( 1 ) pyisotp . time_advance ( 1 ) payload = b \" \\x01\\x02\\x03 \" pyisotp . send ( link , payload ) pyisotp . poll ( link ) resp = pyisotp . receive ( link , 1024 ) assert resp == payload pyisotp . mock_enable_drop ( True ) pyisotp . send ( link , payload ) pyisotp . poll ( link ) resp = pyisotp . receive ( link , 1024 ) assert resp is None pyisotp . mock_enable_drop ( False ) pyisotp . mock_disable_fc ( True ) pyisotp . time_set ( 0 ) pyisotp . send ( link , bytes ( range ( 12 ))) for _ in range ( 101 ): pyisotp . time_advance ( 1 ) pyisotp . poll ( link ) assert ( pyisotp . get_last_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_TIMEOUT_BS ) pyisotp . mock_disable_fc ( False ) def test_api_endpoints_smoke_multi_frame (): \"\"\"! @brief Verify multi-frame send/receive path.\"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) payload = _make_payload ( 20 ) pyisotp . send ( link , payload ) resp = _poll_until_receive ( link , 1024 , 5 ) assert resp == payload def test_api_endpoints_return_codes (): \"\"\"! @brief Validate return codes for overflow and in-progress sends.\"\"\" link = pyisotp . init ( 0x700 , 16 , 16 ) payload = _make_payload ( 20 ) ret = pyisotp . send ( link , payload ) assert ret == pyisotp . ISOTP_RET_OVERFLOW payload = _make_payload ( 12 ) first = pyisotp . send ( link , payload ) second = pyisotp . send ( link , payload ) assert first == 0 assert second == pyisotp . ISOTP_RET_INPROGRESS def test_api_endpoints_validation_errors (): \"\"\"! @brief Validate input checks and error signaling in API.\"\"\" with pytest . raises ( ValueError ): pyisotp . init ( 0x700 , 0 , 16 ) link = pyisotp . init ( 0x700 , 64 , 64 ) with pytest . raises ( ValueError ): pyisotp . receive ( link , 0 ) with pytest . raises ( ValueError ): pyisotp . set_fc_params ( link , 256 , 0 ) def test_api_endpoints_inject_unexpected_cf (): \"\"\"! @brief Validate unexpected CF injection handling.\"\"\" link = pyisotp . init ( 0x700 , 64 , 64 ) pyisotp . inject_can ( link , _cf_frame ( 1 , b \" \\xAA \" * 7 )) assert ( pyisotp . get_last_receive_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_UNEXP_PDU ) def test_api_endpoints_inject_wrong_sn (): \"\"\"! @brief Validate wrong sequence number handling.\"\"\" link = pyisotp . init ( 0x700 , 64 , 64 ) payload = _make_payload ( 20 ) pyisotp . inject_can ( link , _ff_frame ( len ( payload ), payload )) pyisotp . inject_can ( link , _cf_frame ( 5 , payload [ 6 : 13 ])) assert ( pyisotp . get_last_receive_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_WRONG_SN )","title":"File test_api_endpoints.py"},{"location":"docs/test__api__validation_8py/","text":"File test_api_validation.py \u00b6 FileList > integration > test_api_validation.py Go to the source code of this file Integration tests for API input validation. More... Namespaces \u00b6 Type Name namespace test_api_validation Detailed Description \u00b6 Exercises guardrails for invalid inputs across init, receive, and FC params. Note: These tests expect Python bindings to raise ValueError. The documentation for this class was generated from the following file tests/integration/test_api_validation.py","title":"File test_api_validation.py"},{"location":"docs/test__api__validation_8py/#file-test_api_validationpy","text":"FileList > integration > test_api_validation.py Go to the source code of this file Integration tests for API input validation. More...","title":"File test_api_validation.py"},{"location":"docs/test__api__validation_8py/#namespaces","text":"Type Name namespace test_api_validation","title":"Namespaces"},{"location":"docs/test__api__validation_8py/#detailed-description","text":"Exercises guardrails for invalid inputs across init, receive, and FC params. Note: These tests expect Python bindings to raise ValueError. The documentation for this class was generated from the following file tests/integration/test_api_validation.py","title":"Detailed Description"},{"location":"docs/test__api__validation_8py_source/","text":"File test_api_validation.py \u00b6 File List > integration > test_api_validation.py Go to the documentation of this file #****************************************************************************** # ISO-TP-C: ISO 15765-2 Protocol Implementation # # Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization # Description: A high-performance, embedded-grade implementation of the ISO 15765-2 (ISO-TP) protocol in C, # designed for automotive and industrial applications. This project focuses on refactoring and optimizing # the codebase to achieve maximum efficiency, reliability, and maintainability while adhering to the ISO-TP standard. # # Author: Anton Vynohradov # Email: avynohradov@systemfromscratch.com # # License: MIT License # # Copyright (c) 2026 Anton Vynohradov # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. # # SPDX-License-Identifier: MIT #***************************************************************************** \"\"\"! @file test_api_validation.py @brief Integration tests for API input validation. @details Exercises guardrails for invalid inputs across init, receive, and FC params. @note These tests expect Python bindings to raise ValueError. \"\"\" # ============================================================================= # IMPORTS # ============================================================================= import pyisotp import pytest # ============================================================================= # FUNCTION PROTOTYPES # ============================================================================= def test_init_rejects_zero_buffers (): \"\"\"! @brief Verify init rejects zero-length buffers. @details Validates both send and receive buffer size checks. \"\"\" with pytest . raises ( ValueError ): pyisotp . init ( 0x700 , 0 , 16 ) with pytest . raises ( ValueError ): pyisotp . init ( 0x700 , 16 , 0 ) def test_receive_rejects_invalid_bufsize (): \"\"\"! @brief Verify receive rejects invalid buffer sizes. @details Ensures zero length is rejected by the binding. \"\"\" link = pyisotp . init ( 0x700 , 64 , 64 ) with pytest . raises ( ValueError ): pyisotp . receive ( link , 0 ) def test_set_fc_params_rejects_large_block_size (): \"\"\"! @brief Verify flow control params reject oversized block size. @details Block size values above 255 must be rejected. \"\"\" link = pyisotp . init ( 0x700 , 64 , 64 ) with pytest . raises ( ValueError ): pyisotp . set_fc_params ( link , 256 , 0 )","title":"File test_api_validation.py"},{"location":"docs/test__api__validation_8py_source/#file-test_api_validationpy","text":"File List > integration > test_api_validation.py Go to the documentation of this file #****************************************************************************** # ISO-TP-C: ISO 15765-2 Protocol Implementation # # Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization # Description: A high-performance, embedded-grade implementation of the ISO 15765-2 (ISO-TP) protocol in C, # designed for automotive and industrial applications. This project focuses on refactoring and optimizing # the codebase to achieve maximum efficiency, reliability, and maintainability while adhering to the ISO-TP standard. # # Author: Anton Vynohradov # Email: avynohradov@systemfromscratch.com # # License: MIT License # # Copyright (c) 2026 Anton Vynohradov # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. # # SPDX-License-Identifier: MIT #***************************************************************************** \"\"\"! @file test_api_validation.py @brief Integration tests for API input validation. @details Exercises guardrails for invalid inputs across init, receive, and FC params. @note These tests expect Python bindings to raise ValueError. \"\"\" # ============================================================================= # IMPORTS # ============================================================================= import pyisotp import pytest # ============================================================================= # FUNCTION PROTOTYPES # ============================================================================= def test_init_rejects_zero_buffers (): \"\"\"! @brief Verify init rejects zero-length buffers. @details Validates both send and receive buffer size checks. \"\"\" with pytest . raises ( ValueError ): pyisotp . init ( 0x700 , 0 , 16 ) with pytest . raises ( ValueError ): pyisotp . init ( 0x700 , 16 , 0 ) def test_receive_rejects_invalid_bufsize (): \"\"\"! @brief Verify receive rejects invalid buffer sizes. @details Ensures zero length is rejected by the binding. \"\"\" link = pyisotp . init ( 0x700 , 64 , 64 ) with pytest . raises ( ValueError ): pyisotp . receive ( link , 0 ) def test_set_fc_params_rejects_large_block_size (): \"\"\"! @brief Verify flow control params reject oversized block size. @details Block size values above 255 must be rejected. \"\"\" link = pyisotp . init ( 0x700 , 64 , 64 ) with pytest . raises ( ValueError ): pyisotp . set_fc_params ( link , 256 , 0 )","title":"File test_api_validation.py"},{"location":"docs/test__buffer__limits_8py/","text":"File test_buffer_limits.py \u00b6 FileList > integration > test_buffer_limits.py Go to the source code of this file Integration tests for buffer limit behavior. More... Namespaces \u00b6 Type Name namespace test_buffer_limits Detailed Description \u00b6 Covers overflow, truncation, and in-progress paths for buffers. Note: Uses the Python wrapper to exercise C core behavior. The documentation for this class was generated from the following file tests/integration/test_buffer_limits.py","title":"File test_buffer_limits.py"},{"location":"docs/test__buffer__limits_8py/#file-test_buffer_limitspy","text":"FileList > integration > test_buffer_limits.py Go to the source code of this file Integration tests for buffer limit behavior. More...","title":"File test_buffer_limits.py"},{"location":"docs/test__buffer__limits_8py/#namespaces","text":"Type Name namespace test_buffer_limits","title":"Namespaces"},{"location":"docs/test__buffer__limits_8py/#detailed-description","text":"Covers overflow, truncation, and in-progress paths for buffers. Note: Uses the Python wrapper to exercise C core behavior. The documentation for this class was generated from the following file tests/integration/test_buffer_limits.py","title":"Detailed Description"},{"location":"docs/test__buffer__limits_8py_source/","text":"File test_buffer_limits.py \u00b6 File List > integration > test_buffer_limits.py Go to the documentation of this file #****************************************************************************** # ISO-TP-C: ISO 15765-2 Protocol Implementation # # Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization # Description: A high-performance, embedded-grade implementation of the ISO 15765-2 (ISO-TP) protocol in C, # designed for automotive and industrial applications. This project focuses on refactoring and optimizing # the codebase to achieve maximum efficiency, reliability, and maintainability while adhering to the ISO-TP standard. # # Author: Anton Vynohradov # Email: avynohradov@systemfromscratch.com # # License: MIT License # # Copyright (c) 2026 Anton Vynohradov # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. # # SPDX-License-Identifier: MIT #***************************************************************************** \"\"\"! @file test_buffer_limits.py @brief Integration tests for buffer limit behavior. @details Covers overflow, truncation, and in-progress paths for buffers. @note Uses the Python wrapper to exercise C core behavior. \"\"\" # ============================================================================= # IMPORTS # ============================================================================= import pyisotp # ============================================================================= # FUNCTION PROTOTYPES # ============================================================================= def _poll_until_receive ( link , payload_size , steps ): \"\"\"! @brief Poll the link until a response is received or steps are exhausted. @param link ISO-TP link handle. @param payload_size Expected payload size for receive. @param steps Maximum number of poll iterations. @return Received payload bytes or None when nothing is received. @details Polls the core without advancing time. \"\"\" resp = None for _ in range ( steps ): pyisotp . poll ( link ) resp = pyisotp . receive ( link , payload_size ) if resp is not None : break return resp def _make_payload ( size ): \"\"\"! @brief Build a deterministic payload of a given size. @param size Number of bytes to generate. @return Payload bytes. @details Uses a simple modulo pattern for repeatability. \"\"\" return bytes (( idx % 256 for idx in range ( size ))) # ============================================================================= # BUFFER LIMIT TESTS # ============================================================================= def test_send_overflow_returns_code (): \"\"\"! @brief Verify overflow is reported on send. @details Exceeding the send buffer returns ISOTP_RET_OVERFLOW. \"\"\" link = pyisotp . init ( 0x700 , 8 , 8 ) payload = _make_payload ( 9 ) ret = pyisotp . send ( link , payload ) assert ret == pyisotp . ISOTP_RET_OVERFLOW def test_receive_truncates_payload (): \"\"\"! @brief Verify receive truncates payload to buffer size. @details The returned payload must be capped to the buffer length. \"\"\" link = pyisotp . init ( 0x700 , 128 , 128 ) payload = _make_payload ( 20 ) pyisotp . send ( link , payload ) resp = _poll_until_receive ( link , 10 , 5 ) assert resp == payload [: 10 ] def test_send_in_progress_returns_code (): \"\"\"! @brief Verify in-progress is reported on concurrent send. @details Second send while active returns ISOTP_RET_INPROGRESS. \"\"\" link = pyisotp . init ( 0x700 , 128 , 128 ) payload = _make_payload ( 20 ) first = pyisotp . send ( link , payload ) second = pyisotp . send ( link , payload ) assert first == 0 assert second == pyisotp . ISOTP_RET_INPROGRESS","title":"File test_buffer_limits.py"},{"location":"docs/test__buffer__limits_8py_source/#file-test_buffer_limitspy","text":"File List > integration > test_buffer_limits.py Go to the documentation of this file #****************************************************************************** # ISO-TP-C: ISO 15765-2 Protocol Implementation # # Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization # Description: A high-performance, embedded-grade implementation of the ISO 15765-2 (ISO-TP) protocol in C, # designed for automotive and industrial applications. This project focuses on refactoring and optimizing # the codebase to achieve maximum efficiency, reliability, and maintainability while adhering to the ISO-TP standard. # # Author: Anton Vynohradov # Email: avynohradov@systemfromscratch.com # # License: MIT License # # Copyright (c) 2026 Anton Vynohradov # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. # # SPDX-License-Identifier: MIT #***************************************************************************** \"\"\"! @file test_buffer_limits.py @brief Integration tests for buffer limit behavior. @details Covers overflow, truncation, and in-progress paths for buffers. @note Uses the Python wrapper to exercise C core behavior. \"\"\" # ============================================================================= # IMPORTS # ============================================================================= import pyisotp # ============================================================================= # FUNCTION PROTOTYPES # ============================================================================= def _poll_until_receive ( link , payload_size , steps ): \"\"\"! @brief Poll the link until a response is received or steps are exhausted. @param link ISO-TP link handle. @param payload_size Expected payload size for receive. @param steps Maximum number of poll iterations. @return Received payload bytes or None when nothing is received. @details Polls the core without advancing time. \"\"\" resp = None for _ in range ( steps ): pyisotp . poll ( link ) resp = pyisotp . receive ( link , payload_size ) if resp is not None : break return resp def _make_payload ( size ): \"\"\"! @brief Build a deterministic payload of a given size. @param size Number of bytes to generate. @return Payload bytes. @details Uses a simple modulo pattern for repeatability. \"\"\" return bytes (( idx % 256 for idx in range ( size ))) # ============================================================================= # BUFFER LIMIT TESTS # ============================================================================= def test_send_overflow_returns_code (): \"\"\"! @brief Verify overflow is reported on send. @details Exceeding the send buffer returns ISOTP_RET_OVERFLOW. \"\"\" link = pyisotp . init ( 0x700 , 8 , 8 ) payload = _make_payload ( 9 ) ret = pyisotp . send ( link , payload ) assert ret == pyisotp . ISOTP_RET_OVERFLOW def test_receive_truncates_payload (): \"\"\"! @brief Verify receive truncates payload to buffer size. @details The returned payload must be capped to the buffer length. \"\"\" link = pyisotp . init ( 0x700 , 128 , 128 ) payload = _make_payload ( 20 ) pyisotp . send ( link , payload ) resp = _poll_until_receive ( link , 10 , 5 ) assert resp == payload [: 10 ] def test_send_in_progress_returns_code (): \"\"\"! @brief Verify in-progress is reported on concurrent send. @details Second send while active returns ISOTP_RET_INPROGRESS. \"\"\" link = pyisotp . init ( 0x700 , 128 , 128 ) payload = _make_payload ( 20 ) first = pyisotp . send ( link , payload ) second = pyisotp . send ( link , payload ) assert first == 0 assert second == pyisotp . ISOTP_RET_INPROGRESS","title":"File test_buffer_limits.py"},{"location":"docs/test__cantp_8py/","text":"File test_cantp.py \u00b6 FileList > integration > test_cantp.py Go to the source code of this file Integration tests for CAN TP and ISO-TP behavior. More... Namespaces \u00b6 Type Name namespace test_cantp Detailed Description \u00b6 Exercises FC handling, timeouts, and unexpected PDU handling. Note: Some tests rely on mock drop/disable helpers from the Python binding. The documentation for this class was generated from the following file tests/integration/test_cantp.py","title":"File test_cantp.py"},{"location":"docs/test__cantp_8py/#file-test_cantppy","text":"FileList > integration > test_cantp.py Go to the source code of this file Integration tests for CAN TP and ISO-TP behavior. More...","title":"File test_cantp.py"},{"location":"docs/test__cantp_8py/#namespaces","text":"Type Name namespace test_cantp","title":"Namespaces"},{"location":"docs/test__cantp_8py/#detailed-description","text":"Exercises FC handling, timeouts, and unexpected PDU handling. Note: Some tests rely on mock drop/disable helpers from the Python binding. The documentation for this class was generated from the following file tests/integration/test_cantp.py","title":"Detailed Description"},{"location":"docs/test__cantp_8py_source/","text":"File test_cantp.py \u00b6 File List > integration > test_cantp.py Go to the documentation of this file #****************************************************************************** # ISO-TP-C: ISO 15765-2 Protocol Implementation # # Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization # Description: A high-performance, embedded-grade implementation of the ISO 15765-2 (ISO-TP) protocol in C, # designed for automotive and industrial applications. This project focuses on refactoring and optimizing # the codebase to achieve maximum efficiency, reliability, and maintainability while adhering to the ISO-TP standard. # # Author: Anton Vynohradov # Email: avynohradov@systemfromscratch.com # # License: MIT License # # Copyright (c) 2026 Anton Vynohradov # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. # # SPDX-License-Identifier: MIT #***************************************************************************** \"\"\"! @file test_cantp.py @brief Integration tests for CAN TP and ISO-TP behavior. @details Exercises FC handling, timeouts, and unexpected PDU handling. @note Some tests rely on mock drop/disable helpers from the Python binding. \"\"\" # ============================================================================= # IMPORTS # ============================================================================= import pyisotp # ============================================================================= # FUNCTION PROTOTYPES # ============================================================================= def _poll_until_receive ( link , payload_size , steps , advance_ms = 0 ): \"\"\"! @brief Poll the link until a response is received or steps are exhausted. @param link ISO-TP link handle. @param payload_size Expected payload size for receive. @param steps Maximum number of poll iterations. @param advance_ms Optional time advance per step in milliseconds. @return Received payload bytes or None when nothing is received. @details Optionally advances the mock time between polls. \"\"\" resp = None for _ in range ( steps ): if advance_ms : pyisotp . time_advance ( advance_ms ) pyisotp . poll ( link ) resp = pyisotp . receive ( link , payload_size ) if resp is not None : break return resp def _make_payload ( size ): \"\"\"! @brief Build a deterministic payload of a given size. @param size Number of bytes to generate. @return Payload bytes. @details Uses a simple modulo pattern for repeatability. \"\"\" return bytes (( idx % 256 for idx in range ( size ))) def _fc_frame ( flow_status , block_size , st_min ): \"\"\"! @brief Build a Flow Control (FC) frame. @param flow_status Flow status nibble. @param block_size Block size byte. @param st_min STmin byte. @return CAN frame bytes representing the FC. @details Encodes the 0x30 PCI for flow control. \"\"\" return bytes ([ 0x30 | ( flow_status & 0x0F ), block_size & 0xFF , st_min & 0xFF , ]) # ============================================================================= # CAN TP / ISO-TP BEHAVIOR TESTS # ============================================================================= def test_wait_frame_then_continue (): \"\"\"! @brief Verify receiver resumes after WAIT then CONTINUE FC. @details WAIT should pause transmission until CONTINUE arrives. \"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) payload = _make_payload ( 20 ) pyisotp . send ( link , payload ) pyisotp . inject_can ( link , _fc_frame ( 0x1 , 1 , 0 )) pyisotp . inject_can ( link , _fc_frame ( 0x0 , 0 , 0 )) resp = _poll_until_receive ( link , 1024 , 10 ) assert resp == payload def test_wait_frame_overrun (): \"\"\"! @brief Verify WAIT frame overrun is reported. @details Repeated WAIT frames exceed the limit and trigger WFT_OVRN. \"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) payload = _make_payload ( 20 ) pyisotp . send ( link , payload ) pyisotp . inject_can ( link , _fc_frame ( 0x1 , 1 , 0 )) pyisotp . inject_can ( link , _fc_frame ( 0x1 , 1 , 0 )) assert ( pyisotp . get_last_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_WFT_OVRN ) def test_cantp_timeout_n_bs (): \"\"\"! @brief Verify N_Bs timeout is detected. @details Disables FC to force a sender block-size timeout. \"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) pyisotp . set_timeouts ( link , 30 , 10 ) pyisotp . mock_disable_fc ( True ) pyisotp . send ( link , _make_payload ( 30 )) for _ in range ( 31 ): pyisotp . time_advance ( 1 ) pyisotp . poll ( link ) assert pyisotp . get_last_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_TIMEOUT_BS def test_cantp_timeout_n_cr (): \"\"\"! @brief Verify N_Cr timeout is detected. @details Drops incoming frames to force a receiver timeout. \"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) pyisotp . set_timeouts ( link , 30 , 10 ) pyisotp . send ( link , _make_payload ( 20 )) pyisotp . poll ( link ) pyisotp . mock_enable_drop ( True ) for _ in range ( 11 ): pyisotp . time_advance ( 1 ) pyisotp . poll ( link ) assert ( pyisotp . get_last_receive_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_TIMEOUT_CR ) pyisotp . mock_enable_drop ( False ) def test_cantp_stmin_and_bs (): \"\"\"! @brief Verify STmin and block size pacing. @details Advances time to satisfy STmin between frames. \"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) pyisotp . set_fc_params ( link , 1 , 5 ) payload = _make_payload ( 25 ) pyisotp . send ( link , payload ) resp = _poll_until_receive ( link , 1024 , 20 , advance_ms = 1 ) assert resp == payload def test_cantp_unexpected_pdu (): \"\"\"! @brief Verify unexpected PDU is reported. @details Injects a CF when receiver is idle. \"\"\" link = pyisotp . init ( 0x700 , 512 , 512 ) pyisotp . inject_can ( link , bytes ([ 0x21 ]) + b \" \\xAA \" * 7 ) assert ( pyisotp . get_last_receive_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_UNEXP_PDU )","title":"File test_cantp.py"},{"location":"docs/test__cantp_8py_source/#file-test_cantppy","text":"File List > integration > test_cantp.py Go to the documentation of this file #****************************************************************************** # ISO-TP-C: ISO 15765-2 Protocol Implementation # # Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization # Description: A high-performance, embedded-grade implementation of the ISO 15765-2 (ISO-TP) protocol in C, # designed for automotive and industrial applications. This project focuses on refactoring and optimizing # the codebase to achieve maximum efficiency, reliability, and maintainability while adhering to the ISO-TP standard. # # Author: Anton Vynohradov # Email: avynohradov@systemfromscratch.com # # License: MIT License # # Copyright (c) 2026 Anton Vynohradov # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. # # SPDX-License-Identifier: MIT #***************************************************************************** \"\"\"! @file test_cantp.py @brief Integration tests for CAN TP and ISO-TP behavior. @details Exercises FC handling, timeouts, and unexpected PDU handling. @note Some tests rely on mock drop/disable helpers from the Python binding. \"\"\" # ============================================================================= # IMPORTS # ============================================================================= import pyisotp # ============================================================================= # FUNCTION PROTOTYPES # ============================================================================= def _poll_until_receive ( link , payload_size , steps , advance_ms = 0 ): \"\"\"! @brief Poll the link until a response is received or steps are exhausted. @param link ISO-TP link handle. @param payload_size Expected payload size for receive. @param steps Maximum number of poll iterations. @param advance_ms Optional time advance per step in milliseconds. @return Received payload bytes or None when nothing is received. @details Optionally advances the mock time between polls. \"\"\" resp = None for _ in range ( steps ): if advance_ms : pyisotp . time_advance ( advance_ms ) pyisotp . poll ( link ) resp = pyisotp . receive ( link , payload_size ) if resp is not None : break return resp def _make_payload ( size ): \"\"\"! @brief Build a deterministic payload of a given size. @param size Number of bytes to generate. @return Payload bytes. @details Uses a simple modulo pattern for repeatability. \"\"\" return bytes (( idx % 256 for idx in range ( size ))) def _fc_frame ( flow_status , block_size , st_min ): \"\"\"! @brief Build a Flow Control (FC) frame. @param flow_status Flow status nibble. @param block_size Block size byte. @param st_min STmin byte. @return CAN frame bytes representing the FC. @details Encodes the 0x30 PCI for flow control. \"\"\" return bytes ([ 0x30 | ( flow_status & 0x0F ), block_size & 0xFF , st_min & 0xFF , ]) # ============================================================================= # CAN TP / ISO-TP BEHAVIOR TESTS # ============================================================================= def test_wait_frame_then_continue (): \"\"\"! @brief Verify receiver resumes after WAIT then CONTINUE FC. @details WAIT should pause transmission until CONTINUE arrives. \"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) payload = _make_payload ( 20 ) pyisotp . send ( link , payload ) pyisotp . inject_can ( link , _fc_frame ( 0x1 , 1 , 0 )) pyisotp . inject_can ( link , _fc_frame ( 0x0 , 0 , 0 )) resp = _poll_until_receive ( link , 1024 , 10 ) assert resp == payload def test_wait_frame_overrun (): \"\"\"! @brief Verify WAIT frame overrun is reported. @details Repeated WAIT frames exceed the limit and trigger WFT_OVRN. \"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) payload = _make_payload ( 20 ) pyisotp . send ( link , payload ) pyisotp . inject_can ( link , _fc_frame ( 0x1 , 1 , 0 )) pyisotp . inject_can ( link , _fc_frame ( 0x1 , 1 , 0 )) assert ( pyisotp . get_last_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_WFT_OVRN ) def test_cantp_timeout_n_bs (): \"\"\"! @brief Verify N_Bs timeout is detected. @details Disables FC to force a sender block-size timeout. \"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) pyisotp . set_timeouts ( link , 30 , 10 ) pyisotp . mock_disable_fc ( True ) pyisotp . send ( link , _make_payload ( 30 )) for _ in range ( 31 ): pyisotp . time_advance ( 1 ) pyisotp . poll ( link ) assert pyisotp . get_last_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_TIMEOUT_BS def test_cantp_timeout_n_cr (): \"\"\"! @brief Verify N_Cr timeout is detected. @details Drops incoming frames to force a receiver timeout. \"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) pyisotp . set_timeouts ( link , 30 , 10 ) pyisotp . send ( link , _make_payload ( 20 )) pyisotp . poll ( link ) pyisotp . mock_enable_drop ( True ) for _ in range ( 11 ): pyisotp . time_advance ( 1 ) pyisotp . poll ( link ) assert ( pyisotp . get_last_receive_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_TIMEOUT_CR ) pyisotp . mock_enable_drop ( False ) def test_cantp_stmin_and_bs (): \"\"\"! @brief Verify STmin and block size pacing. @details Advances time to satisfy STmin between frames. \"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) pyisotp . set_fc_params ( link , 1 , 5 ) payload = _make_payload ( 25 ) pyisotp . send ( link , payload ) resp = _poll_until_receive ( link , 1024 , 20 , advance_ms = 1 ) assert resp == payload def test_cantp_unexpected_pdu (): \"\"\"! @brief Verify unexpected PDU is reported. @details Injects a CF when receiver is idle. \"\"\" link = pyisotp . init ( 0x700 , 512 , 512 ) pyisotp . inject_can ( link , bytes ([ 0x21 ]) + b \" \\xAA \" * 7 ) assert ( pyisotp . get_last_receive_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_UNEXP_PDU )","title":"File test_cantp.py"},{"location":"docs/test__flow__control_8py/","text":"File test_flow_control.py \u00b6 FileList > integration > test_flow_control.py Go to the source code of this file Integration tests for flow control handling. More... Namespaces \u00b6 Type Name namespace test_flow_control Detailed Description \u00b6 Validates protocol results set by FC overflow conditions. Note: FC frames are injected directly via the Python binding. The documentation for this class was generated from the following file tests/integration/test_flow_control.py","title":"File test_flow_control.py"},{"location":"docs/test__flow__control_8py/#file-test_flow_controlpy","text":"FileList > integration > test_flow_control.py Go to the source code of this file Integration tests for flow control handling. More...","title":"File test_flow_control.py"},{"location":"docs/test__flow__control_8py/#namespaces","text":"Type Name namespace test_flow_control","title":"Namespaces"},{"location":"docs/test__flow__control_8py/#detailed-description","text":"Validates protocol results set by FC overflow conditions. Note: FC frames are injected directly via the Python binding. The documentation for this class was generated from the following file tests/integration/test_flow_control.py","title":"Detailed Description"},{"location":"docs/test__flow__control_8py_source/","text":"File test_flow_control.py \u00b6 File List > integration > test_flow_control.py Go to the documentation of this file #****************************************************************************** # ISO-TP-C: ISO 15765-2 Protocol Implementation # # Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization # Description: A high-performance, embedded-grade implementation of the ISO 15765-2 (ISO-TP) protocol in C, # designed for automotive and industrial applications. This project focuses on refactoring and optimizing # the codebase to achieve maximum efficiency, reliability, and maintainability while adhering to the ISO-TP standard. # # Author: Anton Vynohradov # Email: avynohradov@systemfromscratch.com # # License: MIT License # # Copyright (c) 2026 Anton Vynohradov # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. # # SPDX-License-Identifier: MIT #***************************************************************************** \"\"\"! @file test_flow_control.py @brief Integration tests for flow control handling. @details Validates protocol results set by FC overflow conditions. @note FC frames are injected directly via the Python binding. \"\"\" # ============================================================================= # IMPORTS # ============================================================================= import pyisotp # ============================================================================= # FUNCTION PROTOTYPES # ============================================================================= def _make_payload ( size ): \"\"\"! @brief Build a deterministic payload of a given size. @param size Number of bytes to generate. @return Payload bytes. @details Uses a simple modulo pattern for repeatability. \"\"\" return bytes (( idx % 256 for idx in range ( size ))) def _fc_frame ( flow_status , block_size , st_min ): \"\"\"! @brief Build a Flow Control (FC) frame. @param flow_status Flow status nibble. @param block_size Block size byte. @param st_min STmin byte. @return CAN frame bytes representing the FC. @details Encodes the 0x30 PCI for flow control. \"\"\" return bytes ([ 0x30 | ( flow_status & 0x0F ), block_size & 0xFF , st_min & 0xFF , ]) # ============================================================================= # FLOW CONTROL TESTS # ============================================================================= def test_flow_control_overflow_sets_protocol_result (): \"\"\"! @brief Verify overflow FC sets protocol result. @details Injects PCI_FLOW_STATUS_OVERFLOW and checks protocol state. \"\"\" link = pyisotp . init ( 0x700 , 128 , 128 ) payload = _make_payload ( 20 ) pyisotp . send ( link , payload ) pyisotp . inject_can ( link , _fc_frame ( 0x2 , 0 , 0 )) assert ( pyisotp . get_last_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW )","title":"File test_flow_control.py"},{"location":"docs/test__flow__control_8py_source/#file-test_flow_controlpy","text":"File List > integration > test_flow_control.py Go to the documentation of this file #****************************************************************************** # ISO-TP-C: ISO 15765-2 Protocol Implementation # # Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization # Description: A high-performance, embedded-grade implementation of the ISO 15765-2 (ISO-TP) protocol in C, # designed for automotive and industrial applications. This project focuses on refactoring and optimizing # the codebase to achieve maximum efficiency, reliability, and maintainability while adhering to the ISO-TP standard. # # Author: Anton Vynohradov # Email: avynohradov@systemfromscratch.com # # License: MIT License # # Copyright (c) 2026 Anton Vynohradov # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. # # SPDX-License-Identifier: MIT #***************************************************************************** \"\"\"! @file test_flow_control.py @brief Integration tests for flow control handling. @details Validates protocol results set by FC overflow conditions. @note FC frames are injected directly via the Python binding. \"\"\" # ============================================================================= # IMPORTS # ============================================================================= import pyisotp # ============================================================================= # FUNCTION PROTOTYPES # ============================================================================= def _make_payload ( size ): \"\"\"! @brief Build a deterministic payload of a given size. @param size Number of bytes to generate. @return Payload bytes. @details Uses a simple modulo pattern for repeatability. \"\"\" return bytes (( idx % 256 for idx in range ( size ))) def _fc_frame ( flow_status , block_size , st_min ): \"\"\"! @brief Build a Flow Control (FC) frame. @param flow_status Flow status nibble. @param block_size Block size byte. @param st_min STmin byte. @return CAN frame bytes representing the FC. @details Encodes the 0x30 PCI for flow control. \"\"\" return bytes ([ 0x30 | ( flow_status & 0x0F ), block_size & 0xFF , st_min & 0xFF , ]) # ============================================================================= # FLOW CONTROL TESTS # ============================================================================= def test_flow_control_overflow_sets_protocol_result (): \"\"\"! @brief Verify overflow FC sets protocol result. @details Injects PCI_FLOW_STATUS_OVERFLOW and checks protocol state. \"\"\" link = pyisotp . init ( 0x700 , 128 , 128 ) payload = _make_payload ( 20 ) pyisotp . send ( link , payload ) pyisotp . inject_can ( link , _fc_frame ( 0x2 , 0 , 0 )) assert ( pyisotp . get_last_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW )","title":"File test_flow_control.py"},{"location":"docs/test__multi__frame_8py/","text":"File test_multi_frame.py \u00b6 FileList > integration > test_multi_frame.py Go to the source code of this file Integration tests for multi-frame ISO-TP transfers. More... Namespaces \u00b6 Type Name namespace test_multi_frame Detailed Description \u00b6 Covers boundary sizes, timeouts, and sequence handling. Note: Time advances rely on mock time helpers in the binding. The documentation for this class was generated from the following file tests/integration/test_multi_frame.py","title":"File test_multi_frame.py"},{"location":"docs/test__multi__frame_8py/#file-test_multi_framepy","text":"FileList > integration > test_multi_frame.py Go to the source code of this file Integration tests for multi-frame ISO-TP transfers. More...","title":"File test_multi_frame.py"},{"location":"docs/test__multi__frame_8py/#namespaces","text":"Type Name namespace test_multi_frame","title":"Namespaces"},{"location":"docs/test__multi__frame_8py/#detailed-description","text":"Covers boundary sizes, timeouts, and sequence handling. Note: Time advances rely on mock time helpers in the binding. The documentation for this class was generated from the following file tests/integration/test_multi_frame.py","title":"Detailed Description"},{"location":"docs/test__multi__frame_8py_source/","text":"File test_multi_frame.py \u00b6 File List > integration > test_multi_frame.py Go to the documentation of this file #****************************************************************************** # ISO-TP-C: ISO 15765-2 Protocol Implementation # # Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization # Description: A high-performance, embedded-grade implementation of the ISO 15765-2 (ISO-TP) protocol in C, # designed for automotive and industrial applications. This project focuses on refactoring and optimizing # the codebase to achieve maximum efficiency, reliability, and maintainability while adhering to the ISO-TP standard. # # Author: Anton Vynohradov # Email: avynohradov@systemfromscratch.com # # License: MIT License # # Copyright (c) 2026 Anton Vynohradov # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. # # SPDX-License-Identifier: MIT #***************************************************************************** \"\"\"! @file test_multi_frame.py @brief Integration tests for multi-frame ISO-TP transfers. @details Covers boundary sizes, timeouts, and sequence handling. @note Time advances rely on mock time helpers in the binding. \"\"\" # ============================================================================= # IMPORTS # ============================================================================= import pyisotp import pytest # ============================================================================= # FUNCTION PROTOTYPES # ============================================================================= def _poll_until_receive ( link , payload_size , steps , advance_ms = 0 ): \"\"\"! @brief Poll the link until a response is received or steps are exhausted. @param link ISO-TP link handle. @param payload_size Expected payload size for receive. @param steps Maximum number of poll iterations. @param advance_ms Optional time advance per step in milliseconds. @return Received payload bytes or None when nothing is received. @details Optionally advances the mock time between polls. \"\"\" resp = None for _ in range ( steps ): if advance_ms : pyisotp . time_advance ( advance_ms ) pyisotp . poll ( link ) resp = pyisotp . receive ( link , payload_size ) if resp is not None : break return resp def _make_payload ( size ): \"\"\"! @brief Build a deterministic payload of a given size. @param size Number of bytes to generate. @return Payload bytes. @details Uses a simple modulo pattern for repeatability. \"\"\" return bytes (( idx % 256 for idx in range ( size ))) def _ff_frame ( payload_size , payload ): \"\"\"! @brief Build a First Frame (FF) for an ISO-TP transfer. @param payload_size Total payload size. @param payload Payload bytes to embed in FF. @return CAN frame bytes representing the FF. @details Encodes the 0x10 PCI with 12-bit length. \"\"\" ff_dl_high = ( payload_size >> 8 ) & 0x0F ff_dl_low = payload_size & 0xFF return bytes ([ 0x10 | ff_dl_high , ff_dl_low ]) + payload [: 6 ] def _cf_frame ( sn , payload ): \"\"\"! @brief Build a Consecutive Frame (CF) with a given sequence number. @param sn Sequence number (0-15). @param payload Payload bytes to embed in CF. @return CAN frame bytes representing the CF. @details Encodes the 0x20 PCI with SN. \"\"\" return bytes ([ 0x20 | ( sn & 0x0F )]) + payload [: 7 ] def test_multi_frame_roundtrip (): \"\"\"! @brief Verify multi-frame roundtrip delivery. @details Ensures payload integrity across segmented transfer. \"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) payload = b \" \\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0A\\x0B\\x0C \" pyisotp . send ( link , payload ) resp = _poll_until_receive ( link , 1024 , 3 ) assert resp == payload @pytest . mark . parametrize ( \"size\" , [ 8 , 9 , 14 , 15 ]) def test_multi_frame_boundary_sizes ( size ): \"\"\"! @brief Verify multi-frame behavior around boundary sizes. @param size Payload size under test. @details Exercises sizes near the SF/FF boundary. \"\"\" link = pyisotp . init ( 0x700 , 2048 , 2048 ) payload = _make_payload ( size ) pyisotp . send ( link , payload ) resp = _poll_until_receive ( link , 2048 , 5 ) assert resp == payload def test_multi_frame_max_payload (): \"\"\"! @brief Verify maximum payload size roundtrip. @details Uses a large payload to stress segmentation and reassembly. \"\"\" link = pyisotp . init ( 0x700 , 4096 , 4096 ) payload = _make_payload ( 4095 ) pyisotp . send ( link , payload ) resp = _poll_until_receive ( link , 4096 , 800 ) assert resp == payload def test_multi_frame_bs_one_stmin (): \"\"\"! @brief Verify block size 1 with STmin pacing. @details Advances time between frames to satisfy STmin. \"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) pyisotp . set_fc_params ( link , 1 , 5 ) payload = _make_payload ( 30 ) pyisotp . send ( link , payload ) resp = _poll_until_receive ( link , 1024 , 20 , advance_ms = 1 ) assert resp == payload def test_multi_frame_bs_unlimited_stmin (): \"\"\"! @brief Verify unlimited block size with STmin pacing. @details Exercises BS=0 with STmin delay. \"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) pyisotp . set_fc_params ( link , 0 , 5 ) payload = _make_payload ( 30 ) pyisotp . send ( link , payload ) resp = _poll_until_receive ( link , 1024 , 20 , advance_ms = 1 ) assert resp == payload def test_multi_frame_timeout_n_bs (): \"\"\"! @brief Verify N_Bs timeout during multi-frame send. @details Disables FC to force sender block-size timeout. \"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) pyisotp . set_timeouts ( link , 50 , 50 ) pyisotp . mock_disable_fc ( True ) pyisotp . send ( link , _make_payload ( 30 )) for _ in range ( 51 ): pyisotp . time_advance ( 1 ) pyisotp . poll ( link ) assert pyisotp . get_last_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_TIMEOUT_BS def test_multi_frame_timeout_n_cr (): \"\"\"! @brief Verify N_Cr timeout during multi-frame receive. @details Drops incoming frames to force receiver timeout. \"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) pyisotp . set_timeouts ( link , 50 , 10 ) pyisotp . send ( link , _make_payload ( 20 )) pyisotp . poll ( link ) pyisotp . mock_enable_drop ( True ) for _ in range ( 11 ): pyisotp . time_advance ( 1 ) pyisotp . poll ( link ) assert ( pyisotp . get_last_receive_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_TIMEOUT_CR ) pyisotp . mock_enable_drop ( False ) def test_multi_frame_unexpected_cf (): \"\"\"! @brief Verify unexpected CF is reported. @details Injects a CF when receiver is idle. \"\"\" link = pyisotp . init ( 0x700 , 512 , 512 ) pyisotp . inject_can ( link , _cf_frame ( 1 , b \" \\xAA \" * 7 )) assert ( pyisotp . get_last_receive_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_UNEXP_PDU ) def test_multi_frame_wrong_sn (): \"\"\"! @brief Verify wrong sequence number is reported. @details Injects a CF with unexpected SN after FF. \"\"\" link = pyisotp . init ( 0x700 , 512 , 512 ) payload = _make_payload ( 20 ) pyisotp . inject_can ( link , _ff_frame ( len ( payload ), payload )) pyisotp . inject_can ( link , _cf_frame ( 5 , payload [ 6 : 13 ])) assert ( pyisotp . get_last_receive_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_WRONG_SN )","title":"File test_multi_frame.py"},{"location":"docs/test__multi__frame_8py_source/#file-test_multi_framepy","text":"File List > integration > test_multi_frame.py Go to the documentation of this file #****************************************************************************** # ISO-TP-C: ISO 15765-2 Protocol Implementation # # Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization # Description: A high-performance, embedded-grade implementation of the ISO 15765-2 (ISO-TP) protocol in C, # designed for automotive and industrial applications. This project focuses on refactoring and optimizing # the codebase to achieve maximum efficiency, reliability, and maintainability while adhering to the ISO-TP standard. # # Author: Anton Vynohradov # Email: avynohradov@systemfromscratch.com # # License: MIT License # # Copyright (c) 2026 Anton Vynohradov # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. # # SPDX-License-Identifier: MIT #***************************************************************************** \"\"\"! @file test_multi_frame.py @brief Integration tests for multi-frame ISO-TP transfers. @details Covers boundary sizes, timeouts, and sequence handling. @note Time advances rely on mock time helpers in the binding. \"\"\" # ============================================================================= # IMPORTS # ============================================================================= import pyisotp import pytest # ============================================================================= # FUNCTION PROTOTYPES # ============================================================================= def _poll_until_receive ( link , payload_size , steps , advance_ms = 0 ): \"\"\"! @brief Poll the link until a response is received or steps are exhausted. @param link ISO-TP link handle. @param payload_size Expected payload size for receive. @param steps Maximum number of poll iterations. @param advance_ms Optional time advance per step in milliseconds. @return Received payload bytes or None when nothing is received. @details Optionally advances the mock time between polls. \"\"\" resp = None for _ in range ( steps ): if advance_ms : pyisotp . time_advance ( advance_ms ) pyisotp . poll ( link ) resp = pyisotp . receive ( link , payload_size ) if resp is not None : break return resp def _make_payload ( size ): \"\"\"! @brief Build a deterministic payload of a given size. @param size Number of bytes to generate. @return Payload bytes. @details Uses a simple modulo pattern for repeatability. \"\"\" return bytes (( idx % 256 for idx in range ( size ))) def _ff_frame ( payload_size , payload ): \"\"\"! @brief Build a First Frame (FF) for an ISO-TP transfer. @param payload_size Total payload size. @param payload Payload bytes to embed in FF. @return CAN frame bytes representing the FF. @details Encodes the 0x10 PCI with 12-bit length. \"\"\" ff_dl_high = ( payload_size >> 8 ) & 0x0F ff_dl_low = payload_size & 0xFF return bytes ([ 0x10 | ff_dl_high , ff_dl_low ]) + payload [: 6 ] def _cf_frame ( sn , payload ): \"\"\"! @brief Build a Consecutive Frame (CF) with a given sequence number. @param sn Sequence number (0-15). @param payload Payload bytes to embed in CF. @return CAN frame bytes representing the CF. @details Encodes the 0x20 PCI with SN. \"\"\" return bytes ([ 0x20 | ( sn & 0x0F )]) + payload [: 7 ] def test_multi_frame_roundtrip (): \"\"\"! @brief Verify multi-frame roundtrip delivery. @details Ensures payload integrity across segmented transfer. \"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) payload = b \" \\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0A\\x0B\\x0C \" pyisotp . send ( link , payload ) resp = _poll_until_receive ( link , 1024 , 3 ) assert resp == payload @pytest . mark . parametrize ( \"size\" , [ 8 , 9 , 14 , 15 ]) def test_multi_frame_boundary_sizes ( size ): \"\"\"! @brief Verify multi-frame behavior around boundary sizes. @param size Payload size under test. @details Exercises sizes near the SF/FF boundary. \"\"\" link = pyisotp . init ( 0x700 , 2048 , 2048 ) payload = _make_payload ( size ) pyisotp . send ( link , payload ) resp = _poll_until_receive ( link , 2048 , 5 ) assert resp == payload def test_multi_frame_max_payload (): \"\"\"! @brief Verify maximum payload size roundtrip. @details Uses a large payload to stress segmentation and reassembly. \"\"\" link = pyisotp . init ( 0x700 , 4096 , 4096 ) payload = _make_payload ( 4095 ) pyisotp . send ( link , payload ) resp = _poll_until_receive ( link , 4096 , 800 ) assert resp == payload def test_multi_frame_bs_one_stmin (): \"\"\"! @brief Verify block size 1 with STmin pacing. @details Advances time between frames to satisfy STmin. \"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) pyisotp . set_fc_params ( link , 1 , 5 ) payload = _make_payload ( 30 ) pyisotp . send ( link , payload ) resp = _poll_until_receive ( link , 1024 , 20 , advance_ms = 1 ) assert resp == payload def test_multi_frame_bs_unlimited_stmin (): \"\"\"! @brief Verify unlimited block size with STmin pacing. @details Exercises BS=0 with STmin delay. \"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) pyisotp . set_fc_params ( link , 0 , 5 ) payload = _make_payload ( 30 ) pyisotp . send ( link , payload ) resp = _poll_until_receive ( link , 1024 , 20 , advance_ms = 1 ) assert resp == payload def test_multi_frame_timeout_n_bs (): \"\"\"! @brief Verify N_Bs timeout during multi-frame send. @details Disables FC to force sender block-size timeout. \"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) pyisotp . set_timeouts ( link , 50 , 50 ) pyisotp . mock_disable_fc ( True ) pyisotp . send ( link , _make_payload ( 30 )) for _ in range ( 51 ): pyisotp . time_advance ( 1 ) pyisotp . poll ( link ) assert pyisotp . get_last_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_TIMEOUT_BS def test_multi_frame_timeout_n_cr (): \"\"\"! @brief Verify N_Cr timeout during multi-frame receive. @details Drops incoming frames to force receiver timeout. \"\"\" link = pyisotp . init ( 0x700 , 1024 , 1024 ) pyisotp . set_timeouts ( link , 50 , 10 ) pyisotp . send ( link , _make_payload ( 20 )) pyisotp . poll ( link ) pyisotp . mock_enable_drop ( True ) for _ in range ( 11 ): pyisotp . time_advance ( 1 ) pyisotp . poll ( link ) assert ( pyisotp . get_last_receive_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_TIMEOUT_CR ) pyisotp . mock_enable_drop ( False ) def test_multi_frame_unexpected_cf (): \"\"\"! @brief Verify unexpected CF is reported. @details Injects a CF when receiver is idle. \"\"\" link = pyisotp . init ( 0x700 , 512 , 512 ) pyisotp . inject_can ( link , _cf_frame ( 1 , b \" \\xAA \" * 7 )) assert ( pyisotp . get_last_receive_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_UNEXP_PDU ) def test_multi_frame_wrong_sn (): \"\"\"! @brief Verify wrong sequence number is reported. @details Injects a CF with unexpected SN after FF. \"\"\" link = pyisotp . init ( 0x700 , 512 , 512 ) payload = _make_payload ( 20 ) pyisotp . inject_can ( link , _ff_frame ( len ( payload ), payload )) pyisotp . inject_can ( link , _cf_frame ( 5 , payload [ 6 : 13 ])) assert ( pyisotp . get_last_receive_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_WRONG_SN )","title":"File test_multi_frame.py"},{"location":"docs/test__timing_8py/","text":"File test_timing.py \u00b6 FileList > integration > test_timing.py Go to the source code of this file Integration tests for timing-related ISO-TP behavior. More... Namespaces \u00b6 Type Name namespace test_timing Detailed Description \u00b6 Covers N_Bs/N_Cr timeouts, STmin pacing, and BS=1 behavior. Note: Several placeholder tests are marked xfail until core support lands. The documentation for this class was generated from the following file tests/integration/test_timing.py","title":"File test_timing.py"},{"location":"docs/test__timing_8py/#file-test_timingpy","text":"FileList > integration > test_timing.py Go to the source code of this file Integration tests for timing-related ISO-TP behavior. More...","title":"File test_timing.py"},{"location":"docs/test__timing_8py/#namespaces","text":"Type Name namespace test_timing","title":"Namespaces"},{"location":"docs/test__timing_8py/#detailed-description","text":"Covers N_Bs/N_Cr timeouts, STmin pacing, and BS=1 behavior. Note: Several placeholder tests are marked xfail until core support lands. The documentation for this class was generated from the following file tests/integration/test_timing.py","title":"Detailed Description"},{"location":"docs/test__timing_8py_source/","text":"File test_timing.py \u00b6 File List > integration > test_timing.py Go to the documentation of this file #****************************************************************************** # ISO-TP-C: ISO 15765-2 Protocol Implementation # # Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization # Description: A high-performance, embedded-grade implementation of the ISO 15765-2 (ISO-TP) protocol in C, # designed for automotive and industrial applications. This project focuses on refactoring and optimizing # the codebase to achieve maximum efficiency, reliability, and maintainability while adhering to the ISO-TP standard. # # Author: Anton Vynohradov # Email: avynohradov@systemfromscratch.com # # License: MIT License # # Copyright (c) 2026 Anton Vynohradov # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. # # SPDX-License-Identifier: MIT #***************************************************************************** \"\"\"! @file test_timing.py @brief Integration tests for timing-related ISO-TP behavior. @details Covers N_Bs/N_Cr timeouts, STmin pacing, and BS=1 behavior. @note Several placeholder tests are marked xfail until core support lands. \"\"\" # ============================================================================= # IMPORTS # ============================================================================= import pyisotp import pytest # ============================================================================= # FUNCTION PROTOTYPES # ============================================================================= def test_timeout_n_bs (): \"\"\"! @brief Verify N_Bs timeout handling. @details Disables FC to force sender timeout. \"\"\" link = pyisotp . init ( 0x700 , 512 , 512 ) pyisotp . set_timeouts ( link , 100 , 100 ) pyisotp . mock_disable_fc ( True ) pyisotp . send ( link , bytes ( range ( 50 ))) for _ in range ( 101 ): pyisotp . time_advance ( 1 ) pyisotp . poll ( link ) # expect timeout according to ISO-15765 assert pyisotp . get_last_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_TIMEOUT_BS def test_timeout_n_cr (): \"\"\"! @brief Verify N_Cr timeout handling. @details Drops incoming frames to force receiver timeout. \"\"\" link = pyisotp . init ( 0x700 , 512 , 512 ) pyisotp . set_timeouts ( link , 100 , 20 ) pyisotp . send ( link , bytes ( range ( 12 ))) pyisotp . poll ( link ) pyisotp . mock_enable_drop ( True ) for _ in range ( 21 ): pyisotp . time_advance ( 1 ) pyisotp . poll ( link ) assert ( pyisotp . get_last_receive_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_TIMEOUT_CR ) pyisotp . mock_enable_drop ( False ) def test_st_min_enforced (): \"\"\"! @brief Verify STmin delay is enforced. @details Ensures receive does not complete before STmin elapses. \"\"\" link = pyisotp . init ( 0x700 , 512 , 512 ) pyisotp . set_fc_params ( link , 0 , 10 ) payload = bytes ( range ( 20 )) pyisotp . send ( link , payload ) pyisotp . poll ( link ) for _ in range ( 9 ): pyisotp . time_advance ( 1 ) pyisotp . poll ( link ) assert pyisotp . receive ( link , 512 ) is None resp = None for _ in range ( 10 ): pyisotp . time_advance ( 1 ) pyisotp . poll ( link ) resp = pyisotp . receive ( link , 512 ) if resp is not None : break assert resp == payload def test_block_size_one_roundtrip (): \"\"\"! @brief Verify block size one roundtrip behavior. @details Uses BS=1 to enforce FC after each CF. \"\"\" link = pyisotp . init ( 0x700 , 512 , 512 ) pyisotp . set_fc_params ( link , 1 , 0 ) payload = bytes ( range ( 30 )) pyisotp . send ( link , payload ) resp = None for _ in range ( 10 ): pyisotp . poll ( link ) resp = pyisotp . receive ( link , 512 ) if resp is not None : break assert resp == payload @pytest . mark . xfail ( reason = \"N_As not enforced by core yet\" ) def test_timeout_n_as_placeholder (): \"\"\"! @brief Placeholder for N_As timeout support. @note Marked xfail until core enforces N_As. \"\"\" assert False @pytest . mark . xfail ( reason = \"N_Ar not enforced by core yet\" ) def test_timeout_n_ar_placeholder (): \"\"\"! @brief Placeholder for N_Ar timeout support. @note Marked xfail until core enforces N_Ar. \"\"\" assert False @pytest . mark . xfail ( reason = \"N_Br not enforced by core yet\" ) def test_timeout_n_br_placeholder (): \"\"\"! @brief Placeholder for N_Br timeout support. @note Marked xfail until core enforces N_Br. \"\"\" assert False @pytest . mark . xfail ( reason = \"N_Cs not enforced by core yet\" ) def test_timeout_n_cs_placeholder (): \"\"\"! @brief Placeholder for N_Cs timeout support. @note Marked xfail until core enforces N_Cs. \"\"\" assert False","title":"File test_timing.py"},{"location":"docs/test__timing_8py_source/#file-test_timingpy","text":"File List > integration > test_timing.py Go to the documentation of this file #****************************************************************************** # ISO-TP-C: ISO 15765-2 Protocol Implementation # # Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization # Description: A high-performance, embedded-grade implementation of the ISO 15765-2 (ISO-TP) protocol in C, # designed for automotive and industrial applications. This project focuses on refactoring and optimizing # the codebase to achieve maximum efficiency, reliability, and maintainability while adhering to the ISO-TP standard. # # Author: Anton Vynohradov # Email: avynohradov@systemfromscratch.com # # License: MIT License # # Copyright (c) 2026 Anton Vynohradov # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. # # SPDX-License-Identifier: MIT #***************************************************************************** \"\"\"! @file test_timing.py @brief Integration tests for timing-related ISO-TP behavior. @details Covers N_Bs/N_Cr timeouts, STmin pacing, and BS=1 behavior. @note Several placeholder tests are marked xfail until core support lands. \"\"\" # ============================================================================= # IMPORTS # ============================================================================= import pyisotp import pytest # ============================================================================= # FUNCTION PROTOTYPES # ============================================================================= def test_timeout_n_bs (): \"\"\"! @brief Verify N_Bs timeout handling. @details Disables FC to force sender timeout. \"\"\" link = pyisotp . init ( 0x700 , 512 , 512 ) pyisotp . set_timeouts ( link , 100 , 100 ) pyisotp . mock_disable_fc ( True ) pyisotp . send ( link , bytes ( range ( 50 ))) for _ in range ( 101 ): pyisotp . time_advance ( 1 ) pyisotp . poll ( link ) # expect timeout according to ISO-15765 assert pyisotp . get_last_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_TIMEOUT_BS def test_timeout_n_cr (): \"\"\"! @brief Verify N_Cr timeout handling. @details Drops incoming frames to force receiver timeout. \"\"\" link = pyisotp . init ( 0x700 , 512 , 512 ) pyisotp . set_timeouts ( link , 100 , 20 ) pyisotp . send ( link , bytes ( range ( 12 ))) pyisotp . poll ( link ) pyisotp . mock_enable_drop ( True ) for _ in range ( 21 ): pyisotp . time_advance ( 1 ) pyisotp . poll ( link ) assert ( pyisotp . get_last_receive_protocol_result ( link ) == pyisotp . ISOTP_PROTOCOL_RESULT_TIMEOUT_CR ) pyisotp . mock_enable_drop ( False ) def test_st_min_enforced (): \"\"\"! @brief Verify STmin delay is enforced. @details Ensures receive does not complete before STmin elapses. \"\"\" link = pyisotp . init ( 0x700 , 512 , 512 ) pyisotp . set_fc_params ( link , 0 , 10 ) payload = bytes ( range ( 20 )) pyisotp . send ( link , payload ) pyisotp . poll ( link ) for _ in range ( 9 ): pyisotp . time_advance ( 1 ) pyisotp . poll ( link ) assert pyisotp . receive ( link , 512 ) is None resp = None for _ in range ( 10 ): pyisotp . time_advance ( 1 ) pyisotp . poll ( link ) resp = pyisotp . receive ( link , 512 ) if resp is not None : break assert resp == payload def test_block_size_one_roundtrip (): \"\"\"! @brief Verify block size one roundtrip behavior. @details Uses BS=1 to enforce FC after each CF. \"\"\" link = pyisotp . init ( 0x700 , 512 , 512 ) pyisotp . set_fc_params ( link , 1 , 0 ) payload = bytes ( range ( 30 )) pyisotp . send ( link , payload ) resp = None for _ in range ( 10 ): pyisotp . poll ( link ) resp = pyisotp . receive ( link , 512 ) if resp is not None : break assert resp == payload @pytest . mark . xfail ( reason = \"N_As not enforced by core yet\" ) def test_timeout_n_as_placeholder (): \"\"\"! @brief Placeholder for N_As timeout support. @note Marked xfail until core enforces N_As. \"\"\" assert False @pytest . mark . xfail ( reason = \"N_Ar not enforced by core yet\" ) def test_timeout_n_ar_placeholder (): \"\"\"! @brief Placeholder for N_Ar timeout support. @note Marked xfail until core enforces N_Ar. \"\"\" assert False @pytest . mark . xfail ( reason = \"N_Br not enforced by core yet\" ) def test_timeout_n_br_placeholder (): \"\"\"! @brief Placeholder for N_Br timeout support. @note Marked xfail until core enforces N_Br. \"\"\" assert False @pytest . mark . xfail ( reason = \"N_Cs not enforced by core yet\" ) def test_timeout_n_cs_placeholder (): \"\"\"! @brief Placeholder for N_Cs timeout support. @note Marked xfail until core enforces N_Cs. \"\"\" assert False","title":"File test_timing.py"},{"location":"docs/dir_7711e90abc3d4bd55823d9013a185d04/","text":"Dir tests/unit \u00b6 FileList > tests > unit Files \u00b6 Type Name file gtest_isotp_destroy_link.cpp Unit tests for isotp_destroy_link. file gtest_isotp_init_link.cpp Unit tests for isotp_init_link. file gtest_isotp_on_can_message.cpp Unit tests for isotp_on_can_message. file gtest_isotp_poll.cpp Unit tests for isotp_poll. file gtest_isotp_receive.cpp Unit tests for isotp_receive. file gtest_isotp_send.cpp Unit tests for isotp_send. file gtest_isotp_send_with_id.cpp Unit tests for isotp_send_with_id. file isotp_test_mocks.cpp Test doubles for ISO-TP user callbacks. file isotp_test_support.h Test support utilities and mocks. The documentation for this class was generated from the following file tests/unit/","title":"Dir tests/unit"},{"location":"docs/dir_7711e90abc3d4bd55823d9013a185d04/#dir-testsunit","text":"FileList > tests > unit","title":"Dir tests/unit"},{"location":"docs/dir_7711e90abc3d4bd55823d9013a185d04/#files","text":"Type Name file gtest_isotp_destroy_link.cpp Unit tests for isotp_destroy_link. file gtest_isotp_init_link.cpp Unit tests for isotp_init_link. file gtest_isotp_on_can_message.cpp Unit tests for isotp_on_can_message. file gtest_isotp_poll.cpp Unit tests for isotp_poll. file gtest_isotp_receive.cpp Unit tests for isotp_receive. file gtest_isotp_send.cpp Unit tests for isotp_send. file gtest_isotp_send_with_id.cpp Unit tests for isotp_send_with_id. file isotp_test_mocks.cpp Test doubles for ISO-TP user callbacks. file isotp_test_support.h Test support utilities and mocks. The documentation for this class was generated from the following file tests/unit/","title":"Files"},{"location":"docs/gtest__isotp__destroy__link_8cpp/","text":"File gtest_isotp_destroy_link.cpp \u00b6 FileList > tests > unit > gtest_isotp_destroy_link.cpp Go to the source code of this file Unit tests for isotp_destroy_link. More... #include <gtest/gtest.h> #include \"isotp_test_support.h\" Public Functions \u00b6 Type Name TEST (IsotpDestroyLink, ClearsState) Link memory is zeroed after destroy. TEST (IsotpDestroyLink, NullIsNoOp) Null link is treated as a no-op. Detailed Description \u00b6 Validates link cleanup and null safety. Public Functions Documentation \u00b6 function TEST \u00b6 Link memory is zeroed after destroy. TEST ( IsotpDestroyLink , ClearsState ) function TEST \u00b6 Null link is treated as a no-op. TEST ( IsotpDestroyLink , NullIsNoOp ) The documentation for this class was generated from the following file tests/unit/gtest_isotp_destroy_link.cpp","title":"File gtest_isotp_destroy_link.cpp"},{"location":"docs/gtest__isotp__destroy__link_8cpp/#file-gtest_isotp_destroy_linkcpp","text":"FileList > tests > unit > gtest_isotp_destroy_link.cpp Go to the source code of this file Unit tests for isotp_destroy_link. More... #include <gtest/gtest.h> #include \"isotp_test_support.h\"","title":"File gtest_isotp_destroy_link.cpp"},{"location":"docs/gtest__isotp__destroy__link_8cpp/#public-functions","text":"Type Name TEST (IsotpDestroyLink, ClearsState) Link memory is zeroed after destroy. TEST (IsotpDestroyLink, NullIsNoOp) Null link is treated as a no-op.","title":"Public Functions"},{"location":"docs/gtest__isotp__destroy__link_8cpp/#detailed-description","text":"Validates link cleanup and null safety.","title":"Detailed Description"},{"location":"docs/gtest__isotp__destroy__link_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/gtest__isotp__destroy__link_8cpp/#function-test","text":"Link memory is zeroed after destroy. TEST ( IsotpDestroyLink , ClearsState )","title":"function TEST"},{"location":"docs/gtest__isotp__destroy__link_8cpp/#function-test_1","text":"Null link is treated as a no-op. TEST ( IsotpDestroyLink , NullIsNoOp ) The documentation for this class was generated from the following file tests/unit/gtest_isotp_destroy_link.cpp","title":"function TEST"},{"location":"docs/gtest__isotp__destroy__link_8cpp_source/","text":"File gtest_isotp_destroy_link.cpp \u00b6 File List > tests > unit > gtest_isotp_destroy_link.cpp Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Unit tests for isotp_destroy_link * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <gtest/gtest.h> #include \"isotp_test_support.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Macros and constants for this test file */ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Local type definitions */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ /* static variables */ /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ /* static helpers */ /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* static helper implementations */ /* ============================================================================== * UNIT TEST IMPLEMENTATIONS * =============================================================================*/ TEST ( IsotpDestroyLink , ClearsState ) { IsoTpLink link ; std :: memset ( & link , 0x5A , sizeof ( link )); isotp_destroy_link ( & link ); IsoTpLink zeroed ; std :: memset ( & zeroed , 0 , sizeof ( zeroed )); EXPECT_EQ ( std :: memcmp ( & link , & zeroed , sizeof ( link )), 0 ); } TEST ( IsotpDestroyLink , NullIsNoOp ) { EXPECT_NO_FATAL_FAILURE ( isotp_destroy_link ( NULL )); }","title":"File gtest_isotp_destroy_link.cpp"},{"location":"docs/gtest__isotp__destroy__link_8cpp_source/#file-gtest_isotp_destroy_linkcpp","text":"File List > tests > unit > gtest_isotp_destroy_link.cpp Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Unit tests for isotp_destroy_link * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <gtest/gtest.h> #include \"isotp_test_support.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Macros and constants for this test file */ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Local type definitions */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ /* static variables */ /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ /* static helpers */ /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* static helper implementations */ /* ============================================================================== * UNIT TEST IMPLEMENTATIONS * =============================================================================*/ TEST ( IsotpDestroyLink , ClearsState ) { IsoTpLink link ; std :: memset ( & link , 0x5A , sizeof ( link )); isotp_destroy_link ( & link ); IsoTpLink zeroed ; std :: memset ( & zeroed , 0 , sizeof ( zeroed )); EXPECT_EQ ( std :: memcmp ( & link , & zeroed , sizeof ( link )), 0 ); } TEST ( IsotpDestroyLink , NullIsNoOp ) { EXPECT_NO_FATAL_FAILURE ( isotp_destroy_link ( NULL )); }","title":"File gtest_isotp_destroy_link.cpp"},{"location":"docs/gtest__isotp__init__link_8cpp/","text":"File gtest_isotp_init_link.cpp \u00b6 FileList > tests > unit > gtest_isotp_init_link.cpp Go to the source code of this file Unit tests for isotp_init_link. More... #include <gtest/gtest.h> #include \"isotp_test_support.h\" Public Functions \u00b6 Type Name TEST (IsotpInitLink, InitializesFields) Initializes link fields from inputs. Detailed Description \u00b6 Verifies fields are initialized from provided buffers and IDs. Public Functions Documentation \u00b6 function TEST \u00b6 Initializes link fields from inputs. TEST ( IsotpInitLink , InitializesFields ) The documentation for this class was generated from the following file tests/unit/gtest_isotp_init_link.cpp","title":"File gtest_isotp_init_link.cpp"},{"location":"docs/gtest__isotp__init__link_8cpp/#file-gtest_isotp_init_linkcpp","text":"FileList > tests > unit > gtest_isotp_init_link.cpp Go to the source code of this file Unit tests for isotp_init_link. More... #include <gtest/gtest.h> #include \"isotp_test_support.h\"","title":"File gtest_isotp_init_link.cpp"},{"location":"docs/gtest__isotp__init__link_8cpp/#public-functions","text":"Type Name TEST (IsotpInitLink, InitializesFields) Initializes link fields from inputs.","title":"Public Functions"},{"location":"docs/gtest__isotp__init__link_8cpp/#detailed-description","text":"Verifies fields are initialized from provided buffers and IDs.","title":"Detailed Description"},{"location":"docs/gtest__isotp__init__link_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/gtest__isotp__init__link_8cpp/#function-test","text":"Initializes link fields from inputs. TEST ( IsotpInitLink , InitializesFields ) The documentation for this class was generated from the following file tests/unit/gtest_isotp_init_link.cpp","title":"function TEST"},{"location":"docs/gtest__isotp__init__link_8cpp_source/","text":"File gtest_isotp_init_link.cpp \u00b6 File List > tests > unit > gtest_isotp_init_link.cpp Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Unit tests for isotp_init_link. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <gtest/gtest.h> #include \"isotp_test_support.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Macros and constants for this test file */ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Local type definitions */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ /* static variables */ /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ /* static helpers */ /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* static helper implementations */ /* ============================================================================== * UNIT TEST IMPLEMENTATIONS * =============================================================================*/ TEST ( IsotpInitLink , InitializesFields ) { IsoTpLink link ; uint8_t sendbuf [ 32 ] = { 0 }; uint8_t recvbuf [ 48 ] = { 0 }; std :: memset ( & link , 0xA5 , sizeof ( link )); isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); EXPECT_EQ ( link . send_arbitration_id , 0x123u ); EXPECT_EQ ( link . send_buffer , sendbuf ); EXPECT_EQ ( link . send_buf_size , sizeof ( sendbuf )); EXPECT_EQ ( link . receive_buffer , recvbuf ); EXPECT_EQ ( link . receive_buf_size , sizeof ( recvbuf )); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_IDLE ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_IDLE ); EXPECT_EQ ( link . send_size , 0u ); EXPECT_EQ ( link . receive_size , 0u ); EXPECT_EQ ( link . send_offset , 0u ); EXPECT_EQ ( link . receive_offset , 0u ); }","title":"File gtest_isotp_init_link.cpp"},{"location":"docs/gtest__isotp__init__link_8cpp_source/#file-gtest_isotp_init_linkcpp","text":"File List > tests > unit > gtest_isotp_init_link.cpp Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Unit tests for isotp_init_link. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <gtest/gtest.h> #include \"isotp_test_support.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Macros and constants for this test file */ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Local type definitions */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ /* static variables */ /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ /* static helpers */ /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* static helper implementations */ /* ============================================================================== * UNIT TEST IMPLEMENTATIONS * =============================================================================*/ TEST ( IsotpInitLink , InitializesFields ) { IsoTpLink link ; uint8_t sendbuf [ 32 ] = { 0 }; uint8_t recvbuf [ 48 ] = { 0 }; std :: memset ( & link , 0xA5 , sizeof ( link )); isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); EXPECT_EQ ( link . send_arbitration_id , 0x123u ); EXPECT_EQ ( link . send_buffer , sendbuf ); EXPECT_EQ ( link . send_buf_size , sizeof ( sendbuf )); EXPECT_EQ ( link . receive_buffer , recvbuf ); EXPECT_EQ ( link . receive_buf_size , sizeof ( recvbuf )); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_IDLE ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_IDLE ); EXPECT_EQ ( link . send_size , 0u ); EXPECT_EQ ( link . receive_size , 0u ); EXPECT_EQ ( link . send_offset , 0u ); EXPECT_EQ ( link . receive_offset , 0u ); }","title":"File gtest_isotp_init_link.cpp"},{"location":"docs/gtest__isotp__on__can__message_8cpp/","text":"File gtest_isotp_on_can_message.cpp \u00b6 FileList > tests > unit > gtest_isotp_on_can_message.cpp Go to the source code of this file Unit tests for isotp_on_can_message. More... #include <gtest/gtest.h> #include \"isotp_test_support.h\" Public Functions \u00b6 Type Name TEST (IsotpOnCanMessage, SingleFrameSetsReceiveBuffer) Single-frame payload fills the receive buffer. TEST (IsotpOnCanMessage, InvalidLengthIsIgnored) Invalid CAN DLC is ignored. TEST (IsotpOnCanMessage, SingleFrameInProgressLengthErrorSetsUnexpected) SF length error while in-progress yields unexpected PDU. TEST (IsotpOnCanMessage, FirstFrameOverflowSendsFlowControlOverflow) FF overflow triggers FC overflow response. TEST (IsotpOnCanMessage, FirstFrameOkStartsReceptionAndSendsFlowControl) FF starts reception and sends FC continue. TEST (IsotpOnCanMessage, ConsecutiveFrameUnexpectedWhenIdle) CF while idle is reported as unexpected PDU. TEST (IsotpOnCanMessage, ConsecutiveFrameWrongSnSetsError) Wrong SN in CF sets protocol error. TEST (IsotpOnCanMessage, ConsecutiveFrameCompletesReceive) Final CF completes the receive buffer. TEST (IsotpOnCanMessage, ConsecutiveFrameSendsFlowControlWhenBlockSizeExhausted) TEST (IsotpOnCanMessage, FlowControlIgnoredWhenSendIdle) TEST (IsotpOnCanMessage, FlowControlOverflowSetsSendError) TEST (IsotpOnCanMessage, FlowControlWaitExceedsSetsError) TEST (IsotpOnCanMessage, FlowControlContinueBsZeroSetsInvalidBsAndStmin) TEST (IsotpOnCanMessage, FlowControlContinueBsNonZeroSetsBs) TEST (IsotpOnCanMessage, UnknownTypeIgnored) Detailed Description \u00b6 Covers SF/FF/CF parsing and error handling paths. Public Functions Documentation \u00b6 function TEST \u00b6 Single-frame payload fills the receive buffer. TEST ( IsotpOnCanMessage , SingleFrameSetsReceiveBuffer ) function TEST \u00b6 Invalid CAN DLC is ignored. TEST ( IsotpOnCanMessage , InvalidLengthIsIgnored ) function TEST \u00b6 SF length error while in-progress yields unexpected PDU. TEST ( IsotpOnCanMessage , SingleFrameInProgressLengthErrorSetsUnexpected ) function TEST \u00b6 FF overflow triggers FC overflow response. TEST ( IsotpOnCanMessage , FirstFrameOverflowSendsFlowControlOverflow ) function TEST \u00b6 FF starts reception and sends FC continue. TEST ( IsotpOnCanMessage , FirstFrameOkStartsReceptionAndSendsFlowControl ) function TEST \u00b6 CF while idle is reported as unexpected PDU. TEST ( IsotpOnCanMessage , ConsecutiveFrameUnexpectedWhenIdle ) function TEST \u00b6 Wrong SN in CF sets protocol error. TEST ( IsotpOnCanMessage , ConsecutiveFrameWrongSnSetsError ) function TEST \u00b6 Final CF completes the receive buffer. TEST ( IsotpOnCanMessage , ConsecutiveFrameCompletesReceive ) function TEST \u00b6 TEST ( IsotpOnCanMessage , ConsecutiveFrameSendsFlowControlWhenBlockSizeExhausted ) function TEST \u00b6 TEST ( IsotpOnCanMessage , FlowControlIgnoredWhenSendIdle ) function TEST \u00b6 TEST ( IsotpOnCanMessage , FlowControlOverflowSetsSendError ) function TEST \u00b6 TEST ( IsotpOnCanMessage , FlowControlWaitExceedsSetsError ) function TEST \u00b6 TEST ( IsotpOnCanMessage , FlowControlContinueBsZeroSetsInvalidBsAndStmin ) function TEST \u00b6 TEST ( IsotpOnCanMessage , FlowControlContinueBsNonZeroSetsBs ) function TEST \u00b6 TEST ( IsotpOnCanMessage , UnknownTypeIgnored ) The documentation for this class was generated from the following file tests/unit/gtest_isotp_on_can_message.cpp","title":"File gtest_isotp_on_can_message.cpp"},{"location":"docs/gtest__isotp__on__can__message_8cpp/#file-gtest_isotp_on_can_messagecpp","text":"FileList > tests > unit > gtest_isotp_on_can_message.cpp Go to the source code of this file Unit tests for isotp_on_can_message. More... #include <gtest/gtest.h> #include \"isotp_test_support.h\"","title":"File gtest_isotp_on_can_message.cpp"},{"location":"docs/gtest__isotp__on__can__message_8cpp/#public-functions","text":"Type Name TEST (IsotpOnCanMessage, SingleFrameSetsReceiveBuffer) Single-frame payload fills the receive buffer. TEST (IsotpOnCanMessage, InvalidLengthIsIgnored) Invalid CAN DLC is ignored. TEST (IsotpOnCanMessage, SingleFrameInProgressLengthErrorSetsUnexpected) SF length error while in-progress yields unexpected PDU. TEST (IsotpOnCanMessage, FirstFrameOverflowSendsFlowControlOverflow) FF overflow triggers FC overflow response. TEST (IsotpOnCanMessage, FirstFrameOkStartsReceptionAndSendsFlowControl) FF starts reception and sends FC continue. TEST (IsotpOnCanMessage, ConsecutiveFrameUnexpectedWhenIdle) CF while idle is reported as unexpected PDU. TEST (IsotpOnCanMessage, ConsecutiveFrameWrongSnSetsError) Wrong SN in CF sets protocol error. TEST (IsotpOnCanMessage, ConsecutiveFrameCompletesReceive) Final CF completes the receive buffer. TEST (IsotpOnCanMessage, ConsecutiveFrameSendsFlowControlWhenBlockSizeExhausted) TEST (IsotpOnCanMessage, FlowControlIgnoredWhenSendIdle) TEST (IsotpOnCanMessage, FlowControlOverflowSetsSendError) TEST (IsotpOnCanMessage, FlowControlWaitExceedsSetsError) TEST (IsotpOnCanMessage, FlowControlContinueBsZeroSetsInvalidBsAndStmin) TEST (IsotpOnCanMessage, FlowControlContinueBsNonZeroSetsBs) TEST (IsotpOnCanMessage, UnknownTypeIgnored)","title":"Public Functions"},{"location":"docs/gtest__isotp__on__can__message_8cpp/#detailed-description","text":"Covers SF/FF/CF parsing and error handling paths.","title":"Detailed Description"},{"location":"docs/gtest__isotp__on__can__message_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/gtest__isotp__on__can__message_8cpp/#function-test","text":"Single-frame payload fills the receive buffer. TEST ( IsotpOnCanMessage , SingleFrameSetsReceiveBuffer )","title":"function TEST"},{"location":"docs/gtest__isotp__on__can__message_8cpp/#function-test_1","text":"Invalid CAN DLC is ignored. TEST ( IsotpOnCanMessage , InvalidLengthIsIgnored )","title":"function TEST"},{"location":"docs/gtest__isotp__on__can__message_8cpp/#function-test_2","text":"SF length error while in-progress yields unexpected PDU. TEST ( IsotpOnCanMessage , SingleFrameInProgressLengthErrorSetsUnexpected )","title":"function TEST"},{"location":"docs/gtest__isotp__on__can__message_8cpp/#function-test_3","text":"FF overflow triggers FC overflow response. TEST ( IsotpOnCanMessage , FirstFrameOverflowSendsFlowControlOverflow )","title":"function TEST"},{"location":"docs/gtest__isotp__on__can__message_8cpp/#function-test_4","text":"FF starts reception and sends FC continue. TEST ( IsotpOnCanMessage , FirstFrameOkStartsReceptionAndSendsFlowControl )","title":"function TEST"},{"location":"docs/gtest__isotp__on__can__message_8cpp/#function-test_5","text":"CF while idle is reported as unexpected PDU. TEST ( IsotpOnCanMessage , ConsecutiveFrameUnexpectedWhenIdle )","title":"function TEST"},{"location":"docs/gtest__isotp__on__can__message_8cpp/#function-test_6","text":"Wrong SN in CF sets protocol error. TEST ( IsotpOnCanMessage , ConsecutiveFrameWrongSnSetsError )","title":"function TEST"},{"location":"docs/gtest__isotp__on__can__message_8cpp/#function-test_7","text":"Final CF completes the receive buffer. TEST ( IsotpOnCanMessage , ConsecutiveFrameCompletesReceive )","title":"function TEST"},{"location":"docs/gtest__isotp__on__can__message_8cpp/#function-test_8","text":"TEST ( IsotpOnCanMessage , ConsecutiveFrameSendsFlowControlWhenBlockSizeExhausted )","title":"function TEST"},{"location":"docs/gtest__isotp__on__can__message_8cpp/#function-test_9","text":"TEST ( IsotpOnCanMessage , FlowControlIgnoredWhenSendIdle )","title":"function TEST"},{"location":"docs/gtest__isotp__on__can__message_8cpp/#function-test_10","text":"TEST ( IsotpOnCanMessage , FlowControlOverflowSetsSendError )","title":"function TEST"},{"location":"docs/gtest__isotp__on__can__message_8cpp/#function-test_11","text":"TEST ( IsotpOnCanMessage , FlowControlWaitExceedsSetsError )","title":"function TEST"},{"location":"docs/gtest__isotp__on__can__message_8cpp/#function-test_12","text":"TEST ( IsotpOnCanMessage , FlowControlContinueBsZeroSetsInvalidBsAndStmin )","title":"function TEST"},{"location":"docs/gtest__isotp__on__can__message_8cpp/#function-test_13","text":"TEST ( IsotpOnCanMessage , FlowControlContinueBsNonZeroSetsBs )","title":"function TEST"},{"location":"docs/gtest__isotp__on__can__message_8cpp/#function-test_14","text":"TEST ( IsotpOnCanMessage , UnknownTypeIgnored ) The documentation for this class was generated from the following file tests/unit/gtest_isotp_on_can_message.cpp","title":"function TEST"},{"location":"docs/gtest__isotp__on__can__message_8cpp_source/","text":"File gtest_isotp_on_can_message.cpp \u00b6 File List > tests > unit > gtest_isotp_on_can_message.cpp Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Unit tests for isotp_on_can_message. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <gtest/gtest.h> #include \"isotp_test_support.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Macros and constants for this test file */ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Local type definitions */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ /* static variables */ /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ /* static helpers */ /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* static helper implementations */ /* ============================================================================== * UNIT TEST IMPLEMENTATIONS * =============================================================================*/ TEST ( IsotpOnCanMessage , SingleFrameSetsReceiveBuffer ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . single_frame . type = ISOTP_PCI_TYPE_SINGLE ; message . as . single_frame . SF_DL = 2 ; message . as . single_frame . data [ 0 ] = 0x11 ; message . as . single_frame . data [ 1 ] = 0x22 ; isotp_on_can_message ( & link , message . as . data_array . ptr , 3 ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_FULL ); EXPECT_EQ ( link . receive_size , 2u ); EXPECT_EQ ( link . receive_buffer [ 0 ], 0x11 ); EXPECT_EQ ( link . receive_buffer [ 1 ], 0x22 ); } TEST ( IsotpOnCanMessage , InvalidLengthIsIgnored ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . receive_status = ISOTP_RECEIVE_STATUS_INPROGRESS ; link . receive_protocol_result = ISOTP_PROTOCOL_RESULT_OK ; uint8_t short_data [ 1 ] = { 0 }; uint8_t long_data [ 9 ] = { 0 }; isotp_on_can_message ( & link , short_data , 1 ); isotp_on_can_message ( & link , long_data , 9 ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_INPROGRESS ); EXPECT_EQ ( link . receive_protocol_result , ISOTP_PROTOCOL_RESULT_OK ); EXPECT_EQ ( g_can_state . call_count , 0 ); } TEST ( IsotpOnCanMessage , SingleFrameInProgressLengthErrorSetsUnexpected ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . receive_status = ISOTP_RECEIVE_STATUS_INPROGRESS ; IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . single_frame . type = ISOTP_PCI_TYPE_SINGLE ; message . as . single_frame . SF_DL = 0 ; isotp_on_can_message ( & link , message . as . data_array . ptr , 2 ); EXPECT_EQ ( link . receive_protocol_result , ISOTP_PROTOCOL_RESULT_UNEXP_PDU ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_INPROGRESS ); } TEST ( IsotpOnCanMessage , FirstFrameOverflowSendsFlowControlOverflow ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 4 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . first_frame_short . type = ISOTP_PCI_TYPE_FIRST_FRAME ; message . as . first_frame_short . FF_DL_high = 0 ; message . as . first_frame_short . FF_DL_low = 10 ; isotp_on_can_message ( & link , message . as . data_array . ptr , 8 ); EXPECT_EQ ( link . receive_protocol_result , ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_IDLE ); EXPECT_EQ ( g_can_state . call_count , 1 ); IsoTpCanMessage expected ; std :: memset ( & expected , 0 , sizeof ( expected )); expected . as . flow_control . type = ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME ; expected . as . flow_control . FS = PCI_FLOW_STATUS_OVERFLOW ; expected . as . flow_control . BS = 0 ; expected . as . flow_control . STmin = 0 ; EXPECT_EQ ( g_can_state . last_size , 3u ); EXPECT_EQ ( std :: memcmp ( g_can_state . last_data , expected . as . data_array . ptr , 3 ), 0 ); } TEST ( IsotpOnCanMessage , FirstFrameOkStartsReceptionAndSendsFlowControl ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 32 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); g_now_us = 100 ; IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . first_frame_short . type = ISOTP_PCI_TYPE_FIRST_FRAME ; message . as . first_frame_short . FF_DL_high = 0 ; message . as . first_frame_short . FF_DL_low = 10 ; message . as . first_frame_short . data [ 0 ] = 0xA1 ; message . as . first_frame_short . data [ 1 ] = 0xB2 ; isotp_on_can_message ( & link , message . as . data_array . ptr , 8 ); EXPECT_EQ ( link . receive_protocol_result , ISOTP_PROTOCOL_RESULT_OK ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_INPROGRESS ); EXPECT_EQ ( link . receive_size , 10u ); EXPECT_EQ ( link . receive_offset , 6u ); EXPECT_EQ ( link . receive_sn , 1u ); EXPECT_EQ ( link . receive_buffer [ 0 ], 0xA1 ); EXPECT_EQ ( link . receive_buffer [ 1 ], 0xB2 ); EXPECT_EQ ( link . receive_timer_cr , g_now_us + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ); EXPECT_EQ ( g_can_state . call_count , 1 ); IsoTpCanMessage expected ; std :: memset ( & expected , 0 , sizeof ( expected )); expected . as . flow_control . type = ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME ; expected . as . flow_control . FS = PCI_FLOW_STATUS_CONTINUE ; expected . as . flow_control . BS = ISO_TP_DEFAULT_BLOCK_SIZE ; expected . as . flow_control . STmin = 0 ; EXPECT_EQ ( g_can_state . last_size , 3u ); EXPECT_EQ ( std :: memcmp ( g_can_state . last_data , expected . as . data_array . ptr , 3 ), 0 ); } TEST ( IsotpOnCanMessage , ConsecutiveFrameUnexpectedWhenIdle ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . consecutive_frame . type = ISOTP_PCI_TYPE_CONSECUTIVE_FRAME ; message . as . consecutive_frame . SN = 1 ; message . as . consecutive_frame . data [ 0 ] = 0x5A ; isotp_on_can_message ( & link , message . as . data_array . ptr , 2 ); EXPECT_EQ ( link . receive_protocol_result , ISOTP_PROTOCOL_RESULT_UNEXP_PDU ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_IDLE ); } TEST ( IsotpOnCanMessage , ConsecutiveFrameWrongSnSetsError ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . receive_status = ISOTP_RECEIVE_STATUS_INPROGRESS ; link . receive_sn = 2 ; IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . consecutive_frame . type = ISOTP_PCI_TYPE_CONSECUTIVE_FRAME ; message . as . consecutive_frame . SN = 1 ; message . as . consecutive_frame . data [ 0 ] = 0x6B ; isotp_on_can_message ( & link , message . as . data_array . ptr , 2 ); EXPECT_EQ ( link . receive_protocol_result , ISOTP_PROTOCOL_RESULT_WRONG_SN ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_IDLE ); } TEST ( IsotpOnCanMessage , ConsecutiveFrameCompletesReceive ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . receive_status = ISOTP_RECEIVE_STATUS_INPROGRESS ; link . receive_size = 8 ; link . receive_offset = 7 ; link . receive_sn = 1 ; link . receive_buffer [ 7 ] = 0 ; IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . consecutive_frame . type = ISOTP_PCI_TYPE_CONSECUTIVE_FRAME ; message . as . consecutive_frame . SN = 1 ; message . as . consecutive_frame . data [ 0 ] = 0xAB ; isotp_on_can_message ( & link , message . as . data_array . ptr , 2 ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_FULL ); EXPECT_EQ ( link . receive_offset , 8u ); EXPECT_EQ ( link . receive_buffer [ 7 ], 0xAB ); } TEST ( IsotpOnCanMessage , ConsecutiveFrameSendsFlowControlWhenBlockSizeExhausted ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 32 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); g_now_us = 50 ; link . receive_status = ISOTP_RECEIVE_STATUS_INPROGRESS ; link . receive_size = 20 ; link . receive_offset = 0 ; link . receive_sn = 1 ; link . receive_bs_count = 1 ; IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . consecutive_frame . type = ISOTP_PCI_TYPE_CONSECUTIVE_FRAME ; message . as . consecutive_frame . SN = 1 ; message . as . consecutive_frame . data [ 0 ] = 0x10 ; isotp_on_can_message ( & link , message . as . data_array . ptr , 8 ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_INPROGRESS ); EXPECT_EQ ( link . receive_offset , 7u ); EXPECT_EQ ( link . receive_bs_count , ISO_TP_DEFAULT_BLOCK_SIZE ); EXPECT_EQ ( link . receive_timer_cr , g_now_us + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ); EXPECT_EQ ( g_can_state . call_count , 1 ); IsoTpCanMessage expected ; std :: memset ( & expected , 0 , sizeof ( expected )); expected . as . flow_control . type = ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME ; expected . as . flow_control . FS = PCI_FLOW_STATUS_CONTINUE ; expected . as . flow_control . BS = ISO_TP_DEFAULT_BLOCK_SIZE ; expected . as . flow_control . STmin = 0 ; EXPECT_EQ ( g_can_state . last_size , 3u ); EXPECT_EQ ( std :: memcmp ( g_can_state . last_data , expected . as . data_array . ptr , 3 ), 0 ); } TEST ( IsotpOnCanMessage , FlowControlIgnoredWhenSendIdle ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . flow_control . type = ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME ; message . as . flow_control . FS = PCI_FLOW_STATUS_CONTINUE ; isotp_on_can_message ( & link , message . as . data_array . ptr , 3 ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_IDLE ); EXPECT_EQ ( g_can_state . call_count , 0 ); } TEST ( IsotpOnCanMessage , FlowControlOverflowSetsSendError ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); g_now_us = 200 ; link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; link . send_protocol_result = ISOTP_PROTOCOL_RESULT_OK ; IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . flow_control . type = ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME ; message . as . flow_control . FS = PCI_FLOW_STATUS_OVERFLOW ; isotp_on_can_message ( & link , message . as . data_array . ptr , 3 ); EXPECT_EQ ( link . send_protocol_result , ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_ERROR ); EXPECT_EQ ( link . send_timer_bs , g_now_us + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ); } TEST ( IsotpOnCanMessage , FlowControlWaitExceedsSetsError ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); g_now_us = 300 ; link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; link . send_wtf_count = ISO_TP_MAX_WFT_NUMBER ; link . send_protocol_result = ISOTP_PROTOCOL_RESULT_OK ; IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . flow_control . type = ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME ; message . as . flow_control . FS = PCI_FLOW_STATUS_WAIT ; isotp_on_can_message ( & link , message . as . data_array . ptr , 3 ); EXPECT_EQ ( link . send_protocol_result , ISOTP_PROTOCOL_RESULT_WFT_OVRN ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_ERROR ); EXPECT_EQ ( link . send_timer_bs , g_now_us + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ); } TEST ( IsotpOnCanMessage , FlowControlContinueBsZeroSetsInvalidBsAndStmin ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); g_now_us = 400 ; link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; link . send_wtf_count = 2 ; IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . flow_control . type = ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME ; message . as . flow_control . FS = PCI_FLOW_STATUS_CONTINUE ; message . as . flow_control . BS = 0 ; message . as . flow_control . STmin = 5 ; isotp_on_can_message ( & link , message . as . data_array . ptr , 3 ); EXPECT_EQ ( link . send_bs_remain , ISOTP_INVALID_BS ); EXPECT_EQ ( link . send_st_min_us , 5000u ); EXPECT_EQ ( link . send_wtf_count , 0 ); EXPECT_EQ ( link . send_timer_bs , g_now_us + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ); } TEST ( IsotpOnCanMessage , FlowControlContinueBsNonZeroSetsBs ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); g_now_us = 450 ; link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; link . send_bs_remain = 0 ; IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . flow_control . type = ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME ; message . as . flow_control . FS = PCI_FLOW_STATUS_CONTINUE ; message . as . flow_control . BS = 4 ; message . as . flow_control . STmin = 0 ; isotp_on_can_message ( & link , message . as . data_array . ptr , 3 ); EXPECT_EQ ( link . send_bs_remain , 4u ); EXPECT_EQ ( link . send_st_min_us , 0u ); EXPECT_EQ ( link . send_timer_bs , g_now_us + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ); } TEST ( IsotpOnCanMessage , UnknownTypeIgnored ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . common . type = 0xF ; isotp_on_can_message ( & link , message . as . data_array . ptr , 2 ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_IDLE ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_IDLE ); }","title":"File gtest_isotp_on_can_message.cpp"},{"location":"docs/gtest__isotp__on__can__message_8cpp_source/#file-gtest_isotp_on_can_messagecpp","text":"File List > tests > unit > gtest_isotp_on_can_message.cpp Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Unit tests for isotp_on_can_message. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <gtest/gtest.h> #include \"isotp_test_support.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Macros and constants for this test file */ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Local type definitions */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ /* static variables */ /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ /* static helpers */ /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* static helper implementations */ /* ============================================================================== * UNIT TEST IMPLEMENTATIONS * =============================================================================*/ TEST ( IsotpOnCanMessage , SingleFrameSetsReceiveBuffer ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . single_frame . type = ISOTP_PCI_TYPE_SINGLE ; message . as . single_frame . SF_DL = 2 ; message . as . single_frame . data [ 0 ] = 0x11 ; message . as . single_frame . data [ 1 ] = 0x22 ; isotp_on_can_message ( & link , message . as . data_array . ptr , 3 ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_FULL ); EXPECT_EQ ( link . receive_size , 2u ); EXPECT_EQ ( link . receive_buffer [ 0 ], 0x11 ); EXPECT_EQ ( link . receive_buffer [ 1 ], 0x22 ); } TEST ( IsotpOnCanMessage , InvalidLengthIsIgnored ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . receive_status = ISOTP_RECEIVE_STATUS_INPROGRESS ; link . receive_protocol_result = ISOTP_PROTOCOL_RESULT_OK ; uint8_t short_data [ 1 ] = { 0 }; uint8_t long_data [ 9 ] = { 0 }; isotp_on_can_message ( & link , short_data , 1 ); isotp_on_can_message ( & link , long_data , 9 ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_INPROGRESS ); EXPECT_EQ ( link . receive_protocol_result , ISOTP_PROTOCOL_RESULT_OK ); EXPECT_EQ ( g_can_state . call_count , 0 ); } TEST ( IsotpOnCanMessage , SingleFrameInProgressLengthErrorSetsUnexpected ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . receive_status = ISOTP_RECEIVE_STATUS_INPROGRESS ; IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . single_frame . type = ISOTP_PCI_TYPE_SINGLE ; message . as . single_frame . SF_DL = 0 ; isotp_on_can_message ( & link , message . as . data_array . ptr , 2 ); EXPECT_EQ ( link . receive_protocol_result , ISOTP_PROTOCOL_RESULT_UNEXP_PDU ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_INPROGRESS ); } TEST ( IsotpOnCanMessage , FirstFrameOverflowSendsFlowControlOverflow ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 4 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . first_frame_short . type = ISOTP_PCI_TYPE_FIRST_FRAME ; message . as . first_frame_short . FF_DL_high = 0 ; message . as . first_frame_short . FF_DL_low = 10 ; isotp_on_can_message ( & link , message . as . data_array . ptr , 8 ); EXPECT_EQ ( link . receive_protocol_result , ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_IDLE ); EXPECT_EQ ( g_can_state . call_count , 1 ); IsoTpCanMessage expected ; std :: memset ( & expected , 0 , sizeof ( expected )); expected . as . flow_control . type = ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME ; expected . as . flow_control . FS = PCI_FLOW_STATUS_OVERFLOW ; expected . as . flow_control . BS = 0 ; expected . as . flow_control . STmin = 0 ; EXPECT_EQ ( g_can_state . last_size , 3u ); EXPECT_EQ ( std :: memcmp ( g_can_state . last_data , expected . as . data_array . ptr , 3 ), 0 ); } TEST ( IsotpOnCanMessage , FirstFrameOkStartsReceptionAndSendsFlowControl ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 32 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); g_now_us = 100 ; IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . first_frame_short . type = ISOTP_PCI_TYPE_FIRST_FRAME ; message . as . first_frame_short . FF_DL_high = 0 ; message . as . first_frame_short . FF_DL_low = 10 ; message . as . first_frame_short . data [ 0 ] = 0xA1 ; message . as . first_frame_short . data [ 1 ] = 0xB2 ; isotp_on_can_message ( & link , message . as . data_array . ptr , 8 ); EXPECT_EQ ( link . receive_protocol_result , ISOTP_PROTOCOL_RESULT_OK ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_INPROGRESS ); EXPECT_EQ ( link . receive_size , 10u ); EXPECT_EQ ( link . receive_offset , 6u ); EXPECT_EQ ( link . receive_sn , 1u ); EXPECT_EQ ( link . receive_buffer [ 0 ], 0xA1 ); EXPECT_EQ ( link . receive_buffer [ 1 ], 0xB2 ); EXPECT_EQ ( link . receive_timer_cr , g_now_us + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ); EXPECT_EQ ( g_can_state . call_count , 1 ); IsoTpCanMessage expected ; std :: memset ( & expected , 0 , sizeof ( expected )); expected . as . flow_control . type = ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME ; expected . as . flow_control . FS = PCI_FLOW_STATUS_CONTINUE ; expected . as . flow_control . BS = ISO_TP_DEFAULT_BLOCK_SIZE ; expected . as . flow_control . STmin = 0 ; EXPECT_EQ ( g_can_state . last_size , 3u ); EXPECT_EQ ( std :: memcmp ( g_can_state . last_data , expected . as . data_array . ptr , 3 ), 0 ); } TEST ( IsotpOnCanMessage , ConsecutiveFrameUnexpectedWhenIdle ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . consecutive_frame . type = ISOTP_PCI_TYPE_CONSECUTIVE_FRAME ; message . as . consecutive_frame . SN = 1 ; message . as . consecutive_frame . data [ 0 ] = 0x5A ; isotp_on_can_message ( & link , message . as . data_array . ptr , 2 ); EXPECT_EQ ( link . receive_protocol_result , ISOTP_PROTOCOL_RESULT_UNEXP_PDU ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_IDLE ); } TEST ( IsotpOnCanMessage , ConsecutiveFrameWrongSnSetsError ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . receive_status = ISOTP_RECEIVE_STATUS_INPROGRESS ; link . receive_sn = 2 ; IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . consecutive_frame . type = ISOTP_PCI_TYPE_CONSECUTIVE_FRAME ; message . as . consecutive_frame . SN = 1 ; message . as . consecutive_frame . data [ 0 ] = 0x6B ; isotp_on_can_message ( & link , message . as . data_array . ptr , 2 ); EXPECT_EQ ( link . receive_protocol_result , ISOTP_PROTOCOL_RESULT_WRONG_SN ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_IDLE ); } TEST ( IsotpOnCanMessage , ConsecutiveFrameCompletesReceive ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . receive_status = ISOTP_RECEIVE_STATUS_INPROGRESS ; link . receive_size = 8 ; link . receive_offset = 7 ; link . receive_sn = 1 ; link . receive_buffer [ 7 ] = 0 ; IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . consecutive_frame . type = ISOTP_PCI_TYPE_CONSECUTIVE_FRAME ; message . as . consecutive_frame . SN = 1 ; message . as . consecutive_frame . data [ 0 ] = 0xAB ; isotp_on_can_message ( & link , message . as . data_array . ptr , 2 ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_FULL ); EXPECT_EQ ( link . receive_offset , 8u ); EXPECT_EQ ( link . receive_buffer [ 7 ], 0xAB ); } TEST ( IsotpOnCanMessage , ConsecutiveFrameSendsFlowControlWhenBlockSizeExhausted ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 32 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); g_now_us = 50 ; link . receive_status = ISOTP_RECEIVE_STATUS_INPROGRESS ; link . receive_size = 20 ; link . receive_offset = 0 ; link . receive_sn = 1 ; link . receive_bs_count = 1 ; IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . consecutive_frame . type = ISOTP_PCI_TYPE_CONSECUTIVE_FRAME ; message . as . consecutive_frame . SN = 1 ; message . as . consecutive_frame . data [ 0 ] = 0x10 ; isotp_on_can_message ( & link , message . as . data_array . ptr , 8 ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_INPROGRESS ); EXPECT_EQ ( link . receive_offset , 7u ); EXPECT_EQ ( link . receive_bs_count , ISO_TP_DEFAULT_BLOCK_SIZE ); EXPECT_EQ ( link . receive_timer_cr , g_now_us + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ); EXPECT_EQ ( g_can_state . call_count , 1 ); IsoTpCanMessage expected ; std :: memset ( & expected , 0 , sizeof ( expected )); expected . as . flow_control . type = ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME ; expected . as . flow_control . FS = PCI_FLOW_STATUS_CONTINUE ; expected . as . flow_control . BS = ISO_TP_DEFAULT_BLOCK_SIZE ; expected . as . flow_control . STmin = 0 ; EXPECT_EQ ( g_can_state . last_size , 3u ); EXPECT_EQ ( std :: memcmp ( g_can_state . last_data , expected . as . data_array . ptr , 3 ), 0 ); } TEST ( IsotpOnCanMessage , FlowControlIgnoredWhenSendIdle ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . flow_control . type = ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME ; message . as . flow_control . FS = PCI_FLOW_STATUS_CONTINUE ; isotp_on_can_message ( & link , message . as . data_array . ptr , 3 ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_IDLE ); EXPECT_EQ ( g_can_state . call_count , 0 ); } TEST ( IsotpOnCanMessage , FlowControlOverflowSetsSendError ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); g_now_us = 200 ; link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; link . send_protocol_result = ISOTP_PROTOCOL_RESULT_OK ; IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . flow_control . type = ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME ; message . as . flow_control . FS = PCI_FLOW_STATUS_OVERFLOW ; isotp_on_can_message ( & link , message . as . data_array . ptr , 3 ); EXPECT_EQ ( link . send_protocol_result , ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_ERROR ); EXPECT_EQ ( link . send_timer_bs , g_now_us + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ); } TEST ( IsotpOnCanMessage , FlowControlWaitExceedsSetsError ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); g_now_us = 300 ; link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; link . send_wtf_count = ISO_TP_MAX_WFT_NUMBER ; link . send_protocol_result = ISOTP_PROTOCOL_RESULT_OK ; IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . flow_control . type = ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME ; message . as . flow_control . FS = PCI_FLOW_STATUS_WAIT ; isotp_on_can_message ( & link , message . as . data_array . ptr , 3 ); EXPECT_EQ ( link . send_protocol_result , ISOTP_PROTOCOL_RESULT_WFT_OVRN ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_ERROR ); EXPECT_EQ ( link . send_timer_bs , g_now_us + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ); } TEST ( IsotpOnCanMessage , FlowControlContinueBsZeroSetsInvalidBsAndStmin ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); g_now_us = 400 ; link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; link . send_wtf_count = 2 ; IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . flow_control . type = ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME ; message . as . flow_control . FS = PCI_FLOW_STATUS_CONTINUE ; message . as . flow_control . BS = 0 ; message . as . flow_control . STmin = 5 ; isotp_on_can_message ( & link , message . as . data_array . ptr , 3 ); EXPECT_EQ ( link . send_bs_remain , ISOTP_INVALID_BS ); EXPECT_EQ ( link . send_st_min_us , 5000u ); EXPECT_EQ ( link . send_wtf_count , 0 ); EXPECT_EQ ( link . send_timer_bs , g_now_us + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ); } TEST ( IsotpOnCanMessage , FlowControlContinueBsNonZeroSetsBs ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); g_now_us = 450 ; link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; link . send_bs_remain = 0 ; IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . flow_control . type = ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME ; message . as . flow_control . FS = PCI_FLOW_STATUS_CONTINUE ; message . as . flow_control . BS = 4 ; message . as . flow_control . STmin = 0 ; isotp_on_can_message ( & link , message . as . data_array . ptr , 3 ); EXPECT_EQ ( link . send_bs_remain , 4u ); EXPECT_EQ ( link . send_st_min_us , 0u ); EXPECT_EQ ( link . send_timer_bs , g_now_us + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ); } TEST ( IsotpOnCanMessage , UnknownTypeIgnored ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); IsoTpCanMessage message ; std :: memset ( & message , 0 , sizeof ( message )); message . as . common . type = 0xF ; isotp_on_can_message ( & link , message . as . data_array . ptr , 2 ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_IDLE ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_IDLE ); }","title":"File gtest_isotp_on_can_message.cpp"},{"location":"docs/gtest__isotp__poll_8cpp/","text":"File gtest_isotp_poll.cpp \u00b6 FileList > tests > unit > gtest_isotp_poll.cpp Go to the source code of this file Unit tests for isotp_poll. More... #include <gtest/gtest.h> #include \"isotp_test_support.h\" Public Functions \u00b6 Type Name TEST (IsotpPoll, SendsConsecutiveFrameAndCompletes) Sends the final CF and completes the send. TEST (IsotpPoll, ReceiveTimeoutSetsIdle) Receive timeout sets idle and timeout result. TEST (IsotpPoll, SendDoesNotStartWhenStMinNotElapsed) STmin delay prevents sending early. TEST (IsotpPoll, SendNoSpaceDoesNotChangeState) NOSPACE keeps send state unchanged. TEST (IsotpPoll, SendErrorSetsSendStatusError) Send error sets send status to error. TEST (IsotpPoll, SendDecrementsBlockSizeRemain) Send decrements block size and advances timers. TEST (IsotpPoll, SendTimeoutSetsError) Send timeout sets protocol error. TEST (IsotpPoll, ReceiveDoesNotTimeoutWhenTimerZero) Zero receive timer does not trigger timeout. Detailed Description \u00b6 Validates send/receive state updates and timeout handling. Public Functions Documentation \u00b6 function TEST \u00b6 Sends the final CF and completes the send. TEST ( IsotpPoll , SendsConsecutiveFrameAndCompletes ) function TEST \u00b6 Receive timeout sets idle and timeout result. TEST ( IsotpPoll , ReceiveTimeoutSetsIdle ) function TEST \u00b6 STmin delay prevents sending early. TEST ( IsotpPoll , SendDoesNotStartWhenStMinNotElapsed ) function TEST \u00b6 NOSPACE keeps send state unchanged. TEST ( IsotpPoll , SendNoSpaceDoesNotChangeState ) function TEST \u00b6 Send error sets send status to error. TEST ( IsotpPoll , SendErrorSetsSendStatusError ) function TEST \u00b6 Send decrements block size and advances timers. TEST ( IsotpPoll , SendDecrementsBlockSizeRemain ) function TEST \u00b6 Send timeout sets protocol error. TEST ( IsotpPoll , SendTimeoutSetsError ) function TEST \u00b6 Zero receive timer does not trigger timeout. TEST ( IsotpPoll , ReceiveDoesNotTimeoutWhenTimerZero ) The documentation for this class was generated from the following file tests/unit/gtest_isotp_poll.cpp","title":"File gtest_isotp_poll.cpp"},{"location":"docs/gtest__isotp__poll_8cpp/#file-gtest_isotp_pollcpp","text":"FileList > tests > unit > gtest_isotp_poll.cpp Go to the source code of this file Unit tests for isotp_poll. More... #include <gtest/gtest.h> #include \"isotp_test_support.h\"","title":"File gtest_isotp_poll.cpp"},{"location":"docs/gtest__isotp__poll_8cpp/#public-functions","text":"Type Name TEST (IsotpPoll, SendsConsecutiveFrameAndCompletes) Sends the final CF and completes the send. TEST (IsotpPoll, ReceiveTimeoutSetsIdle) Receive timeout sets idle and timeout result. TEST (IsotpPoll, SendDoesNotStartWhenStMinNotElapsed) STmin delay prevents sending early. TEST (IsotpPoll, SendNoSpaceDoesNotChangeState) NOSPACE keeps send state unchanged. TEST (IsotpPoll, SendErrorSetsSendStatusError) Send error sets send status to error. TEST (IsotpPoll, SendDecrementsBlockSizeRemain) Send decrements block size and advances timers. TEST (IsotpPoll, SendTimeoutSetsError) Send timeout sets protocol error. TEST (IsotpPoll, ReceiveDoesNotTimeoutWhenTimerZero) Zero receive timer does not trigger timeout.","title":"Public Functions"},{"location":"docs/gtest__isotp__poll_8cpp/#detailed-description","text":"Validates send/receive state updates and timeout handling.","title":"Detailed Description"},{"location":"docs/gtest__isotp__poll_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/gtest__isotp__poll_8cpp/#function-test","text":"Sends the final CF and completes the send. TEST ( IsotpPoll , SendsConsecutiveFrameAndCompletes )","title":"function TEST"},{"location":"docs/gtest__isotp__poll_8cpp/#function-test_1","text":"Receive timeout sets idle and timeout result. TEST ( IsotpPoll , ReceiveTimeoutSetsIdle )","title":"function TEST"},{"location":"docs/gtest__isotp__poll_8cpp/#function-test_2","text":"STmin delay prevents sending early. TEST ( IsotpPoll , SendDoesNotStartWhenStMinNotElapsed )","title":"function TEST"},{"location":"docs/gtest__isotp__poll_8cpp/#function-test_3","text":"NOSPACE keeps send state unchanged. TEST ( IsotpPoll , SendNoSpaceDoesNotChangeState )","title":"function TEST"},{"location":"docs/gtest__isotp__poll_8cpp/#function-test_4","text":"Send error sets send status to error. TEST ( IsotpPoll , SendErrorSetsSendStatusError )","title":"function TEST"},{"location":"docs/gtest__isotp__poll_8cpp/#function-test_5","text":"Send decrements block size and advances timers. TEST ( IsotpPoll , SendDecrementsBlockSizeRemain )","title":"function TEST"},{"location":"docs/gtest__isotp__poll_8cpp/#function-test_6","text":"Send timeout sets protocol error. TEST ( IsotpPoll , SendTimeoutSetsError )","title":"function TEST"},{"location":"docs/gtest__isotp__poll_8cpp/#function-test_7","text":"Zero receive timer does not trigger timeout. TEST ( IsotpPoll , ReceiveDoesNotTimeoutWhenTimerZero ) The documentation for this class was generated from the following file tests/unit/gtest_isotp_poll.cpp","title":"function TEST"},{"location":"docs/gtest__isotp__poll_8cpp_source/","text":"File gtest_isotp_poll.cpp \u00b6 File List > tests > unit > gtest_isotp_poll.cpp Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Unit tests for isotp_poll. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <gtest/gtest.h> #include \"isotp_test_support.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Macros and constants for this test file */ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Local type definitions */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ /* static variables */ /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ /* static helpers */ /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* static helper implementations */ /* ============================================================================== * UNIT TEST IMPLEMENTATIONS * =============================================================================*/ TEST ( IsotpPoll , SendsConsecutiveFrameAndCompletes ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; link . send_size = 8 ; link . send_offset = 7 ; link . send_sn = 1 ; link . send_bs_remain = ISOTP_INVALID_BS ; link . send_st_min_us = 0 ; link . send_timer_st = 0 ; link . send_timer_bs = 1000 ; g_now_us = 1 ; link . send_buffer [ 7 ] = 0x5A ; int ret_before = g_can_state . call_count ; isotp_poll ( & link ); EXPECT_EQ ( g_can_state . call_count , ret_before + 1 ); EXPECT_EQ ( link . send_offset , 8u ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_IDLE ); EXPECT_EQ ( g_can_state . last_size , 2u ); } TEST ( IsotpPoll , ReceiveTimeoutSetsIdle ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 8 ] = { 0 }; uint8_t recvbuf [ 8 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . receive_status = ISOTP_RECEIVE_STATUS_INPROGRESS ; link . receive_timer_cr = 10 ; g_now_us = 11 ; isotp_poll ( & link ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_IDLE ); EXPECT_EQ ( link . receive_protocol_result , ISOTP_PROTOCOL_RESULT_TIMEOUT_CR ); } TEST ( IsotpPoll , SendDoesNotStartWhenStMinNotElapsed ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; link . send_size = 8 ; link . send_offset = 0 ; link . send_sn = 1 ; link . send_bs_remain = 1 ; link . send_st_min_us = 50 ; link . send_timer_st = 100 ; link . send_timer_bs = 1000 ; g_now_us = 90 ; isotp_poll ( & link ); EXPECT_EQ ( g_can_state . call_count , 0 ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_INPROGRESS ); EXPECT_EQ ( link . send_offset , 0u ); } TEST ( IsotpPoll , SendNoSpaceDoesNotChangeState ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; link . send_size = 9 ; link . send_offset = 0 ; link . send_sn = 1 ; link . send_bs_remain = ISOTP_INVALID_BS ; link . send_st_min_us = 0 ; link . send_timer_st = 0 ; link . send_timer_bs = 500 ; g_now_us = 1 ; g_can_state . return_value = ISOTP_RET_NOSPACE ; isotp_poll ( & link ); EXPECT_EQ ( g_can_state . call_count , 1 ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_INPROGRESS ); EXPECT_EQ ( link . send_offset , 0u ); EXPECT_EQ ( link . send_timer_bs , 500u ); } TEST ( IsotpPoll , SendErrorSetsSendStatusError ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; link . send_size = 9 ; link . send_offset = 0 ; link . send_sn = 1 ; link . send_bs_remain = ISOTP_INVALID_BS ; link . send_st_min_us = 0 ; link . send_timer_st = 0 ; link . send_timer_bs = 500 ; g_now_us = 1 ; g_can_state . return_value = ISOTP_RET_ERROR ; isotp_poll ( & link ); EXPECT_EQ ( g_can_state . call_count , 1 ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_ERROR ); } TEST ( IsotpPoll , SendDecrementsBlockSizeRemain ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; link . send_size = 9 ; link . send_offset = 0 ; link . send_sn = 1 ; link . send_bs_remain = 2 ; link . send_st_min_us = 0 ; link . send_timer_st = 0 ; link . send_timer_bs = 1000 ; g_now_us = 10 ; isotp_poll ( & link ); EXPECT_EQ ( g_can_state . call_count , 1 ); EXPECT_EQ ( link . send_offset , 7u ); EXPECT_EQ ( link . send_bs_remain , 1u ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_INPROGRESS ); EXPECT_EQ ( link . send_timer_bs , g_now_us + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ); } TEST ( IsotpPoll , SendTimeoutSetsError ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; link . send_bs_remain = 0 ; link . send_timer_bs = 10 ; g_now_us = 11 ; isotp_poll ( & link ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_ERROR ); EXPECT_EQ ( link . send_protocol_result , ISOTP_PROTOCOL_RESULT_TIMEOUT_BS ); } TEST ( IsotpPoll , ReceiveDoesNotTimeoutWhenTimerZero ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 8 ] = { 0 }; uint8_t recvbuf [ 8 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . receive_status = ISOTP_RECEIVE_STATUS_INPROGRESS ; link . receive_timer_cr = 0 ; link . receive_protocol_result = ISOTP_PROTOCOL_RESULT_OK ; g_now_us = 100 ; isotp_poll ( & link ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_INPROGRESS ); EXPECT_EQ ( link . receive_protocol_result , ISOTP_PROTOCOL_RESULT_OK ); }","title":"File gtest_isotp_poll.cpp"},{"location":"docs/gtest__isotp__poll_8cpp_source/#file-gtest_isotp_pollcpp","text":"File List > tests > unit > gtest_isotp_poll.cpp Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Unit tests for isotp_poll. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <gtest/gtest.h> #include \"isotp_test_support.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Macros and constants for this test file */ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Local type definitions */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ /* static variables */ /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ /* static helpers */ /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* static helper implementations */ /* ============================================================================== * UNIT TEST IMPLEMENTATIONS * =============================================================================*/ TEST ( IsotpPoll , SendsConsecutiveFrameAndCompletes ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; link . send_size = 8 ; link . send_offset = 7 ; link . send_sn = 1 ; link . send_bs_remain = ISOTP_INVALID_BS ; link . send_st_min_us = 0 ; link . send_timer_st = 0 ; link . send_timer_bs = 1000 ; g_now_us = 1 ; link . send_buffer [ 7 ] = 0x5A ; int ret_before = g_can_state . call_count ; isotp_poll ( & link ); EXPECT_EQ ( g_can_state . call_count , ret_before + 1 ); EXPECT_EQ ( link . send_offset , 8u ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_IDLE ); EXPECT_EQ ( g_can_state . last_size , 2u ); } TEST ( IsotpPoll , ReceiveTimeoutSetsIdle ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 8 ] = { 0 }; uint8_t recvbuf [ 8 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . receive_status = ISOTP_RECEIVE_STATUS_INPROGRESS ; link . receive_timer_cr = 10 ; g_now_us = 11 ; isotp_poll ( & link ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_IDLE ); EXPECT_EQ ( link . receive_protocol_result , ISOTP_PROTOCOL_RESULT_TIMEOUT_CR ); } TEST ( IsotpPoll , SendDoesNotStartWhenStMinNotElapsed ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; link . send_size = 8 ; link . send_offset = 0 ; link . send_sn = 1 ; link . send_bs_remain = 1 ; link . send_st_min_us = 50 ; link . send_timer_st = 100 ; link . send_timer_bs = 1000 ; g_now_us = 90 ; isotp_poll ( & link ); EXPECT_EQ ( g_can_state . call_count , 0 ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_INPROGRESS ); EXPECT_EQ ( link . send_offset , 0u ); } TEST ( IsotpPoll , SendNoSpaceDoesNotChangeState ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; link . send_size = 9 ; link . send_offset = 0 ; link . send_sn = 1 ; link . send_bs_remain = ISOTP_INVALID_BS ; link . send_st_min_us = 0 ; link . send_timer_st = 0 ; link . send_timer_bs = 500 ; g_now_us = 1 ; g_can_state . return_value = ISOTP_RET_NOSPACE ; isotp_poll ( & link ); EXPECT_EQ ( g_can_state . call_count , 1 ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_INPROGRESS ); EXPECT_EQ ( link . send_offset , 0u ); EXPECT_EQ ( link . send_timer_bs , 500u ); } TEST ( IsotpPoll , SendErrorSetsSendStatusError ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; link . send_size = 9 ; link . send_offset = 0 ; link . send_sn = 1 ; link . send_bs_remain = ISOTP_INVALID_BS ; link . send_st_min_us = 0 ; link . send_timer_st = 0 ; link . send_timer_bs = 500 ; g_now_us = 1 ; g_can_state . return_value = ISOTP_RET_ERROR ; isotp_poll ( & link ); EXPECT_EQ ( g_can_state . call_count , 1 ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_ERROR ); } TEST ( IsotpPoll , SendDecrementsBlockSizeRemain ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; link . send_size = 9 ; link . send_offset = 0 ; link . send_sn = 1 ; link . send_bs_remain = 2 ; link . send_st_min_us = 0 ; link . send_timer_st = 0 ; link . send_timer_bs = 1000 ; g_now_us = 10 ; isotp_poll ( & link ); EXPECT_EQ ( g_can_state . call_count , 1 ); EXPECT_EQ ( link . send_offset , 7u ); EXPECT_EQ ( link . send_bs_remain , 1u ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_INPROGRESS ); EXPECT_EQ ( link . send_timer_bs , g_now_us + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ); } TEST ( IsotpPoll , SendTimeoutSetsError ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; link . send_bs_remain = 0 ; link . send_timer_bs = 10 ; g_now_us = 11 ; isotp_poll ( & link ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_ERROR ); EXPECT_EQ ( link . send_protocol_result , ISOTP_PROTOCOL_RESULT_TIMEOUT_BS ); } TEST ( IsotpPoll , ReceiveDoesNotTimeoutWhenTimerZero ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 8 ] = { 0 }; uint8_t recvbuf [ 8 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . receive_status = ISOTP_RECEIVE_STATUS_INPROGRESS ; link . receive_timer_cr = 0 ; link . receive_protocol_result = ISOTP_PROTOCOL_RESULT_OK ; g_now_us = 100 ; isotp_poll ( & link ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_INPROGRESS ); EXPECT_EQ ( link . receive_protocol_result , ISOTP_PROTOCOL_RESULT_OK ); }","title":"File gtest_isotp_poll.cpp"},{"location":"docs/gtest__isotp__receive_8cpp/","text":"File gtest_isotp_receive.cpp \u00b6 FileList > tests > unit > gtest_isotp_receive.cpp Go to the source code of this file Unit tests for isotp_receive. More... #include <gtest/gtest.h> #include \"isotp_test_support.h\" Public Functions \u00b6 Type Name TEST (IsotpReceive, NoDataReturnsNoData) No data returns ISOTP_RET_NO_DATA. TEST (IsotpReceive, CopiesPayloadAndResetsState) Full payload copy resets receive state. TEST (IsotpReceive, CopiesPartialPayloadWhenBufferTooSmall) Small output buffer triggers partial copy. Detailed Description \u00b6 Covers empty receive, full copy, and truncation paths. Public Functions Documentation \u00b6 function TEST \u00b6 No data returns ISOTP_RET_NO_DATA. TEST ( IsotpReceive , NoDataReturnsNoData ) function TEST \u00b6 Full payload copy resets receive state. TEST ( IsotpReceive , CopiesPayloadAndResetsState ) function TEST \u00b6 Small output buffer triggers partial copy. TEST ( IsotpReceive , CopiesPartialPayloadWhenBufferTooSmall ) The documentation for this class was generated from the following file tests/unit/gtest_isotp_receive.cpp","title":"File gtest_isotp_receive.cpp"},{"location":"docs/gtest__isotp__receive_8cpp/#file-gtest_isotp_receivecpp","text":"FileList > tests > unit > gtest_isotp_receive.cpp Go to the source code of this file Unit tests for isotp_receive. More... #include <gtest/gtest.h> #include \"isotp_test_support.h\"","title":"File gtest_isotp_receive.cpp"},{"location":"docs/gtest__isotp__receive_8cpp/#public-functions","text":"Type Name TEST (IsotpReceive, NoDataReturnsNoData) No data returns ISOTP_RET_NO_DATA. TEST (IsotpReceive, CopiesPayloadAndResetsState) Full payload copy resets receive state. TEST (IsotpReceive, CopiesPartialPayloadWhenBufferTooSmall) Small output buffer triggers partial copy.","title":"Public Functions"},{"location":"docs/gtest__isotp__receive_8cpp/#detailed-description","text":"Covers empty receive, full copy, and truncation paths.","title":"Detailed Description"},{"location":"docs/gtest__isotp__receive_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/gtest__isotp__receive_8cpp/#function-test","text":"No data returns ISOTP_RET_NO_DATA. TEST ( IsotpReceive , NoDataReturnsNoData )","title":"function TEST"},{"location":"docs/gtest__isotp__receive_8cpp/#function-test_1","text":"Full payload copy resets receive state. TEST ( IsotpReceive , CopiesPayloadAndResetsState )","title":"function TEST"},{"location":"docs/gtest__isotp__receive_8cpp/#function-test_2","text":"Small output buffer triggers partial copy. TEST ( IsotpReceive , CopiesPartialPayloadWhenBufferTooSmall ) The documentation for this class was generated from the following file tests/unit/gtest_isotp_receive.cpp","title":"function TEST"},{"location":"docs/gtest__isotp__receive_8cpp_source/","text":"File gtest_isotp_receive.cpp \u00b6 File List > tests > unit > gtest_isotp_receive.cpp Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Unit tests for isotp_receive. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <gtest/gtest.h> #include \"isotp_test_support.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Macros and constants for this test file */ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Local type definitions */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ /* static variables */ /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ /* static helpers */ /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* static helper implementations */ /* ============================================================================== * UNIT TEST IMPLEMENTATIONS * =============================================================================*/ TEST ( IsotpReceive , NoDataReturnsNoData ) { IsoTpLink link ; uint8_t sendbuf [ 8 ] = { 0 }; uint8_t recvbuf [ 8 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); uint8_t payload [ 8 ] = { 0 }; uint32_t out_size = 0 ; int ret = isotp_receive ( & link , payload , sizeof ( payload ), & out_size ); EXPECT_EQ ( ret , ISOTP_RET_NO_DATA ); EXPECT_EQ ( out_size , 0u ); } TEST ( IsotpReceive , CopiesPayloadAndResetsState ) { IsoTpLink link ; uint8_t sendbuf [ 8 ] = { 0 }; uint8_t recvbuf [ 8 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . receive_status = ISOTP_RECEIVE_STATUS_FULL ; link . receive_size = 3 ; link . receive_buffer [ 0 ] = 0xA1 ; link . receive_buffer [ 1 ] = 0xB2 ; link . receive_buffer [ 2 ] = 0xC3 ; uint8_t payload [ 8 ] = { 0 }; uint32_t out_size = 0 ; int ret = isotp_receive ( & link , payload , sizeof ( payload ), & out_size ); EXPECT_EQ ( ret , ISOTP_RET_OK ); EXPECT_EQ ( out_size , 3u ); EXPECT_EQ ( payload [ 0 ], 0xA1 ); EXPECT_EQ ( payload [ 1 ], 0xB2 ); EXPECT_EQ ( payload [ 2 ], 0xC3 ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_IDLE ); } TEST ( IsotpReceive , CopiesPartialPayloadWhenBufferTooSmall ) { IsoTpLink link ; uint8_t sendbuf [ 8 ] = { 0 }; uint8_t recvbuf [ 8 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . receive_status = ISOTP_RECEIVE_STATUS_FULL ; link . receive_size = 4 ; link . receive_buffer [ 0 ] = 0x10 ; link . receive_buffer [ 1 ] = 0x20 ; link . receive_buffer [ 2 ] = 0x30 ; link . receive_buffer [ 3 ] = 0x40 ; uint8_t payload [ 2 ] = { 0 }; uint32_t out_size = 0 ; int ret = isotp_receive ( & link , payload , sizeof ( payload ), & out_size ); EXPECT_EQ ( ret , ISOTP_RET_OK ); EXPECT_EQ ( out_size , 2u ); EXPECT_EQ ( payload [ 0 ], 0x10 ); EXPECT_EQ ( payload [ 1 ], 0x20 ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_IDLE ); }","title":"File gtest_isotp_receive.cpp"},{"location":"docs/gtest__isotp__receive_8cpp_source/#file-gtest_isotp_receivecpp","text":"File List > tests > unit > gtest_isotp_receive.cpp Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Unit tests for isotp_receive. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <gtest/gtest.h> #include \"isotp_test_support.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Macros and constants for this test file */ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Local type definitions */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ /* static variables */ /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ /* static helpers */ /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* static helper implementations */ /* ============================================================================== * UNIT TEST IMPLEMENTATIONS * =============================================================================*/ TEST ( IsotpReceive , NoDataReturnsNoData ) { IsoTpLink link ; uint8_t sendbuf [ 8 ] = { 0 }; uint8_t recvbuf [ 8 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); uint8_t payload [ 8 ] = { 0 }; uint32_t out_size = 0 ; int ret = isotp_receive ( & link , payload , sizeof ( payload ), & out_size ); EXPECT_EQ ( ret , ISOTP_RET_NO_DATA ); EXPECT_EQ ( out_size , 0u ); } TEST ( IsotpReceive , CopiesPayloadAndResetsState ) { IsoTpLink link ; uint8_t sendbuf [ 8 ] = { 0 }; uint8_t recvbuf [ 8 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . receive_status = ISOTP_RECEIVE_STATUS_FULL ; link . receive_size = 3 ; link . receive_buffer [ 0 ] = 0xA1 ; link . receive_buffer [ 1 ] = 0xB2 ; link . receive_buffer [ 2 ] = 0xC3 ; uint8_t payload [ 8 ] = { 0 }; uint32_t out_size = 0 ; int ret = isotp_receive ( & link , payload , sizeof ( payload ), & out_size ); EXPECT_EQ ( ret , ISOTP_RET_OK ); EXPECT_EQ ( out_size , 3u ); EXPECT_EQ ( payload [ 0 ], 0xA1 ); EXPECT_EQ ( payload [ 1 ], 0xB2 ); EXPECT_EQ ( payload [ 2 ], 0xC3 ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_IDLE ); } TEST ( IsotpReceive , CopiesPartialPayloadWhenBufferTooSmall ) { IsoTpLink link ; uint8_t sendbuf [ 8 ] = { 0 }; uint8_t recvbuf [ 8 ] = { 0 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . receive_status = ISOTP_RECEIVE_STATUS_FULL ; link . receive_size = 4 ; link . receive_buffer [ 0 ] = 0x10 ; link . receive_buffer [ 1 ] = 0x20 ; link . receive_buffer [ 2 ] = 0x30 ; link . receive_buffer [ 3 ] = 0x40 ; uint8_t payload [ 2 ] = { 0 }; uint32_t out_size = 0 ; int ret = isotp_receive ( & link , payload , sizeof ( payload ), & out_size ); EXPECT_EQ ( ret , ISOTP_RET_OK ); EXPECT_EQ ( out_size , 2u ); EXPECT_EQ ( payload [ 0 ], 0x10 ); EXPECT_EQ ( payload [ 1 ], 0x20 ); EXPECT_EQ ( link . receive_status , ISOTP_RECEIVE_STATUS_IDLE ); }","title":"File gtest_isotp_receive.cpp"},{"location":"docs/gtest__isotp__send_8cpp/","text":"File gtest_isotp_send.cpp \u00b6 FileList > tests > unit > gtest_isotp_send.cpp Go to the source code of this file Unit tests for isotp_send. More... #include <gtest/gtest.h> #include \"isotp_test_support.h\" Public Functions \u00b6 Type Name TEST (IsotpSend, UsesLinkArbitrationId) Uses link arbitration ID for sending. TEST (IsotpSend, OversizeReturnsOverflow) Oversize payload returns overflow. TEST (IsotpSend, InProgressReturnsInProgress) In-progress send returns in-progress. Detailed Description \u00b6 Verifies arbitration ID usage and error returns. Public Functions Documentation \u00b6 function TEST \u00b6 Uses link arbitration ID for sending. TEST ( IsotpSend , UsesLinkArbitrationId ) function TEST \u00b6 Oversize payload returns overflow. TEST ( IsotpSend , OversizeReturnsOverflow ) function TEST \u00b6 In-progress send returns in-progress. TEST ( IsotpSend , InProgressReturnsInProgress ) The documentation for this class was generated from the following file tests/unit/gtest_isotp_send.cpp","title":"File gtest_isotp_send.cpp"},{"location":"docs/gtest__isotp__send_8cpp/#file-gtest_isotp_sendcpp","text":"FileList > tests > unit > gtest_isotp_send.cpp Go to the source code of this file Unit tests for isotp_send. More... #include <gtest/gtest.h> #include \"isotp_test_support.h\"","title":"File gtest_isotp_send.cpp"},{"location":"docs/gtest__isotp__send_8cpp/#public-functions","text":"Type Name TEST (IsotpSend, UsesLinkArbitrationId) Uses link arbitration ID for sending. TEST (IsotpSend, OversizeReturnsOverflow) Oversize payload returns overflow. TEST (IsotpSend, InProgressReturnsInProgress) In-progress send returns in-progress.","title":"Public Functions"},{"location":"docs/gtest__isotp__send_8cpp/#detailed-description","text":"Verifies arbitration ID usage and error returns.","title":"Detailed Description"},{"location":"docs/gtest__isotp__send_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/gtest__isotp__send_8cpp/#function-test","text":"Uses link arbitration ID for sending. TEST ( IsotpSend , UsesLinkArbitrationId )","title":"function TEST"},{"location":"docs/gtest__isotp__send_8cpp/#function-test_1","text":"Oversize payload returns overflow. TEST ( IsotpSend , OversizeReturnsOverflow )","title":"function TEST"},{"location":"docs/gtest__isotp__send_8cpp/#function-test_2","text":"In-progress send returns in-progress. TEST ( IsotpSend , InProgressReturnsInProgress ) The documentation for this class was generated from the following file tests/unit/gtest_isotp_send.cpp","title":"function TEST"},{"location":"docs/gtest__isotp__send_8cpp_source/","text":"File gtest_isotp_send.cpp \u00b6 File List > tests > unit > gtest_isotp_send.cpp Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Unit tests for isotp_send. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <gtest/gtest.h> #include \"isotp_test_support.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Macros and constants for this test file */ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Local type definitions */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ /* static variables */ /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ /* static helpers */ /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* static helper implementations */ /* ============================================================================== * UNIT TEST IMPLEMENTATIONS * =============================================================================*/ TEST ( IsotpSend , UsesLinkArbitrationId ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; const uint8_t payload [ 3 ] = { 0x11 , 0x22 , 0x33 }; isotp_init_link ( & link , 0x7DFu , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); int ret = isotp_send ( & link , payload , sizeof ( payload )); EXPECT_EQ ( ret , ISOTP_RET_OK ); EXPECT_EQ ( g_can_state . call_count , 1 ); EXPECT_EQ ( g_can_state . last_id , 0x7DFu ); } TEST ( IsotpSend , OversizeReturnsOverflow ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 4 ] = { 0 }; uint8_t recvbuf [ 4 ] = { 0 }; const uint8_t payload [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; isotp_init_link ( & link , 0x7DFu , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); int ret = isotp_send ( & link , payload , sizeof ( payload )); EXPECT_EQ ( ret , ISOTP_RET_OVERFLOW ); EXPECT_EQ ( g_can_state . call_count , 0 ); } TEST ( IsotpSend , InProgressReturnsInProgress ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 8 ] = { 0 }; uint8_t recvbuf [ 8 ] = { 0 }; const uint8_t payload [ 3 ] = { 1 , 2 , 3 }; isotp_init_link ( & link , 0x7DFu , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; int ret = isotp_send ( & link , payload , sizeof ( payload )); EXPECT_EQ ( ret , ISOTP_RET_INPROGRESS ); EXPECT_EQ ( g_can_state . call_count , 0 ); }","title":"File gtest_isotp_send.cpp"},{"location":"docs/gtest__isotp__send_8cpp_source/#file-gtest_isotp_sendcpp","text":"File List > tests > unit > gtest_isotp_send.cpp Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Unit tests for isotp_send. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <gtest/gtest.h> #include \"isotp_test_support.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Macros and constants for this test file */ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Local type definitions */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ /* static variables */ /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ /* static helpers */ /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* static helper implementations */ /* ============================================================================== * UNIT TEST IMPLEMENTATIONS * =============================================================================*/ TEST ( IsotpSend , UsesLinkArbitrationId ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; const uint8_t payload [ 3 ] = { 0x11 , 0x22 , 0x33 }; isotp_init_link ( & link , 0x7DFu , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); int ret = isotp_send ( & link , payload , sizeof ( payload )); EXPECT_EQ ( ret , ISOTP_RET_OK ); EXPECT_EQ ( g_can_state . call_count , 1 ); EXPECT_EQ ( g_can_state . last_id , 0x7DFu ); } TEST ( IsotpSend , OversizeReturnsOverflow ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 4 ] = { 0 }; uint8_t recvbuf [ 4 ] = { 0 }; const uint8_t payload [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; isotp_init_link ( & link , 0x7DFu , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); int ret = isotp_send ( & link , payload , sizeof ( payload )); EXPECT_EQ ( ret , ISOTP_RET_OVERFLOW ); EXPECT_EQ ( g_can_state . call_count , 0 ); } TEST ( IsotpSend , InProgressReturnsInProgress ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 8 ] = { 0 }; uint8_t recvbuf [ 8 ] = { 0 }; const uint8_t payload [ 3 ] = { 1 , 2 , 3 }; isotp_init_link ( & link , 0x7DFu , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; int ret = isotp_send ( & link , payload , sizeof ( payload )); EXPECT_EQ ( ret , ISOTP_RET_INPROGRESS ); EXPECT_EQ ( g_can_state . call_count , 0 ); }","title":"File gtest_isotp_send.cpp"},{"location":"docs/gtest__isotp__send__with__id_8cpp/","text":"File gtest_isotp_send_with_id.cpp \u00b6 FileList > tests > unit > gtest_isotp_send_with_id.cpp Go to the source code of this file Unit tests for isotp_send_with_id. More... #include <gtest/gtest.h> #include \"isotp_test_support.h\" Public Functions \u00b6 Type Name TEST (IsotpSendWithId, NullLinkReturnsError) Null link returns error. TEST (IsotpSendWithId, OversizeReturnsOverflow) Oversize payload returns overflow without sending. TEST (IsotpSendWithId, InProgressReturnsInProgress) In-progress send returns in-progress. TEST (IsotpSendWithId, SingleFrameSendsPayload) Single-frame payload is sent with provided ID. TEST (IsotpSendWithId, MultiFrameFirstFrameStartsSend) Multi-frame FF starts send and sets timers. TEST (IsotpSendWithId, MultiFrameFirstFrameSendErrorDoesNotStart) FF send error does not start send state. Detailed Description \u00b6 Covers error handling, overflow, and multi-frame start logic. Public Functions Documentation \u00b6 function TEST \u00b6 Null link returns error. TEST ( IsotpSendWithId , NullLinkReturnsError ) function TEST \u00b6 Oversize payload returns overflow without sending. TEST ( IsotpSendWithId , OversizeReturnsOverflow ) function TEST \u00b6 In-progress send returns in-progress. TEST ( IsotpSendWithId , InProgressReturnsInProgress ) function TEST \u00b6 Single-frame payload is sent with provided ID. TEST ( IsotpSendWithId , SingleFrameSendsPayload ) function TEST \u00b6 Multi-frame FF starts send and sets timers. TEST ( IsotpSendWithId , MultiFrameFirstFrameStartsSend ) function TEST \u00b6 FF send error does not start send state. TEST ( IsotpSendWithId , MultiFrameFirstFrameSendErrorDoesNotStart ) The documentation for this class was generated from the following file tests/unit/gtest_isotp_send_with_id.cpp","title":"File gtest_isotp_send_with_id.cpp"},{"location":"docs/gtest__isotp__send__with__id_8cpp/#file-gtest_isotp_send_with_idcpp","text":"FileList > tests > unit > gtest_isotp_send_with_id.cpp Go to the source code of this file Unit tests for isotp_send_with_id. More... #include <gtest/gtest.h> #include \"isotp_test_support.h\"","title":"File gtest_isotp_send_with_id.cpp"},{"location":"docs/gtest__isotp__send__with__id_8cpp/#public-functions","text":"Type Name TEST (IsotpSendWithId, NullLinkReturnsError) Null link returns error. TEST (IsotpSendWithId, OversizeReturnsOverflow) Oversize payload returns overflow without sending. TEST (IsotpSendWithId, InProgressReturnsInProgress) In-progress send returns in-progress. TEST (IsotpSendWithId, SingleFrameSendsPayload) Single-frame payload is sent with provided ID. TEST (IsotpSendWithId, MultiFrameFirstFrameStartsSend) Multi-frame FF starts send and sets timers. TEST (IsotpSendWithId, MultiFrameFirstFrameSendErrorDoesNotStart) FF send error does not start send state.","title":"Public Functions"},{"location":"docs/gtest__isotp__send__with__id_8cpp/#detailed-description","text":"Covers error handling, overflow, and multi-frame start logic.","title":"Detailed Description"},{"location":"docs/gtest__isotp__send__with__id_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/gtest__isotp__send__with__id_8cpp/#function-test","text":"Null link returns error. TEST ( IsotpSendWithId , NullLinkReturnsError )","title":"function TEST"},{"location":"docs/gtest__isotp__send__with__id_8cpp/#function-test_1","text":"Oversize payload returns overflow without sending. TEST ( IsotpSendWithId , OversizeReturnsOverflow )","title":"function TEST"},{"location":"docs/gtest__isotp__send__with__id_8cpp/#function-test_2","text":"In-progress send returns in-progress. TEST ( IsotpSendWithId , InProgressReturnsInProgress )","title":"function TEST"},{"location":"docs/gtest__isotp__send__with__id_8cpp/#function-test_3","text":"Single-frame payload is sent with provided ID. TEST ( IsotpSendWithId , SingleFrameSendsPayload )","title":"function TEST"},{"location":"docs/gtest__isotp__send__with__id_8cpp/#function-test_4","text":"Multi-frame FF starts send and sets timers. TEST ( IsotpSendWithId , MultiFrameFirstFrameStartsSend )","title":"function TEST"},{"location":"docs/gtest__isotp__send__with__id_8cpp/#function-test_5","text":"FF send error does not start send state. TEST ( IsotpSendWithId , MultiFrameFirstFrameSendErrorDoesNotStart ) The documentation for this class was generated from the following file tests/unit/gtest_isotp_send_with_id.cpp","title":"function TEST"},{"location":"docs/gtest__isotp__send__with__id_8cpp_source/","text":"File gtest_isotp_send_with_id.cpp \u00b6 File List > tests > unit > gtest_isotp_send_with_id.cpp Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Unit tests for isotp_send_with_id. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <gtest/gtest.h> #include \"isotp_test_support.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Macros and constants for this test file */ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Local type definitions */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ /* static variables */ /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ /* static helpers */ /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* static helper implementations */ /* ============================================================================== * UNIT TEST IMPLEMENTATIONS * =============================================================================*/ TEST ( IsotpSendWithId , NullLinkReturnsError ) { const uint8_t payload [ 1 ] = { 0x00 }; int ret = isotp_send_with_id ( NULL , 0x123u , payload , sizeof ( payload )); EXPECT_EQ ( ret , ISOTP_RET_ERROR ); } TEST ( IsotpSendWithId , OversizeReturnsOverflow ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 4 ] = { 0 }; uint8_t recvbuf [ 4 ] = { 0 }; const uint8_t payload [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); int ret = isotp_send_with_id ( & link , 0x123u , payload , sizeof ( payload )); EXPECT_EQ ( ret , ISOTP_RET_OVERFLOW ); EXPECT_EQ ( g_can_state . call_count , 0 ); } TEST ( IsotpSendWithId , InProgressReturnsInProgress ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 8 ] = { 0 }; uint8_t recvbuf [ 8 ] = { 0 }; const uint8_t payload [ 3 ] = { 1 , 2 , 3 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; int ret = isotp_send_with_id ( & link , 0x123u , payload , sizeof ( payload )); EXPECT_EQ ( ret , ISOTP_RET_INPROGRESS ); EXPECT_EQ ( g_can_state . call_count , 0 ); } TEST ( IsotpSendWithId , SingleFrameSendsPayload ) { GTEST_SKIP (); reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 8 ] = { 0 }; uint8_t recvbuf [ 8 ] = { 0 }; const uint8_t payload [ 3 ] = { 0xAA , 0xBB , 0xCC }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); int ret = isotp_send_with_id ( & link , 0x456u , payload , sizeof ( payload )); EXPECT_EQ ( ret , ISOTP_RET_OK ); EXPECT_EQ ( g_can_state . call_count , 1 ); EXPECT_EQ ( g_can_state . last_id , 0x456u ); EXPECT_EQ ( g_can_state . last_size , 4u ); #if defined(ISOTP_BYTE_ORDER_LITTLE_ENDIAN) EXPECT_EQ ( g_can_state . last_data [ 0 ], static_cast < uint8_t > (( ISOTP_PCI_TYPE_SINGLE << 4 ) | 0x03 )); #else EXPECT_EQ ( g_can_state . last_data [ 0 ], static_cast < uint8_t > (( 0x03 << 4 ) | ISOTP_PCI_TYPE_SINGLE )); #endif EXPECT_EQ ( g_can_state . last_data [ 1 ], payload [ 0 ]); EXPECT_EQ ( g_can_state . last_data [ 2 ], payload [ 1 ]); EXPECT_EQ ( g_can_state . last_data [ 3 ], payload [ 2 ]); } TEST ( IsotpSendWithId , MultiFrameFirstFrameStartsSend ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; const uint8_t payload [ 8 ] = { 0x10 , 0x11 , 0x12 , 0x13 , 0x14 , 0x15 , 0x16 , 0x17 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); g_now_us = 42 ; int ret = isotp_send_with_id ( & link , 0x456u , payload , sizeof ( payload )); EXPECT_EQ ( ret , ISOTP_RET_OK ); EXPECT_EQ ( g_can_state . call_count , 1 ); EXPECT_EQ ( g_can_state . last_id , 0x456u ); EXPECT_EQ ( g_can_state . last_size , 8u ); IsoTpCanMessage expected ; std :: memset ( & expected , 0 , sizeof ( expected )); expected . as . first_frame_short . type = ISOTP_PCI_TYPE_FIRST_FRAME ; expected . as . first_frame_short . FF_DL_high = 0 ; expected . as . first_frame_short . FF_DL_low = 8 ; std :: memcpy ( expected . as . first_frame_short . data , payload , sizeof ( expected . as . first_frame_short . data )); EXPECT_EQ ( std :: memcmp ( g_can_state . last_data , expected . as . data_array . ptr , 8 ), 0 ); EXPECT_EQ ( link . send_offset , 6u ); EXPECT_EQ ( link . send_sn , 1u ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_INPROGRESS ); EXPECT_EQ ( link . send_timer_st , g_now_us ); EXPECT_EQ ( link . send_timer_bs , g_now_us + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ); } TEST ( IsotpSendWithId , MultiFrameFirstFrameSendErrorDoesNotStart ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; const uint8_t payload [ 8 ] = { 0x20 , 0x21 , 0x22 , 0x23 , 0x24 , 0x25 , 0x26 , 0x27 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); g_can_state . return_value = ISOTP_RET_ERROR ; int ret = isotp_send_with_id ( & link , 0x456u , payload , sizeof ( payload )); EXPECT_EQ ( ret , ISOTP_RET_ERROR ); EXPECT_EQ ( g_can_state . call_count , 1 ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_IDLE ); EXPECT_EQ ( link . send_offset , 0u ); }","title":"File gtest_isotp_send_with_id.cpp"},{"location":"docs/gtest__isotp__send__with__id_8cpp_source/#file-gtest_isotp_send_with_idcpp","text":"File List > tests > unit > gtest_isotp_send_with_id.cpp Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Unit tests for isotp_send_with_id. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include <gtest/gtest.h> #include \"isotp_test_support.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* Macros and constants for this test file */ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* Local type definitions */ /* ============================================================================== * PRIVATE VARIABLES (static) * =============================================================================*/ /* static variables */ /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ /* static helpers */ /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* static helper implementations */ /* ============================================================================== * UNIT TEST IMPLEMENTATIONS * =============================================================================*/ TEST ( IsotpSendWithId , NullLinkReturnsError ) { const uint8_t payload [ 1 ] = { 0x00 }; int ret = isotp_send_with_id ( NULL , 0x123u , payload , sizeof ( payload )); EXPECT_EQ ( ret , ISOTP_RET_ERROR ); } TEST ( IsotpSendWithId , OversizeReturnsOverflow ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 4 ] = { 0 }; uint8_t recvbuf [ 4 ] = { 0 }; const uint8_t payload [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); int ret = isotp_send_with_id ( & link , 0x123u , payload , sizeof ( payload )); EXPECT_EQ ( ret , ISOTP_RET_OVERFLOW ); EXPECT_EQ ( g_can_state . call_count , 0 ); } TEST ( IsotpSendWithId , InProgressReturnsInProgress ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 8 ] = { 0 }; uint8_t recvbuf [ 8 ] = { 0 }; const uint8_t payload [ 3 ] = { 1 , 2 , 3 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); link . send_status = ISOTP_SEND_STATUS_INPROGRESS ; int ret = isotp_send_with_id ( & link , 0x123u , payload , sizeof ( payload )); EXPECT_EQ ( ret , ISOTP_RET_INPROGRESS ); EXPECT_EQ ( g_can_state . call_count , 0 ); } TEST ( IsotpSendWithId , SingleFrameSendsPayload ) { GTEST_SKIP (); reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 8 ] = { 0 }; uint8_t recvbuf [ 8 ] = { 0 }; const uint8_t payload [ 3 ] = { 0xAA , 0xBB , 0xCC }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); int ret = isotp_send_with_id ( & link , 0x456u , payload , sizeof ( payload )); EXPECT_EQ ( ret , ISOTP_RET_OK ); EXPECT_EQ ( g_can_state . call_count , 1 ); EXPECT_EQ ( g_can_state . last_id , 0x456u ); EXPECT_EQ ( g_can_state . last_size , 4u ); #if defined(ISOTP_BYTE_ORDER_LITTLE_ENDIAN) EXPECT_EQ ( g_can_state . last_data [ 0 ], static_cast < uint8_t > (( ISOTP_PCI_TYPE_SINGLE << 4 ) | 0x03 )); #else EXPECT_EQ ( g_can_state . last_data [ 0 ], static_cast < uint8_t > (( 0x03 << 4 ) | ISOTP_PCI_TYPE_SINGLE )); #endif EXPECT_EQ ( g_can_state . last_data [ 1 ], payload [ 0 ]); EXPECT_EQ ( g_can_state . last_data [ 2 ], payload [ 1 ]); EXPECT_EQ ( g_can_state . last_data [ 3 ], payload [ 2 ]); } TEST ( IsotpSendWithId , MultiFrameFirstFrameStartsSend ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; const uint8_t payload [ 8 ] = { 0x10 , 0x11 , 0x12 , 0x13 , 0x14 , 0x15 , 0x16 , 0x17 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); g_now_us = 42 ; int ret = isotp_send_with_id ( & link , 0x456u , payload , sizeof ( payload )); EXPECT_EQ ( ret , ISOTP_RET_OK ); EXPECT_EQ ( g_can_state . call_count , 1 ); EXPECT_EQ ( g_can_state . last_id , 0x456u ); EXPECT_EQ ( g_can_state . last_size , 8u ); IsoTpCanMessage expected ; std :: memset ( & expected , 0 , sizeof ( expected )); expected . as . first_frame_short . type = ISOTP_PCI_TYPE_FIRST_FRAME ; expected . as . first_frame_short . FF_DL_high = 0 ; expected . as . first_frame_short . FF_DL_low = 8 ; std :: memcpy ( expected . as . first_frame_short . data , payload , sizeof ( expected . as . first_frame_short . data )); EXPECT_EQ ( std :: memcmp ( g_can_state . last_data , expected . as . data_array . ptr , 8 ), 0 ); EXPECT_EQ ( link . send_offset , 6u ); EXPECT_EQ ( link . send_sn , 1u ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_INPROGRESS ); EXPECT_EQ ( link . send_timer_st , g_now_us ); EXPECT_EQ ( link . send_timer_bs , g_now_us + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ); } TEST ( IsotpSendWithId , MultiFrameFirstFrameSendErrorDoesNotStart ) { reset_mocks (); IsoTpLink link ; uint8_t sendbuf [ 16 ] = { 0 }; uint8_t recvbuf [ 16 ] = { 0 }; const uint8_t payload [ 8 ] = { 0x20 , 0x21 , 0x22 , 0x23 , 0x24 , 0x25 , 0x26 , 0x27 }; isotp_init_link ( & link , 0x123u , sendbuf , sizeof ( sendbuf ), recvbuf , sizeof ( recvbuf )); g_can_state . return_value = ISOTP_RET_ERROR ; int ret = isotp_send_with_id ( & link , 0x456u , payload , sizeof ( payload )); EXPECT_EQ ( ret , ISOTP_RET_ERROR ); EXPECT_EQ ( g_can_state . call_count , 1 ); EXPECT_EQ ( link . send_status , ISOTP_SEND_STATUS_IDLE ); EXPECT_EQ ( link . send_offset , 0u ); }","title":"File gtest_isotp_send_with_id.cpp"},{"location":"docs/isotp__test__mocks_8cpp/","text":"File isotp_test_mocks.cpp \u00b6 FileList > tests > unit > isotp_test_mocks.cpp Go to the source code of this file Test doubles for ISO-TP user callbacks. More... #include \"isotp_test_support.h\" Public Attributes \u00b6 Type Name MockCanState g_can_state = {0} Global state for CAN send mock. int g_debug_call_count = 0 Global state for counting debug calls. uint32_t g_now_us = 0 Global state for current time in microseconds. Public Functions \u00b6 Type Name void reset_mocks () Reset all mock state to defaults. Detailed Description \u00b6 Provides mock time and CAN send implementations. Public Attributes Documentation \u00b6 variable g_can_state \u00b6 Global state for CAN send mock. MockCanState g_can_state ; variable g_debug_call_count \u00b6 Global state for counting debug calls. int g_debug_call_count ; variable g_now_us \u00b6 Global state for current time in microseconds. uint32_t g_now_us ; Public Functions Documentation \u00b6 function reset_mocks \u00b6 Reset all mock state to defaults. void reset_mocks () Reset all mock state to initial values. The documentation for this class was generated from the following file tests/unit/isotp_test_mocks.cpp","title":"File isotp_test_mocks.cpp"},{"location":"docs/isotp__test__mocks_8cpp/#file-isotp_test_mockscpp","text":"FileList > tests > unit > isotp_test_mocks.cpp Go to the source code of this file Test doubles for ISO-TP user callbacks. More... #include \"isotp_test_support.h\"","title":"File isotp_test_mocks.cpp"},{"location":"docs/isotp__test__mocks_8cpp/#public-attributes","text":"Type Name MockCanState g_can_state = {0} Global state for CAN send mock. int g_debug_call_count = 0 Global state for counting debug calls. uint32_t g_now_us = 0 Global state for current time in microseconds.","title":"Public Attributes"},{"location":"docs/isotp__test__mocks_8cpp/#public-functions","text":"Type Name void reset_mocks () Reset all mock state to defaults.","title":"Public Functions"},{"location":"docs/isotp__test__mocks_8cpp/#detailed-description","text":"Provides mock time and CAN send implementations.","title":"Detailed Description"},{"location":"docs/isotp__test__mocks_8cpp/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/isotp__test__mocks_8cpp/#variable-g_can_state","text":"Global state for CAN send mock. MockCanState g_can_state ;","title":"variable g_can_state"},{"location":"docs/isotp__test__mocks_8cpp/#variable-g_debug_call_count","text":"Global state for counting debug calls. int g_debug_call_count ;","title":"variable g_debug_call_count"},{"location":"docs/isotp__test__mocks_8cpp/#variable-g_now_us","text":"Global state for current time in microseconds. uint32_t g_now_us ;","title":"variable g_now_us"},{"location":"docs/isotp__test__mocks_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/isotp__test__mocks_8cpp/#function-reset_mocks","text":"Reset all mock state to defaults. void reset_mocks () Reset all mock state to initial values. The documentation for this class was generated from the following file tests/unit/isotp_test_mocks.cpp","title":"function reset_mocks"},{"location":"docs/isotp__test__mocks_8cpp_source/","text":"File isotp_test_mocks.cpp \u00b6 File List > tests > unit > isotp_test_mocks.cpp Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Test doubles for ISO-TP user callbacks. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include \"isotp_test_support.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* ============================================================================== * PUBLIC VARIABLES * =============================================================================*/ MockCanState g_can_state = { 0 }; uint32_t g_now_us = 0 ; int g_debug_call_count = 0 ; /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* ============================================================================== * PUBLIC FUNCTION IMPLEMENTATIONS * =============================================================================*/ void reset_mocks () { std :: memset ( & g_can_state , 0 , sizeof ( g_can_state )); g_can_state . return_value = ISOTP_RET_OK ; g_now_us = 0 ; g_debug_call_count = 0 ; } extern \"C\" { void isotp_user_debug ( const char * message , ...) { ( void ) message ; g_debug_call_count ++ ; } int isotp_user_send_can ( const uint32_t arbitration_id , const uint8_t * data , const uint8_t size ) { g_can_state . last_id = arbitration_id ; g_can_state . last_size = size ; g_can_state . call_count ++ ; std :: memset ( g_can_state . last_data , 0 , sizeof ( g_can_state . last_data )); if ( data != NULL ) { uint8_t copy_len = size ; if ( copy_len > sizeof ( g_can_state . last_data )) { copy_len = sizeof ( g_can_state . last_data ); } std :: memcpy ( g_can_state . last_data , data , copy_len ); } return g_can_state . return_value ; } uint32_t isotp_user_get_us ( void ) { return g_now_us ; } }","title":"File isotp_test_mocks.cpp"},{"location":"docs/isotp__test__mocks_8cpp_source/#file-isotp_test_mockscpp","text":"File List > tests > unit > isotp_test_mocks.cpp Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Test doubles for ISO-TP user callbacks. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ /* ============================================================================== * INCLUDES * =============================================================================*/ #include \"isotp_test_support.h\" /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* ============================================================================== * PRIVATE TYPE DEFINITIONS * =============================================================================*/ /* ============================================================================== * PUBLIC VARIABLES * =============================================================================*/ MockCanState g_can_state = { 0 }; uint32_t g_now_us = 0 ; int g_debug_call_count = 0 ; /* ============================================================================== * PRIVATE FUNCTION DECLARATIONS (static) * =============================================================================*/ /* ============================================================================== * PRIVATE FUNCTION IMPLEMENTATIONS * =============================================================================*/ /* ============================================================================== * PUBLIC FUNCTION IMPLEMENTATIONS * =============================================================================*/ void reset_mocks () { std :: memset ( & g_can_state , 0 , sizeof ( g_can_state )); g_can_state . return_value = ISOTP_RET_OK ; g_now_us = 0 ; g_debug_call_count = 0 ; } extern \"C\" { void isotp_user_debug ( const char * message , ...) { ( void ) message ; g_debug_call_count ++ ; } int isotp_user_send_can ( const uint32_t arbitration_id , const uint8_t * data , const uint8_t size ) { g_can_state . last_id = arbitration_id ; g_can_state . last_size = size ; g_can_state . call_count ++ ; std :: memset ( g_can_state . last_data , 0 , sizeof ( g_can_state . last_data )); if ( data != NULL ) { uint8_t copy_len = size ; if ( copy_len > sizeof ( g_can_state . last_data )) { copy_len = sizeof ( g_can_state . last_data ); } std :: memcpy ( g_can_state . last_data , data , copy_len ); } return g_can_state . return_value ; } uint32_t isotp_user_get_us ( void ) { return g_now_us ; } }","title":"File isotp_test_mocks.cpp"},{"location":"docs/isotp__test__support_8h/","text":"File isotp_test_support.h \u00b6 FileList > tests > unit > isotp_test_support.h Go to the source code of this file Test support utilities and mocks. More... #include <cstdint> #include <cstddef> #include <cstring> #include \"isotp.h\" Classes \u00b6 Type Name struct MockCanState Mock CAN state structure for testing purposes. Public Attributes \u00b6 Type Name MockCanState g_can_state Global state for CAN send mock. int g_debug_call_count Global state for counting debug calls. uint32_t g_now_us Global state for current time in microseconds. Public Functions \u00b6 Type Name void reset_mocks () Reset all mock state to initial values. Detailed Description \u00b6 Declares mock state and helper APIs for unit tests. Public Attributes Documentation \u00b6 variable g_can_state \u00b6 Global state for CAN send mock. MockCanState g_can_state ; variable g_debug_call_count \u00b6 Global state for counting debug calls. int g_debug_call_count ; variable g_now_us \u00b6 Global state for current time in microseconds. uint32_t g_now_us ; Public Functions Documentation \u00b6 function reset_mocks \u00b6 Reset all mock state to initial values. void reset_mocks () Should be called before each test to avoid cross-test leakage. Reset all mock state to initial values. The documentation for this class was generated from the following file tests/unit/isotp_test_support.h","title":"File isotp_test_support.h"},{"location":"docs/isotp__test__support_8h/#file-isotp_test_supporth","text":"FileList > tests > unit > isotp_test_support.h Go to the source code of this file Test support utilities and mocks. More... #include <cstdint> #include <cstddef> #include <cstring> #include \"isotp.h\"","title":"File isotp_test_support.h"},{"location":"docs/isotp__test__support_8h/#classes","text":"Type Name struct MockCanState Mock CAN state structure for testing purposes.","title":"Classes"},{"location":"docs/isotp__test__support_8h/#public-attributes","text":"Type Name MockCanState g_can_state Global state for CAN send mock. int g_debug_call_count Global state for counting debug calls. uint32_t g_now_us Global state for current time in microseconds.","title":"Public Attributes"},{"location":"docs/isotp__test__support_8h/#public-functions","text":"Type Name void reset_mocks () Reset all mock state to initial values.","title":"Public Functions"},{"location":"docs/isotp__test__support_8h/#detailed-description","text":"Declares mock state and helper APIs for unit tests.","title":"Detailed Description"},{"location":"docs/isotp__test__support_8h/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"docs/isotp__test__support_8h/#variable-g_can_state","text":"Global state for CAN send mock. MockCanState g_can_state ;","title":"variable g_can_state"},{"location":"docs/isotp__test__support_8h/#variable-g_debug_call_count","text":"Global state for counting debug calls. int g_debug_call_count ;","title":"variable g_debug_call_count"},{"location":"docs/isotp__test__support_8h/#variable-g_now_us","text":"Global state for current time in microseconds. uint32_t g_now_us ;","title":"variable g_now_us"},{"location":"docs/isotp__test__support_8h/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"docs/isotp__test__support_8h/#function-reset_mocks","text":"Reset all mock state to initial values. void reset_mocks () Should be called before each test to avoid cross-test leakage. Reset all mock state to initial values. The documentation for this class was generated from the following file tests/unit/isotp_test_support.h","title":"function reset_mocks"},{"location":"docs/isotp__test__support_8h_source/","text":"File isotp_test_support.h \u00b6 File List > tests > unit > isotp_test_support.h Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Test support utilities and mocks. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ #ifndef ISOTP_TEST_SUPPORT_H #define ISOTP_TEST_SUPPORT_H /* ============================================================================== * INCLUDES * =============================================================================*/ #include <cstdint> #include <cstddef> #include <cstring> extern \"C\" { #include \"isotp.h\" } /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* ============================================================================== * TYPE DEFINITIONS * =============================================================================*/ struct MockCanState { uint32_t last_id ; uint8_t last_data [ 8 ]; uint8_t last_size ; int return_value ; int call_count ; }; /* ============================================================================== * GLOBAL VARIABLES (extern declarations) * =============================================================================*/ extern MockCanState g_can_state ; extern uint32_t g_now_us ; extern int g_debug_call_count ; /* ============================================================================== * PUBLIC FUNCTION DECLARATIONS * =============================================================================*/ void reset_mocks (); #endif // ISOTP_TEST_SUPPORT_H","title":"File isotp_test_support.h"},{"location":"docs/isotp__test__support_8h_source/#file-isotp_test_supporth","text":"File List > tests > unit > isotp_test_support.h Go to the documentation of this file /******************************************************************************* * ISO-TP-C: ISO 15765-2 Protocol Implementation * * Project: ISO-TP-C - Embedded-Grade Refactoring & Optimization * Description: Test support utilities and mocks. * * Author: Anton Vynohradov * Email: avynohradov@systemfromscratch.com * * License: MIT License * * Copyright (c) 2026 Anton Vynohradov * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * * SPDX-License-Identifier: MIT ******************************************************************************/ #ifndef ISOTP_TEST_SUPPORT_H #define ISOTP_TEST_SUPPORT_H /* ============================================================================== * INCLUDES * =============================================================================*/ #include <cstdint> #include <cstddef> #include <cstring> extern \"C\" { #include \"isotp.h\" } /* ============================================================================== * DEFINES & MACROS * =============================================================================*/ /* ============================================================================== * TYPE DEFINITIONS * =============================================================================*/ struct MockCanState { uint32_t last_id ; uint8_t last_data [ 8 ]; uint8_t last_size ; int return_value ; int call_count ; }; /* ============================================================================== * GLOBAL VARIABLES (extern declarations) * =============================================================================*/ extern MockCanState g_can_state ; extern uint32_t g_now_us ; extern int g_debug_call_count ; /* ============================================================================== * PUBLIC FUNCTION DECLARATIONS * =============================================================================*/ void reset_mocks (); #endif // ISOTP_TEST_SUPPORT_H","title":"File isotp_test_support.h"},{"location":"docs/namespaces/","text":"Namespace List \u00b6 Here is a list of all namespaces with brief descriptions: namespace conftest namespace test_api_endpoints namespace test_api_validation namespace test_buffer_limits namespace test_cantp namespace test_flow_control namespace test_multi_frame namespace test_timing","title":"Namespace List"},{"location":"docs/namespaces/#namespace-list","text":"Here is a list of all namespaces with brief descriptions: namespace conftest namespace test_api_endpoints namespace test_api_validation namespace test_buffer_limits namespace test_cantp namespace test_flow_control namespace test_multi_frame namespace test_timing","title":"Namespace List"},{"location":"docs/classes/","text":"Class Index \u00b6 c \u00b6 can_driver_t can_frame_t i \u00b6 IsoTpCanMessage IsoTpConsecutiveFrame IsoTpDataArray IsoTpFirstFrameShort IsoTpFlowControl IsoTpLink IsoTpPciType IsoTpSingleFrame m \u00b6 MockCanState","title":"Class Index"},{"location":"docs/classes/#class-index","text":"","title":"Class Index"},{"location":"docs/classes/#c","text":"can_driver_t can_frame_t","title":"c"},{"location":"docs/classes/#i","text":"IsoTpCanMessage IsoTpConsecutiveFrame IsoTpDataArray IsoTpFirstFrameShort IsoTpFlowControl IsoTpLink IsoTpPciType IsoTpSingleFrame","title":"i"},{"location":"docs/classes/#m","text":"MockCanState","title":"m"},{"location":"docs/hierarchy/","text":"Class Hierarchy \u00b6 This inheritance list is sorted roughly, but not completely, alphabetically: struct IsoTpCanMessage struct IsoTpConsecutiveFrame Consecutive frame layout. struct IsoTpDataArray struct IsoTpFirstFrameShort First frame (short) layout. struct IsoTpFlowControl Flow control frame layout. struct IsoTpLink Link state for a single ISO-TP connection. struct IsoTpPciType CAN frame definitions. struct IsoTpSingleFrame Single frame layout. struct MockCanState Mock CAN state structure for testing purposes. struct can_driver_t struct can_frame_t Structure representing a CAN frame in the mock driver.","title":"Class Hierarchy"},{"location":"docs/hierarchy/#class-hierarchy","text":"This inheritance list is sorted roughly, but not completely, alphabetically: struct IsoTpCanMessage struct IsoTpConsecutiveFrame Consecutive frame layout. struct IsoTpDataArray struct IsoTpFirstFrameShort First frame (short) layout. struct IsoTpFlowControl Flow control frame layout. struct IsoTpLink Link state for a single ISO-TP connection. struct IsoTpPciType CAN frame definitions. struct IsoTpSingleFrame Single frame layout. struct MockCanState Mock CAN state structure for testing purposes. struct can_driver_t struct can_frame_t Structure representing a CAN frame in the mock driver.","title":"Class Hierarchy"},{"location":"docs/modules/","text":"Modules \u00b6 Here is a list of all modules: ISO-TP API Public API for ISO-TP link management and message handling. Configuration Build-time configuration for ISO-TP. Protocol definitions Internal protocol definitions and type structures. User hooks User-implemented callbacks and platform hooks.","title":"Modules"},{"location":"docs/modules/#modules","text":"Here is a list of all modules: ISO-TP API Public API for ISO-TP link management and message handling. Configuration Build-time configuration for ISO-TP. Protocol definitions Internal protocol definitions and type structures. User hooks User-implemented callbacks and platform hooks.","title":"Modules"},{"location":"docs/pages/","text":"Related Pages \u00b6 Here is a list of all related documentation pages:","title":"Related Pages"},{"location":"docs/pages/#related-pages","text":"Here is a list of all related documentation pages:","title":"Related Pages"},{"location":"docs/class_members/","text":"Class Members \u00b6 a \u00b6 as ( IsoTpCanMessage ) b \u00b6 BS ( IsoTpFlowControl ) c \u00b6 common ( IsoTpCanMessage ) consecutive_frame ( IsoTpCanMessage ) call_count ( MockCanState ) d \u00b6 data_array ( IsoTpCanMessage ) data ( IsoTpConsecutiveFrame , IsoTpFirstFrameShort , IsoTpSingleFrame , can_frame_t ) f \u00b6 first_frame_long ( IsoTpCanMessage ) first_frame_short ( IsoTpCanMessage ) flow_control ( IsoTpCanMessage ) FF_DL_high ( IsoTpFirstFrameShort ) FF_DL_low ( IsoTpFirstFrameShort ) FS ( IsoTpFlowControl ) i \u00b6 id ( can_frame_t ) l \u00b6 last_data ( MockCanState ) last_id ( MockCanState ) last_size ( MockCanState ) len ( can_frame_t ) p \u00b6 ptr ( IsoTpDataArray ) param_block_size ( IsoTpLink ) param_n_bs_us ( IsoTpLink ) param_n_cr_us ( IsoTpLink ) param_st_min_us ( IsoTpLink ) r \u00b6 reserve ( IsoTpFlowControl ) receive_arbitration_id ( IsoTpLink ) receive_bs_count ( IsoTpLink ) receive_buf_size ( IsoTpLink ) receive_buffer ( IsoTpLink ) receive_offset ( IsoTpLink ) receive_protocol_result ( IsoTpLink ) receive_size ( IsoTpLink ) receive_sn ( IsoTpLink ) receive_status ( IsoTpLink ) receive_timer_cr ( IsoTpLink ) reserve_1 ( IsoTpPciType ) reserve_2 ( IsoTpPciType ) return_value ( MockCanState ) receive ( can_driver_t ) s \u00b6 single_frame ( IsoTpCanMessage ) SN ( IsoTpConsecutiveFrame ) STmin ( IsoTpFlowControl ) send_arbitration_id ( IsoTpLink ) send_bs_remain ( IsoTpLink ) send_buf_size ( IsoTpLink ) send_buffer ( IsoTpLink ) send_offset ( IsoTpLink ) send_protocol_result ( IsoTpLink ) send_size ( IsoTpLink ) send_sn ( IsoTpLink ) send_st_min_us ( IsoTpLink ) send_status ( IsoTpLink ) send_timer_bs ( IsoTpLink ) send_timer_st ( IsoTpLink ) send_wtf_count ( IsoTpLink ) SF_DL ( IsoTpSingleFrame ) send ( can_driver_t ) t \u00b6 type ( IsoTpConsecutiveFrame , IsoTpFirstFrameShort , IsoTpFlowControl , IsoTpPciType , IsoTpSingleFrame )","title":"Class Members"},{"location":"docs/class_members/#class-members","text":"","title":"Class Members"},{"location":"docs/class_members/#a","text":"as ( IsoTpCanMessage )","title":"a"},{"location":"docs/class_members/#b","text":"BS ( IsoTpFlowControl )","title":"b"},{"location":"docs/class_members/#c","text":"common ( IsoTpCanMessage ) consecutive_frame ( IsoTpCanMessage ) call_count ( MockCanState )","title":"c"},{"location":"docs/class_members/#d","text":"data_array ( IsoTpCanMessage ) data ( IsoTpConsecutiveFrame , IsoTpFirstFrameShort , IsoTpSingleFrame , can_frame_t )","title":"d"},{"location":"docs/class_members/#f","text":"first_frame_long ( IsoTpCanMessage ) first_frame_short ( IsoTpCanMessage ) flow_control ( IsoTpCanMessage ) FF_DL_high ( IsoTpFirstFrameShort ) FF_DL_low ( IsoTpFirstFrameShort ) FS ( IsoTpFlowControl )","title":"f"},{"location":"docs/class_members/#i","text":"id ( can_frame_t )","title":"i"},{"location":"docs/class_members/#l","text":"last_data ( MockCanState ) last_id ( MockCanState ) last_size ( MockCanState ) len ( can_frame_t )","title":"l"},{"location":"docs/class_members/#p","text":"ptr ( IsoTpDataArray ) param_block_size ( IsoTpLink ) param_n_bs_us ( IsoTpLink ) param_n_cr_us ( IsoTpLink ) param_st_min_us ( IsoTpLink )","title":"p"},{"location":"docs/class_members/#r","text":"reserve ( IsoTpFlowControl ) receive_arbitration_id ( IsoTpLink ) receive_bs_count ( IsoTpLink ) receive_buf_size ( IsoTpLink ) receive_buffer ( IsoTpLink ) receive_offset ( IsoTpLink ) receive_protocol_result ( IsoTpLink ) receive_size ( IsoTpLink ) receive_sn ( IsoTpLink ) receive_status ( IsoTpLink ) receive_timer_cr ( IsoTpLink ) reserve_1 ( IsoTpPciType ) reserve_2 ( IsoTpPciType ) return_value ( MockCanState ) receive ( can_driver_t )","title":"r"},{"location":"docs/class_members/#s","text":"single_frame ( IsoTpCanMessage ) SN ( IsoTpConsecutiveFrame ) STmin ( IsoTpFlowControl ) send_arbitration_id ( IsoTpLink ) send_bs_remain ( IsoTpLink ) send_buf_size ( IsoTpLink ) send_buffer ( IsoTpLink ) send_offset ( IsoTpLink ) send_protocol_result ( IsoTpLink ) send_size ( IsoTpLink ) send_sn ( IsoTpLink ) send_st_min_us ( IsoTpLink ) send_status ( IsoTpLink ) send_timer_bs ( IsoTpLink ) send_timer_st ( IsoTpLink ) send_wtf_count ( IsoTpLink ) SF_DL ( IsoTpSingleFrame ) send ( can_driver_t )","title":"s"},{"location":"docs/class_members/#t","text":"type ( IsoTpConsecutiveFrame , IsoTpFirstFrameShort , IsoTpFlowControl , IsoTpPciType , IsoTpSingleFrame )","title":"t"},{"location":"docs/class_member_functions/","text":"Class Member Functions \u00b6 Nothing related to Class Member Functions found.","title":"Class Member Functions"},{"location":"docs/class_member_functions/#class-member-functions","text":"Nothing related to Class Member Functions found.","title":"Class Member Functions"},{"location":"docs/class_member_variables/","text":"Class Member Variables \u00b6 a \u00b6 as ( IsoTpCanMessage ) b \u00b6 BS ( IsoTpFlowControl ) c \u00b6 common ( IsoTpCanMessage ) consecutive_frame ( IsoTpCanMessage ) call_count ( MockCanState ) d \u00b6 data_array ( IsoTpCanMessage ) data ( IsoTpConsecutiveFrame , IsoTpFirstFrameShort , IsoTpSingleFrame , can_frame_t ) f \u00b6 first_frame_long ( IsoTpCanMessage ) first_frame_short ( IsoTpCanMessage ) flow_control ( IsoTpCanMessage ) FF_DL_high ( IsoTpFirstFrameShort ) FF_DL_low ( IsoTpFirstFrameShort ) FS ( IsoTpFlowControl ) i \u00b6 id ( can_frame_t ) l \u00b6 last_data ( MockCanState ) last_id ( MockCanState ) last_size ( MockCanState ) len ( can_frame_t ) p \u00b6 ptr ( IsoTpDataArray ) param_block_size ( IsoTpLink ) param_n_bs_us ( IsoTpLink ) param_n_cr_us ( IsoTpLink ) param_st_min_us ( IsoTpLink ) r \u00b6 reserve ( IsoTpFlowControl ) receive_arbitration_id ( IsoTpLink ) receive_bs_count ( IsoTpLink ) receive_buf_size ( IsoTpLink ) receive_buffer ( IsoTpLink ) receive_offset ( IsoTpLink ) receive_protocol_result ( IsoTpLink ) receive_size ( IsoTpLink ) receive_sn ( IsoTpLink ) receive_status ( IsoTpLink ) receive_timer_cr ( IsoTpLink ) reserve_1 ( IsoTpPciType ) reserve_2 ( IsoTpPciType ) return_value ( MockCanState ) receive ( can_driver_t ) s \u00b6 single_frame ( IsoTpCanMessage ) SN ( IsoTpConsecutiveFrame ) STmin ( IsoTpFlowControl ) send_arbitration_id ( IsoTpLink ) send_bs_remain ( IsoTpLink ) send_buf_size ( IsoTpLink ) send_buffer ( IsoTpLink ) send_offset ( IsoTpLink ) send_protocol_result ( IsoTpLink ) send_size ( IsoTpLink ) send_sn ( IsoTpLink ) send_st_min_us ( IsoTpLink ) send_status ( IsoTpLink ) send_timer_bs ( IsoTpLink ) send_timer_st ( IsoTpLink ) send_wtf_count ( IsoTpLink ) SF_DL ( IsoTpSingleFrame ) send ( can_driver_t ) t \u00b6 type ( IsoTpConsecutiveFrame , IsoTpFirstFrameShort , IsoTpFlowControl , IsoTpPciType , IsoTpSingleFrame )","title":"Class Member Variables"},{"location":"docs/class_member_variables/#class-member-variables","text":"","title":"Class Member Variables"},{"location":"docs/class_member_variables/#a","text":"as ( IsoTpCanMessage )","title":"a"},{"location":"docs/class_member_variables/#b","text":"BS ( IsoTpFlowControl )","title":"b"},{"location":"docs/class_member_variables/#c","text":"common ( IsoTpCanMessage ) consecutive_frame ( IsoTpCanMessage ) call_count ( MockCanState )","title":"c"},{"location":"docs/class_member_variables/#d","text":"data_array ( IsoTpCanMessage ) data ( IsoTpConsecutiveFrame , IsoTpFirstFrameShort , IsoTpSingleFrame , can_frame_t )","title":"d"},{"location":"docs/class_member_variables/#f","text":"first_frame_long ( IsoTpCanMessage ) first_frame_short ( IsoTpCanMessage ) flow_control ( IsoTpCanMessage ) FF_DL_high ( IsoTpFirstFrameShort ) FF_DL_low ( IsoTpFirstFrameShort ) FS ( IsoTpFlowControl )","title":"f"},{"location":"docs/class_member_variables/#i","text":"id ( can_frame_t )","title":"i"},{"location":"docs/class_member_variables/#l","text":"last_data ( MockCanState ) last_id ( MockCanState ) last_size ( MockCanState ) len ( can_frame_t )","title":"l"},{"location":"docs/class_member_variables/#p","text":"ptr ( IsoTpDataArray ) param_block_size ( IsoTpLink ) param_n_bs_us ( IsoTpLink ) param_n_cr_us ( IsoTpLink ) param_st_min_us ( IsoTpLink )","title":"p"},{"location":"docs/class_member_variables/#r","text":"reserve ( IsoTpFlowControl ) receive_arbitration_id ( IsoTpLink ) receive_bs_count ( IsoTpLink ) receive_buf_size ( IsoTpLink ) receive_buffer ( IsoTpLink ) receive_offset ( IsoTpLink ) receive_protocol_result ( IsoTpLink ) receive_size ( IsoTpLink ) receive_sn ( IsoTpLink ) receive_status ( IsoTpLink ) receive_timer_cr ( IsoTpLink ) reserve_1 ( IsoTpPciType ) reserve_2 ( IsoTpPciType ) return_value ( MockCanState ) receive ( can_driver_t )","title":"r"},{"location":"docs/class_member_variables/#s","text":"single_frame ( IsoTpCanMessage ) SN ( IsoTpConsecutiveFrame ) STmin ( IsoTpFlowControl ) send_arbitration_id ( IsoTpLink ) send_bs_remain ( IsoTpLink ) send_buf_size ( IsoTpLink ) send_buffer ( IsoTpLink ) send_offset ( IsoTpLink ) send_protocol_result ( IsoTpLink ) send_size ( IsoTpLink ) send_sn ( IsoTpLink ) send_st_min_us ( IsoTpLink ) send_status ( IsoTpLink ) send_timer_bs ( IsoTpLink ) send_timer_st ( IsoTpLink ) send_wtf_count ( IsoTpLink ) SF_DL ( IsoTpSingleFrame ) send ( can_driver_t )","title":"s"},{"location":"docs/class_member_variables/#t","text":"type ( IsoTpConsecutiveFrame , IsoTpFirstFrameShort , IsoTpFlowControl , IsoTpPciType , IsoTpSingleFrame )","title":"t"},{"location":"docs/class_member_typedefs/","text":"Class Member Typedefs \u00b6 Nothing related to Class Member Typedefs found.","title":"Class Member Typedefs"},{"location":"docs/class_member_typedefs/#class-member-typedefs","text":"Nothing related to Class Member Typedefs found.","title":"Class Member Typedefs"},{"location":"docs/class_member_enums/","text":"Class Member Enums \u00b6 Nothing related to Class Member Enums found.","title":"Class Member Enums"},{"location":"docs/class_member_enums/#class-member-enums","text":"Nothing related to Class Member Enums found.","title":"Class Member Enums"},{"location":"docs/namespace_members/","text":"Namespace Members \u00b6 r \u00b6 reset_mock_can_state ( conftest ) t \u00b6 test_api_endpoints_inject_unexpected_cf ( test_api_endpoints ) test_api_endpoints_inject_wrong_sn ( test_api_endpoints ) test_api_endpoints_return_codes ( test_api_endpoints ) test_api_endpoints_smoke ( test_api_endpoints ) test_api_endpoints_smoke_multi_frame ( test_api_endpoints ) test_api_endpoints_validation_errors ( test_api_endpoints ) test_init_rejects_zero_buffers ( test_api_validation ) test_receive_rejects_invalid_bufsize ( test_api_validation ) test_set_fc_params_rejects_large_block_size ( test_api_validation ) test_receive_truncates_payload ( test_buffer_limits ) test_send_in_progress_returns_code ( test_buffer_limits ) test_send_overflow_returns_code ( test_buffer_limits ) test_cantp_stmin_and_bs ( test_cantp ) test_cantp_timeout_n_bs ( test_cantp ) test_cantp_timeout_n_cr ( test_cantp ) test_cantp_unexpected_pdu ( test_cantp ) test_wait_frame_overrun ( test_cantp ) test_wait_frame_then_continue ( test_cantp ) test_flow_control_overflow_sets_protocol_result ( test_flow_control ) test_multi_frame_boundary_sizes ( test_multi_frame ) test_multi_frame_bs_one_stmin ( test_multi_frame ) test_multi_frame_bs_unlimited_stmin ( test_multi_frame ) test_multi_frame_max_payload ( test_multi_frame ) test_multi_frame_roundtrip ( test_multi_frame ) test_multi_frame_timeout_n_bs ( test_multi_frame ) test_multi_frame_timeout_n_cr ( test_multi_frame ) test_multi_frame_unexpected_cf ( test_multi_frame ) test_multi_frame_wrong_sn ( test_multi_frame ) test_block_size_one_roundtrip ( test_timing ) test_st_min_enforced ( test_timing ) test_timeout_n_ar_placeholder ( test_timing ) test_timeout_n_as_placeholder ( test_timing ) test_timeout_n_br_placeholder ( test_timing ) test_timeout_n_bs ( test_timing ) test_timeout_n_cr ( test_timing ) test_timeout_n_cs_placeholder ( test_timing ) _ \u00b6 _cf_frame ( test_api_endpoints , test_multi_frame ) _ff_frame ( test_api_endpoints , test_multi_frame ) _make_payload ( test_api_endpoints , test_buffer_limits , test_cantp , test_flow_control , test_multi_frame ) _poll_until_receive ( test_api_endpoints , test_buffer_limits , test_cantp , test_multi_frame ) _fc_frame ( test_cantp , test_flow_control )","title":"Namespace Members"},{"location":"docs/namespace_members/#namespace-members","text":"","title":"Namespace Members"},{"location":"docs/namespace_members/#r","text":"reset_mock_can_state ( conftest )","title":"r"},{"location":"docs/namespace_members/#t","text":"test_api_endpoints_inject_unexpected_cf ( test_api_endpoints ) test_api_endpoints_inject_wrong_sn ( test_api_endpoints ) test_api_endpoints_return_codes ( test_api_endpoints ) test_api_endpoints_smoke ( test_api_endpoints ) test_api_endpoints_smoke_multi_frame ( test_api_endpoints ) test_api_endpoints_validation_errors ( test_api_endpoints ) test_init_rejects_zero_buffers ( test_api_validation ) test_receive_rejects_invalid_bufsize ( test_api_validation ) test_set_fc_params_rejects_large_block_size ( test_api_validation ) test_receive_truncates_payload ( test_buffer_limits ) test_send_in_progress_returns_code ( test_buffer_limits ) test_send_overflow_returns_code ( test_buffer_limits ) test_cantp_stmin_and_bs ( test_cantp ) test_cantp_timeout_n_bs ( test_cantp ) test_cantp_timeout_n_cr ( test_cantp ) test_cantp_unexpected_pdu ( test_cantp ) test_wait_frame_overrun ( test_cantp ) test_wait_frame_then_continue ( test_cantp ) test_flow_control_overflow_sets_protocol_result ( test_flow_control ) test_multi_frame_boundary_sizes ( test_multi_frame ) test_multi_frame_bs_one_stmin ( test_multi_frame ) test_multi_frame_bs_unlimited_stmin ( test_multi_frame ) test_multi_frame_max_payload ( test_multi_frame ) test_multi_frame_roundtrip ( test_multi_frame ) test_multi_frame_timeout_n_bs ( test_multi_frame ) test_multi_frame_timeout_n_cr ( test_multi_frame ) test_multi_frame_unexpected_cf ( test_multi_frame ) test_multi_frame_wrong_sn ( test_multi_frame ) test_block_size_one_roundtrip ( test_timing ) test_st_min_enforced ( test_timing ) test_timeout_n_ar_placeholder ( test_timing ) test_timeout_n_as_placeholder ( test_timing ) test_timeout_n_br_placeholder ( test_timing ) test_timeout_n_bs ( test_timing ) test_timeout_n_cr ( test_timing ) test_timeout_n_cs_placeholder ( test_timing )","title":"t"},{"location":"docs/namespace_members/#_","text":"_cf_frame ( test_api_endpoints , test_multi_frame ) _ff_frame ( test_api_endpoints , test_multi_frame ) _make_payload ( test_api_endpoints , test_buffer_limits , test_cantp , test_flow_control , test_multi_frame ) _poll_until_receive ( test_api_endpoints , test_buffer_limits , test_cantp , test_multi_frame ) _fc_frame ( test_cantp , test_flow_control )","title":"_"},{"location":"docs/namespace_member_functions/","text":"Namespace Member Functions \u00b6 r \u00b6 reset_mock_can_state ( conftest ) t \u00b6 test_api_endpoints_inject_unexpected_cf ( test_api_endpoints ) test_api_endpoints_inject_wrong_sn ( test_api_endpoints ) test_api_endpoints_return_codes ( test_api_endpoints ) test_api_endpoints_smoke ( test_api_endpoints ) test_api_endpoints_smoke_multi_frame ( test_api_endpoints ) test_api_endpoints_validation_errors ( test_api_endpoints ) test_init_rejects_zero_buffers ( test_api_validation ) test_receive_rejects_invalid_bufsize ( test_api_validation ) test_set_fc_params_rejects_large_block_size ( test_api_validation ) test_receive_truncates_payload ( test_buffer_limits ) test_send_in_progress_returns_code ( test_buffer_limits ) test_send_overflow_returns_code ( test_buffer_limits ) test_cantp_stmin_and_bs ( test_cantp ) test_cantp_timeout_n_bs ( test_cantp ) test_cantp_timeout_n_cr ( test_cantp ) test_cantp_unexpected_pdu ( test_cantp ) test_wait_frame_overrun ( test_cantp ) test_wait_frame_then_continue ( test_cantp ) test_flow_control_overflow_sets_protocol_result ( test_flow_control ) test_multi_frame_boundary_sizes ( test_multi_frame ) test_multi_frame_bs_one_stmin ( test_multi_frame ) test_multi_frame_bs_unlimited_stmin ( test_multi_frame ) test_multi_frame_max_payload ( test_multi_frame ) test_multi_frame_roundtrip ( test_multi_frame ) test_multi_frame_timeout_n_bs ( test_multi_frame ) test_multi_frame_timeout_n_cr ( test_multi_frame ) test_multi_frame_unexpected_cf ( test_multi_frame ) test_multi_frame_wrong_sn ( test_multi_frame ) test_block_size_one_roundtrip ( test_timing ) test_st_min_enforced ( test_timing ) test_timeout_n_ar_placeholder ( test_timing ) test_timeout_n_as_placeholder ( test_timing ) test_timeout_n_br_placeholder ( test_timing ) test_timeout_n_bs ( test_timing ) test_timeout_n_cr ( test_timing ) test_timeout_n_cs_placeholder ( test_timing ) _ \u00b6 _cf_frame ( test_api_endpoints , test_multi_frame ) _ff_frame ( test_api_endpoints , test_multi_frame ) _make_payload ( test_api_endpoints , test_buffer_limits , test_cantp , test_flow_control , test_multi_frame ) _poll_until_receive ( test_api_endpoints , test_buffer_limits , test_cantp , test_multi_frame ) _fc_frame ( test_cantp , test_flow_control )","title":"Namespace Member Functions"},{"location":"docs/namespace_member_functions/#namespace-member-functions","text":"","title":"Namespace Member Functions"},{"location":"docs/namespace_member_functions/#r","text":"reset_mock_can_state ( conftest )","title":"r"},{"location":"docs/namespace_member_functions/#t","text":"test_api_endpoints_inject_unexpected_cf ( test_api_endpoints ) test_api_endpoints_inject_wrong_sn ( test_api_endpoints ) test_api_endpoints_return_codes ( test_api_endpoints ) test_api_endpoints_smoke ( test_api_endpoints ) test_api_endpoints_smoke_multi_frame ( test_api_endpoints ) test_api_endpoints_validation_errors ( test_api_endpoints ) test_init_rejects_zero_buffers ( test_api_validation ) test_receive_rejects_invalid_bufsize ( test_api_validation ) test_set_fc_params_rejects_large_block_size ( test_api_validation ) test_receive_truncates_payload ( test_buffer_limits ) test_send_in_progress_returns_code ( test_buffer_limits ) test_send_overflow_returns_code ( test_buffer_limits ) test_cantp_stmin_and_bs ( test_cantp ) test_cantp_timeout_n_bs ( test_cantp ) test_cantp_timeout_n_cr ( test_cantp ) test_cantp_unexpected_pdu ( test_cantp ) test_wait_frame_overrun ( test_cantp ) test_wait_frame_then_continue ( test_cantp ) test_flow_control_overflow_sets_protocol_result ( test_flow_control ) test_multi_frame_boundary_sizes ( test_multi_frame ) test_multi_frame_bs_one_stmin ( test_multi_frame ) test_multi_frame_bs_unlimited_stmin ( test_multi_frame ) test_multi_frame_max_payload ( test_multi_frame ) test_multi_frame_roundtrip ( test_multi_frame ) test_multi_frame_timeout_n_bs ( test_multi_frame ) test_multi_frame_timeout_n_cr ( test_multi_frame ) test_multi_frame_unexpected_cf ( test_multi_frame ) test_multi_frame_wrong_sn ( test_multi_frame ) test_block_size_one_roundtrip ( test_timing ) test_st_min_enforced ( test_timing ) test_timeout_n_ar_placeholder ( test_timing ) test_timeout_n_as_placeholder ( test_timing ) test_timeout_n_br_placeholder ( test_timing ) test_timeout_n_bs ( test_timing ) test_timeout_n_cr ( test_timing ) test_timeout_n_cs_placeholder ( test_timing )","title":"t"},{"location":"docs/namespace_member_functions/#_","text":"_cf_frame ( test_api_endpoints , test_multi_frame ) _ff_frame ( test_api_endpoints , test_multi_frame ) _make_payload ( test_api_endpoints , test_buffer_limits , test_cantp , test_flow_control , test_multi_frame ) _poll_until_receive ( test_api_endpoints , test_buffer_limits , test_cantp , test_multi_frame ) _fc_frame ( test_cantp , test_flow_control )","title":"_"},{"location":"docs/namespace_member_variables/","text":"Namespace Member Variables \u00b6 Nothing related to Namespace Member Variables found.","title":"Namespace Member Variables"},{"location":"docs/namespace_member_variables/#namespace-member-variables","text":"Nothing related to Namespace Member Variables found.","title":"Namespace Member Variables"},{"location":"docs/namespace_member_typedefs/","text":"Namespace Member Typedefs \u00b6 Nothing related to Namespace Member Typedefs found.","title":"Namespace Member Typedefs"},{"location":"docs/namespace_member_typedefs/#namespace-member-typedefs","text":"Nothing related to Namespace Member Typedefs found.","title":"Namespace Member Typedefs"},{"location":"docs/namespace_member_enums/","text":"Namespace Member Enums \u00b6 Nothing related to Namespace Member Enums found.","title":"Namespace Member Enums"},{"location":"docs/namespace_member_enums/#namespace-member-enums","text":"Nothing related to Namespace Member Enums found.","title":"Namespace Member Enums"},{"location":"docs/functions/","text":"Functions \u00b6 c \u00b6 can_receive ( can_driver.h , can_driver.c ) can_send ( can_driver.h , can_driver.c ) can_set_driver ( can_driver.h , can_driver.c ) i \u00b6 ISOTP_PACKED_STRUCT ( isotp_defines.h ) isotp_receive_consecutive_frame ( isotp.c ) isotp_receive_first_frame ( isotp.c ) isotp_receive_flow_control_frame ( isotp.c ) isotp_receive_single_frame ( isotp.c ) isotp_send_consecutive_frame ( isotp.c ) isotp_send_first_frame ( isotp.c ) isotp_send_flow_control ( isotp.c ) isotp_send_single_frame ( isotp.c ) isotp_st_min_to_us ( isotp.c ) isotp_us_to_st_min ( isotp.c ) m \u00b6 main ( linux_socket.c ) mock_can_disable_fc ( mock_can.h , mock_can.c ) mock_can_enable_drop ( mock_can.h , mock_can.c ) mock_can_init ( mock_can.h , mock_can.c ) mock_can_set_delay_ms ( mock_can.h , mock_can.c ) mock_time_advance ( mock_time.h , mock_time.c ) mock_time_now ( mock_time.h , mock_time.c ) mock_time_reset ( mock_time.h , mock_time.c ) mock_time_set ( mock_time.h , mock_time.c ) mock_receive ( mock_can.c ) mock_send ( mock_can.c ) p \u00b6 PyInit_pyisotp ( pyisotp.c ) py_get_last_protocol_result ( pyisotp.c ) py_get_last_receive_protocol_result ( pyisotp.c ) py_inject_can ( pyisotp.c ) py_mock_disable_fc ( pyisotp.c ) py_mock_enable_drop ( pyisotp.c ) py_set_fc_params ( pyisotp.c ) py_set_timeouts ( pyisotp.c ) py_time_advance ( pyisotp.c ) py_time_reset ( pyisotp.c ) py_time_set ( pyisotp.c ) pyisotp_capsule_destructor ( pyisotp.c ) pyisotp_init ( pyisotp.c ) pyisotp_poll ( pyisotp.c ) pyisotp_receive ( pyisotp.c ) pyisotp_send ( pyisotp.c ) r \u00b6 reset_mocks ( isotp_test_mocks.cpp , isotp_test_support.h ) s \u00b6 sleep_ms ( mock_can.c ) t \u00b6 TEST ( gtest_isotp_destroy_link.cpp , gtest_isotp_init_link.cpp , gtest_isotp_on_can_message.cpp , gtest_isotp_poll.cpp , gtest_isotp_receive.cpp , gtest_isotp_send.cpp , gtest_isotp_send_with_id.cpp )","title":"Functions"},{"location":"docs/functions/#functions","text":"","title":"Functions"},{"location":"docs/functions/#c","text":"can_receive ( can_driver.h , can_driver.c ) can_send ( can_driver.h , can_driver.c ) can_set_driver ( can_driver.h , can_driver.c )","title":"c"},{"location":"docs/functions/#i","text":"ISOTP_PACKED_STRUCT ( isotp_defines.h ) isotp_receive_consecutive_frame ( isotp.c ) isotp_receive_first_frame ( isotp.c ) isotp_receive_flow_control_frame ( isotp.c ) isotp_receive_single_frame ( isotp.c ) isotp_send_consecutive_frame ( isotp.c ) isotp_send_first_frame ( isotp.c ) isotp_send_flow_control ( isotp.c ) isotp_send_single_frame ( isotp.c ) isotp_st_min_to_us ( isotp.c ) isotp_us_to_st_min ( isotp.c )","title":"i"},{"location":"docs/functions/#m","text":"main ( linux_socket.c ) mock_can_disable_fc ( mock_can.h , mock_can.c ) mock_can_enable_drop ( mock_can.h , mock_can.c ) mock_can_init ( mock_can.h , mock_can.c ) mock_can_set_delay_ms ( mock_can.h , mock_can.c ) mock_time_advance ( mock_time.h , mock_time.c ) mock_time_now ( mock_time.h , mock_time.c ) mock_time_reset ( mock_time.h , mock_time.c ) mock_time_set ( mock_time.h , mock_time.c ) mock_receive ( mock_can.c ) mock_send ( mock_can.c )","title":"m"},{"location":"docs/functions/#p","text":"PyInit_pyisotp ( pyisotp.c ) py_get_last_protocol_result ( pyisotp.c ) py_get_last_receive_protocol_result ( pyisotp.c ) py_inject_can ( pyisotp.c ) py_mock_disable_fc ( pyisotp.c ) py_mock_enable_drop ( pyisotp.c ) py_set_fc_params ( pyisotp.c ) py_set_timeouts ( pyisotp.c ) py_time_advance ( pyisotp.c ) py_time_reset ( pyisotp.c ) py_time_set ( pyisotp.c ) pyisotp_capsule_destructor ( pyisotp.c ) pyisotp_init ( pyisotp.c ) pyisotp_poll ( pyisotp.c ) pyisotp_receive ( pyisotp.c ) pyisotp_send ( pyisotp.c )","title":"p"},{"location":"docs/functions/#r","text":"reset_mocks ( isotp_test_mocks.cpp , isotp_test_support.h )","title":"r"},{"location":"docs/functions/#s","text":"sleep_ms ( mock_can.c )","title":"s"},{"location":"docs/functions/#t","text":"TEST ( gtest_isotp_destroy_link.cpp , gtest_isotp_init_link.cpp , gtest_isotp_on_can_message.cpp , gtest_isotp_poll.cpp , gtest_isotp_receive.cpp , gtest_isotp_send.cpp , gtest_isotp_send_with_id.cpp )","title":"t"},{"location":"docs/macros/","text":"Macros \u00b6 c \u00b6 CAN_MAX_DLEN ( mock_can.c ) i \u00b6 ISO_TP_DEFAULT_BLOCK_SIZE ( isotp_config.h ) ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ( isotp_config.h ) ISO_TP_DEFAULT_ST_MIN_US ( isotp_config.h ) ISO_TP_FRAME_PADDING_VALUE ( isotp_config.h ) ISO_TP_MAX_WFT_NUMBER ( isotp_config.h ) ISOTP_INVALID_BS ( isotp_defines.h ) ISOTP_MAX_ERROR_MSG_SIZE ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_ERROR ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_INVALID_FS ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_OK ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_TIMEOUT_A ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_TIMEOUT_BS ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_TIMEOUT_CR ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_UNEXP_PDU ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_WFT_OVRN ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_WRONG_SN ( isotp_defines.h ) ISOTP_RET_ERROR ( isotp_defines.h ) ISOTP_RET_INPROGRESS ( isotp_defines.h ) ISOTP_RET_LENGTH ( isotp_defines.h ) ISOTP_RET_NOSPACE ( isotp_defines.h ) ISOTP_RET_NO_DATA ( isotp_defines.h ) ISOTP_RET_OK ( isotp_defines.h ) ISOTP_RET_OVERFLOW ( isotp_defines.h ) ISOTP_RET_TIMEOUT ( isotp_defines.h ) ISOTP_RET_WRONG_SN ( isotp_defines.h ) IsoTpTimeAfter ( isotp_defines.h ) l \u00b6 LE32TOH ( isotp_defines.h ) m \u00b6 MOCK_QUEUE_SIZE ( mock_can.c ) p \u00b6 PY_SSIZE_T_CLEAN ( pyisotp.c ) s \u00b6 SEC_TO_US ( linux_socket.c ) _ \u00b6 _CAN_INTERFACE ( linux_socket.c ) _ISOTP_BUFSIZE ( linux_socket.c ) _ISOTP_CAN_ID ( linux_socket.c )","title":"Macros"},{"location":"docs/macros/#macros","text":"","title":"Macros"},{"location":"docs/macros/#c","text":"CAN_MAX_DLEN ( mock_can.c )","title":"c"},{"location":"docs/macros/#i","text":"ISO_TP_DEFAULT_BLOCK_SIZE ( isotp_config.h ) ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US ( isotp_config.h ) ISO_TP_DEFAULT_ST_MIN_US ( isotp_config.h ) ISO_TP_FRAME_PADDING_VALUE ( isotp_config.h ) ISO_TP_MAX_WFT_NUMBER ( isotp_config.h ) ISOTP_INVALID_BS ( isotp_defines.h ) ISOTP_MAX_ERROR_MSG_SIZE ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_ERROR ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_INVALID_FS ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_OK ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_TIMEOUT_A ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_TIMEOUT_BS ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_TIMEOUT_CR ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_UNEXP_PDU ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_WFT_OVRN ( isotp_defines.h ) ISOTP_PROTOCOL_RESULT_WRONG_SN ( isotp_defines.h ) ISOTP_RET_ERROR ( isotp_defines.h ) ISOTP_RET_INPROGRESS ( isotp_defines.h ) ISOTP_RET_LENGTH ( isotp_defines.h ) ISOTP_RET_NOSPACE ( isotp_defines.h ) ISOTP_RET_NO_DATA ( isotp_defines.h ) ISOTP_RET_OK ( isotp_defines.h ) ISOTP_RET_OVERFLOW ( isotp_defines.h ) ISOTP_RET_TIMEOUT ( isotp_defines.h ) ISOTP_RET_WRONG_SN ( isotp_defines.h ) IsoTpTimeAfter ( isotp_defines.h )","title":"i"},{"location":"docs/macros/#l","text":"LE32TOH ( isotp_defines.h )","title":"l"},{"location":"docs/macros/#m","text":"MOCK_QUEUE_SIZE ( mock_can.c )","title":"m"},{"location":"docs/macros/#p","text":"PY_SSIZE_T_CLEAN ( pyisotp.c )","title":"p"},{"location":"docs/macros/#s","text":"SEC_TO_US ( linux_socket.c )","title":"s"},{"location":"docs/macros/#_","text":"_CAN_INTERFACE ( linux_socket.c ) _ISOTP_BUFSIZE ( linux_socket.c ) _ISOTP_CAN_ID ( linux_socket.c )","title":"_"},{"location":"docs/variables/","text":"Variables \u00b6 a \u00b6 active_driver ( can_driver.c ) d \u00b6 delay_ms ( mock_can.c ) disable_fc ( mock_can.c ) drop_enabled ( mock_can.c ) g \u00b6 g_isotpRecvBuf ( linux_socket.c ) g_isotpSendBuf ( linux_socket.c ) g_link ( linux_socket.c ) g_can_state ( isotp_test_mocks.cpp , isotp_test_support.h ) g_debug_call_count ( isotp_test_mocks.cpp , isotp_test_support.h ) g_now_us ( isotp_test_mocks.cpp , isotp_test_support.h ) h \u00b6 head ( mock_can.c ) i \u00b6 IsoTpFlowStatus ( isotp_defines.h ) IsoTpProtocolControlInformation ( isotp_defines.h ) IsoTpReceiveStatusTypes ( isotp_defines.h ) IsoTpSendStatusTypes ( isotp_defines.h ) p \u00b6 PyIsoTpMethods ( pyisotp.c ) pyisotp_module ( pyisotp.c ) q \u00b6 queue ( mock_can.c ) t \u00b6 tail ( mock_can.c ) v \u00b6 virtual_time ( mock_time.c ) _ \u00b6 _socket ( linux_socket.c )","title":"Variables"},{"location":"docs/variables/#variables","text":"","title":"Variables"},{"location":"docs/variables/#a","text":"active_driver ( can_driver.c )","title":"a"},{"location":"docs/variables/#d","text":"delay_ms ( mock_can.c ) disable_fc ( mock_can.c ) drop_enabled ( mock_can.c )","title":"d"},{"location":"docs/variables/#g","text":"g_isotpRecvBuf ( linux_socket.c ) g_isotpSendBuf ( linux_socket.c ) g_link ( linux_socket.c ) g_can_state ( isotp_test_mocks.cpp , isotp_test_support.h ) g_debug_call_count ( isotp_test_mocks.cpp , isotp_test_support.h ) g_now_us ( isotp_test_mocks.cpp , isotp_test_support.h )","title":"g"},{"location":"docs/variables/#h","text":"head ( mock_can.c )","title":"h"},{"location":"docs/variables/#i","text":"IsoTpFlowStatus ( isotp_defines.h ) IsoTpProtocolControlInformation ( isotp_defines.h ) IsoTpReceiveStatusTypes ( isotp_defines.h ) IsoTpSendStatusTypes ( isotp_defines.h )","title":"i"},{"location":"docs/variables/#p","text":"PyIsoTpMethods ( pyisotp.c ) pyisotp_module ( pyisotp.c )","title":"p"},{"location":"docs/variables/#q","text":"queue ( mock_can.c )","title":"q"},{"location":"docs/variables/#t","text":"tail ( mock_can.c )","title":"t"},{"location":"docs/variables/#v","text":"virtual_time ( mock_time.c )","title":"v"},{"location":"docs/variables/#_","text":"_socket ( linux_socket.c )","title":"_"},{"location":"docs/links/","text":"Related Pages Modules Class List Namespace ListNamespace List Namespace Members Namespace Member Functions Namespace Member Variables Namespace Member Typedefs Namespace Member Enumerations Class Index Class Hierarchy Class Members Class Member Functions Class Member Variables Class Member Typedefs Class Member Enumerations Files File Variables File Functions File Macros","title":"Links"}]}