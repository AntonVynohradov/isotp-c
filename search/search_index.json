{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ISO-TP C Implementation","text":"<p>ISO-TP (ISO 15765-2) protocol implementation in C.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Full ISO-TP protocol support</li> <li>Configurable parameters</li> <li>Minimal dependencies</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#building","title":"Building","text":"<pre><code>cmake -B build\ncmake --build build\n</code></pre>"},{"location":"#integration","title":"Integration","text":"<p>Include the header file: <pre><code>#include \"isotp.h\"\n</code></pre></p>"},{"location":"#documentation","title":"Documentation","text":"<p>For detailed API documentation, see API Reference</p>"},{"location":"#license","title":"License","text":"<p>See LICENSE file for details.</p>"},{"location":"LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2019-2024 Li Shen &amp; Co-Operators Copyright (c) 2024 Simon Cahill &amp; Contributors.</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"api/","title":"API Reference","text":"<p>The API reference is automatically generated from the source code using Doxygen.</p>"},{"location":"api/#main-components","title":"Main Components","text":"<ul> <li>isotp.h - Main protocol header</li> <li>isotp_config.h - Configuration options</li> <li>isotp_user.h - User callback definitions</li> <li>isotp_defines.h - Protocol definitions</li> </ul>"},{"location":"api/#functions","title":"Functions","text":"<p>Detailed function documentation is available in the generated API documentation.</p>"},{"location":"api/#data-structures","title":"Data Structures","text":"<p>Core data structures for ISO-TP protocol handling are documented in the API reference.</p> <p>For more information, please refer to the ISO 15765-2 standard.</p>"},{"location":"configuration/","title":"Configuration Guide","text":""},{"location":"configuration/#isotp_configh","title":"isotp_config.h","text":"<p>The <code>isotp_config.h</code> file contains compile-time configuration options.</p>"},{"location":"configuration/#key-configuration-options","title":"Key Configuration Options","text":"<ul> <li><code>ISOTP_MAX_MESSAGE_LENGTH</code> - Maximum message length</li> <li><code>ISOTP_TIMEOUT</code> - Communication timeout</li> <li><code>ISOTP_PADDING_ENABLED</code> - Enable/disable frame padding</li> </ul>"},{"location":"configuration/#user-callbacks","title":"User Callbacks","text":"<p>Configure user-defined callbacks in <code>isotp_user.h</code> for: - Frame transmission - Frame reception - Timing management</p>"},{"location":"configuration/#more-information","title":"More Information","text":"<p>See <code>Inc/isotp_config.h</code> for detailed configuration parameters.</p>"},{"location":"guide/","title":"Usage Guide","text":""},{"location":"guide/#initialization","title":"Initialization","text":"<p>Initialize the ISO-TP protocol handler:</p> <pre><code>isotp_t handler;\n// Initialize with appropriate parameters\n</code></pre>"},{"location":"guide/#sending-data","title":"Sending Data","text":"<p>Transmit ISO-TP messages:</p> <pre><code>uint8_t data[] = {/* your data */};\n// Use isotp send functions\n</code></pre>"},{"location":"guide/#receiving-data","title":"Receiving Data","text":"<p>Handle incoming ISO-TP frames:</p> <pre><code>// Use isotp receive functions\n</code></pre>"},{"location":"guide/#configuration","title":"Configuration","text":"<p>See Configuration Guide for detailed configuration options.</p>"},{"location":"guide/#error-handling","title":"Error Handling","text":"<p>The library provides error codes for various conditions: - Timeout errors - Protocol errors - Frame validation errors</p> <p>For details, refer to the API Reference.</p>"},{"location":"docs/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>struct IsoTpCanMessage </li> <li>struct IsoTpConsecutiveFrame </li> <li>struct IsoTpDataArray </li> <li>struct IsoTpFirstFrameShort </li> <li>struct IsoTpFlowControl </li> <li>struct IsoTpPciType </li> <li>struct IsoTpSingleFrame </li> </ul>"},{"location":"docs/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir Inc <ul> <li>file isotp_config.h </li> <li>file isotp_defines.h </li> <li>file isotp_user.h </li> </ul> </li> <li>dir Src <ul> <li>file isotp.c </li> </ul> </li> </ul>"},{"location":"docs/structIsoTpCanMessage/","title":"Struct IsoTpCanMessage","text":"<p>ClassList &gt; IsoTpCanMessage</p>"},{"location":"docs/structIsoTpCanMessage/#public-attributes","title":"Public Attributes","text":"Type Name union IsoTpCanMessage as IsoTpPciType common IsoTpConsecutiveFrame consecutive_frame IsoTpDataArray data_array IsoTpFirstFrameLong first_frame_long IsoTpFirstFrameShort first_frame_short IsoTpFlowControl flow_control IsoTpSingleFrame single_frame"},{"location":"docs/structIsoTpCanMessage/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"docs/structIsoTpCanMessage/#variable-as","title":"variable as","text":"<pre><code>union IsoTpCanMessage IsoTpCanMessage::as;\n</code></pre>"},{"location":"docs/structIsoTpCanMessage/#variable-common","title":"variable common","text":"<pre><code>IsoTpPciType IsoTpCanMessage::common;\n</code></pre>"},{"location":"docs/structIsoTpCanMessage/#variable-consecutive_frame","title":"variable consecutive_frame","text":"<pre><code>IsoTpConsecutiveFrame IsoTpCanMessage::consecutive_frame;\n</code></pre>"},{"location":"docs/structIsoTpCanMessage/#variable-data_array","title":"variable data_array","text":"<pre><code>IsoTpDataArray IsoTpCanMessage::data_array;\n</code></pre>"},{"location":"docs/structIsoTpCanMessage/#variable-first_frame_long","title":"variable first_frame_long","text":"<pre><code>IsoTpFirstFrameLong IsoTpCanMessage::first_frame_long;\n</code></pre>"},{"location":"docs/structIsoTpCanMessage/#variable-first_frame_short","title":"variable first_frame_short","text":"<pre><code>IsoTpFirstFrameShort IsoTpCanMessage::first_frame_short;\n</code></pre>"},{"location":"docs/structIsoTpCanMessage/#variable-flow_control","title":"variable flow_control","text":"<pre><code>IsoTpFlowControl IsoTpCanMessage::flow_control;\n</code></pre>"},{"location":"docs/structIsoTpCanMessage/#variable-single_frame","title":"variable single_frame","text":"<pre><code>IsoTpSingleFrame IsoTpCanMessage::single_frame;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Inc/isotp_defines.h</code></p>"},{"location":"docs/structIsoTpConsecutiveFrame/","title":"Struct IsoTpConsecutiveFrame","text":"<p>ClassList &gt; IsoTpConsecutiveFrame</p>"},{"location":"docs/structIsoTpConsecutiveFrame/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t SN uint8_t data uint8_t type"},{"location":"docs/structIsoTpConsecutiveFrame/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"docs/structIsoTpConsecutiveFrame/#variable-sn","title":"variable SN","text":"<pre><code>uint8_t IsoTpConsecutiveFrame::SN;\n</code></pre>"},{"location":"docs/structIsoTpConsecutiveFrame/#variable-data","title":"variable data","text":"<pre><code>uint8_t IsoTpConsecutiveFrame::data[7];\n</code></pre>"},{"location":"docs/structIsoTpConsecutiveFrame/#variable-type","title":"variable type","text":"<pre><code>uint8_t IsoTpConsecutiveFrame::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Inc/isotp_defines.h</code></p>"},{"location":"docs/structIsoTpDataArray/","title":"Struct IsoTpDataArray","text":"<p>ClassList &gt; IsoTpDataArray</p>"},{"location":"docs/structIsoTpDataArray/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t ptr"},{"location":"docs/structIsoTpDataArray/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"docs/structIsoTpDataArray/#variable-ptr","title":"variable ptr","text":"<pre><code>uint8_t IsoTpDataArray::ptr[8];\n</code></pre> <p>The documentation for this class was generated from the following file <code>Inc/isotp_defines.h</code></p>"},{"location":"docs/structIsoTpFirstFrameShort/","title":"Struct IsoTpFirstFrameShort","text":"<p>ClassList &gt; IsoTpFirstFrameShort</p>"},{"location":"docs/structIsoTpFirstFrameShort/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t FF_DL_high uint8_t FF_DL_low uint8_t data uint8_t type"},{"location":"docs/structIsoTpFirstFrameShort/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"docs/structIsoTpFirstFrameShort/#variable-ff_dl_high","title":"variable FF_DL_high","text":"<pre><code>uint8_t IsoTpFirstFrameShort::FF_DL_high;\n</code></pre>"},{"location":"docs/structIsoTpFirstFrameShort/#variable-ff_dl_low","title":"variable FF_DL_low","text":"<pre><code>uint8_t IsoTpFirstFrameShort::FF_DL_low;\n</code></pre>"},{"location":"docs/structIsoTpFirstFrameShort/#variable-data","title":"variable data","text":"<pre><code>uint8_t IsoTpFirstFrameShort::data[6];\n</code></pre>"},{"location":"docs/structIsoTpFirstFrameShort/#variable-type","title":"variable type","text":"<pre><code>uint8_t IsoTpFirstFrameShort::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Inc/isotp_defines.h</code></p>"},{"location":"docs/structIsoTpFlowControl/","title":"Struct IsoTpFlowControl","text":"<p>ClassList &gt; IsoTpFlowControl</p>"},{"location":"docs/structIsoTpFlowControl/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t BS uint8_t FS uint8_t STmin uint8_t reserve uint8_t type"},{"location":"docs/structIsoTpFlowControl/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"docs/structIsoTpFlowControl/#variable-bs","title":"variable BS","text":"<pre><code>uint8_t IsoTpFlowControl::BS;\n</code></pre>"},{"location":"docs/structIsoTpFlowControl/#variable-fs","title":"variable FS","text":"<pre><code>uint8_t IsoTpFlowControl::FS;\n</code></pre>"},{"location":"docs/structIsoTpFlowControl/#variable-stmin","title":"variable STmin","text":"<pre><code>uint8_t IsoTpFlowControl::STmin;\n</code></pre>"},{"location":"docs/structIsoTpFlowControl/#variable-reserve","title":"variable reserve","text":"<pre><code>uint8_t IsoTpFlowControl::reserve[5];\n</code></pre>"},{"location":"docs/structIsoTpFlowControl/#variable-type","title":"variable type","text":"<pre><code>uint8_t IsoTpFlowControl::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Inc/isotp_defines.h</code></p>"},{"location":"docs/structIsoTpPciType/","title":"Struct IsoTpPciType","text":"<p>ClassList &gt; IsoTpPciType</p>"},{"location":"docs/structIsoTpPciType/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t reserve_1 uint8_t reserve_2 uint8_t type"},{"location":"docs/structIsoTpPciType/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"docs/structIsoTpPciType/#variable-reserve_1","title":"variable reserve_1","text":"<pre><code>uint8_t IsoTpPciType::reserve_1;\n</code></pre>"},{"location":"docs/structIsoTpPciType/#variable-reserve_2","title":"variable reserve_2","text":"<pre><code>uint8_t IsoTpPciType::reserve_2[7];\n</code></pre>"},{"location":"docs/structIsoTpPciType/#variable-type","title":"variable type","text":"<pre><code>uint8_t IsoTpPciType::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Inc/isotp_defines.h</code></p>"},{"location":"docs/structIsoTpSingleFrame/","title":"Struct IsoTpSingleFrame","text":"<p>ClassList &gt; IsoTpSingleFrame</p>"},{"location":"docs/structIsoTpSingleFrame/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t SF_DL uint8_t data uint8_t type"},{"location":"docs/structIsoTpSingleFrame/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"docs/structIsoTpSingleFrame/#variable-sf_dl","title":"variable SF_DL","text":"<pre><code>uint8_t IsoTpSingleFrame::SF_DL;\n</code></pre>"},{"location":"docs/structIsoTpSingleFrame/#variable-data","title":"variable data","text":"<pre><code>uint8_t IsoTpSingleFrame::data[7];\n</code></pre>"},{"location":"docs/structIsoTpSingleFrame/#variable-type","title":"variable type","text":"<pre><code>uint8_t IsoTpSingleFrame::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Inc/isotp_defines.h</code></p>"},{"location":"docs/dir_f93dfce691d792349f1c14ede440e2e6/","title":"Dir Inc","text":"<p>FileList &gt; Inc</p>"},{"location":"docs/dir_f93dfce691d792349f1c14ede440e2e6/#files","title":"Files","text":"Type Name file isotp_config.h file isotp_defines.h file isotp_user.h <p>The documentation for this class was generated from the following file <code>Inc/</code></p>"},{"location":"docs/isotp__config_8h/","title":"File isotp_config.h","text":"<p>FileList &gt; Inc &gt; isotp_config.h</p> <p>Go to the source code of this file</p>"},{"location":"docs/isotp__config_8h/#macros","title":"Macros","text":"Type Name define ISO_TP_DEFAULT_BLOCK_SIZE <code>8</code> define ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US <code>100000</code> define ISO_TP_DEFAULT_ST_MIN_US <code>0</code> define ISO_TP_FRAME_PADDING_VALUE <code>0xAA</code> define ISO_TP_MAX_WFT_NUMBER <code>1</code>"},{"location":"docs/isotp__config_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"docs/isotp__config_8h/#define-iso_tp_default_block_size","title":"define ISO_TP_DEFAULT_BLOCK_SIZE","text":"<pre><code>#define ISO_TP_DEFAULT_BLOCK_SIZE `8`\n</code></pre>"},{"location":"docs/isotp__config_8h/#define-iso_tp_default_response_timeout_us","title":"define ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US","text":"<pre><code>#define ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US `100000`\n</code></pre>"},{"location":"docs/isotp__config_8h/#define-iso_tp_default_st_min_us","title":"define ISO_TP_DEFAULT_ST_MIN_US","text":"<pre><code>#define ISO_TP_DEFAULT_ST_MIN_US `0`\n</code></pre>"},{"location":"docs/isotp__config_8h/#define-iso_tp_frame_padding_value","title":"define ISO_TP_FRAME_PADDING_VALUE","text":"<pre><code>#define ISO_TP_FRAME_PADDING_VALUE `0xAA`\n</code></pre>"},{"location":"docs/isotp__config_8h/#define-iso_tp_max_wft_number","title":"define ISO_TP_MAX_WFT_NUMBER","text":"<pre><code>#define ISO_TP_MAX_WFT_NUMBER `1`\n</code></pre> <p>The documentation for this class was generated from the following file <code>Inc/isotp_config.h</code></p>"},{"location":"docs/isotp__config_8h_source/","title":"File isotp_config.h","text":"<p>File List &gt; Inc &gt; isotp_config.h</p> <p>Go to the documentation of this file</p> <pre><code>/*******************************************************************************\n * ISO-TP-C: ISO 15765-2 Protocol Implementation\n *\n * Project:     ISO-TP-C - Embedded-Grade Refactoring &amp; Optimization\n * Description: ISO-TP configuration parameters and feature toggles\n *\n * Author:      Anton Vynohradov\n * Email:       avynohradovair@gmail.com\n *\n * License:     MIT License\n *\n * Copyright (c) 2026 Anton Vynohradov\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * SPDX-License-Identifier: MIT\n ******************************************************************************/\n\n#ifndef ISOTPC_CONFIG_H\n#define ISOTPC_CONFIG_H\n\n/* ==============================================================================\n * INCLUDES\n * =============================================================================*/\n\n/* ==============================================================================\n * DEFINES &amp; MACROS\n * =============================================================================*/\n\n/* Max number of messages the receiver can receive at one time, this value\n * is affected by can driver queue length\n */\n#ifndef ISO_TP_DEFAULT_BLOCK_SIZE\n#define ISO_TP_DEFAULT_BLOCK_SIZE 8\n#endif\n\n/* The STmin parameter value specifies the minimum time gap allowed between\n * the transmission of consecutive frame network protocol data units\n */\n#ifndef ISO_TP_DEFAULT_ST_MIN_US\n#define ISO_TP_DEFAULT_ST_MIN_US 0\n#endif\n\n/* This parameter indicate how many FC N_PDU WTs can be transmitted by the\n * receiver in a row.\n */\n#ifndef ISO_TP_MAX_WFT_NUMBER\n#define ISO_TP_MAX_WFT_NUMBER 1\n#endif\n\n/* Private: The default timeout to use when waiting for a response during a\n * multi-frame send or receive.\n */\n#ifndef ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US\n#define ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US 100000\n#endif\n\n/* Private: Determines if by default, padding is added to ISO-TP message frames.\n */\n/* #define ISO_TP_FRAME_PADDING */\n\n/* Private: Value to use when padding frames if enabled by ISO_TP_FRAME_PADDING\n */\n#ifndef ISO_TP_FRAME_PADDING_VALUE\n#define ISO_TP_FRAME_PADDING_VALUE 0xAA\n#endif\n\n/* Private: Determines if by default, an additional argument is present in the\n * definition of isotp_user_send_can.\n */\n/* #define ISO_TP_USER_SEND_CAN_ARG */\n\n/* Enable support for transmission complete callback */\n/* #define ISO_TP_TRANSMIT_COMPLETE_CALLBACK */\n\n/* Enable support for receive complete callback */\n/* #define ISO_TP_RECEIVE_COMPLETE_CALLBACK */\n\n/* ==============================================================================\n * TYPE DEFINITIONS\n * =============================================================================*/\n\n/* ==============================================================================\n * GLOBAL VARIABLES (extern declarations)\n * =============================================================================*/\n\n/* ==============================================================================\n * PUBLIC FUNCTION DECLARATIONS\n * =============================================================================*/\n\n#endif /* ISOTPC_CONFIG_H */\n</code></pre>"},{"location":"docs/isotp__defines_8h/","title":"File isotp_defines.h","text":"<p>FileList &gt; Inc &gt; isotp_defines.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"docs/isotp__defines_8h/#classes","title":"Classes","text":"Type Name struct IsoTpCanMessage struct IsoTpConsecutiveFrame struct IsoTpDataArray struct IsoTpFirstFrameShort struct IsoTpFlowControl struct IsoTpPciType struct IsoTpSingleFrame"},{"location":"docs/isotp__defines_8h/#public-types","title":"Public Types","text":"Type Name enum IsoTpFlowStatus enum IsoTpProtocolControlInformation enum IsoTpReceiveStatusTypes enum IsoTpSendStatusTypes"},{"location":"docs/isotp__defines_8h/#public-functions","title":"Public Functions","text":"Type Name ISOTP_PACKED_STRUCT ({ uint8_t set_to_zero_high :4;uint8_t type :4;uint8_t set_to_zero_low;uint32_t FF_DL;uint8_t data[2];} IsoTpFirstFrameLong)"},{"location":"docs/isotp__defines_8h/#macros","title":"Macros","text":"Type Name define ISOTP_INVALID_BS <code>0xFFFF</code> define ISOTP_MAX_ERROR_MSG_SIZE <code>128</code> define ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW <code>-8</code> define ISOTP_PROTOCOL_RESULT_ERROR <code>-9</code> define ISOTP_PROTOCOL_RESULT_INVALID_FS <code>-5</code> define ISOTP_PROTOCOL_RESULT_OK <code>0</code> define ISOTP_PROTOCOL_RESULT_TIMEOUT_A <code>-1</code> define ISOTP_PROTOCOL_RESULT_TIMEOUT_BS <code>-2</code> define ISOTP_PROTOCOL_RESULT_TIMEOUT_CR <code>-3</code> define ISOTP_PROTOCOL_RESULT_UNEXP_PDU <code>-6</code> define ISOTP_PROTOCOL_RESULT_WFT_OVRN <code>-7</code> define ISOTP_PROTOCOL_RESULT_WRONG_SN <code>-4</code> define ISOTP_RET_ERROR <code>-1</code> define ISOTP_RET_INPROGRESS <code>-2</code> define ISOTP_RET_LENGTH <code>-7</code> define ISOTP_RET_NOSPACE <code>-8</code> define ISOTP_RET_NO_DATA <code>-5</code> define ISOTP_RET_OK <code>0</code> define ISOTP_RET_OVERFLOW <code>-3</code> define ISOTP_RET_TIMEOUT <code>-6</code> define ISOTP_RET_WRONG_SN <code>-4</code> define IsoTpTimeAfter (a, b) <code>((int32\\_t) ((int32\\_t) (b) - (int32\\_t) (a)) &amp;lt; 0)</code> define LE32TOH (le) <code>/* multi line expression */</code>"},{"location":"docs/isotp__defines_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"docs/isotp__defines_8h/#enum-isotpflowstatus","title":"enum IsoTpFlowStatus","text":"<pre><code>enum IsoTpFlowStatus {\n    PCI_FLOW_STATUS_CONTINUE = 0x0,\n    PCI_FLOW_STATUS_WAIT = 0x1,\n    PCI_FLOW_STATUS_OVERFLOW = 0x2\n};\n</code></pre>"},{"location":"docs/isotp__defines_8h/#enum-isotpprotocolcontrolinformation","title":"enum IsoTpProtocolControlInformation","text":"<pre><code>enum IsoTpProtocolControlInformation {\n    ISOTP_PCI_TYPE_SINGLE = 0x0,\n    ISOTP_PCI_TYPE_FIRST_FRAME = 0x1,\n    TSOTP_PCI_TYPE_CONSECUTIVE_FRAME = 0x2,\n    ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME = 0x3,\n    ISOTP_PCI_TYPE_CONSECUTIVE_FRAME =\n        0x2\n};\n</code></pre>"},{"location":"docs/isotp__defines_8h/#enum-isotpreceivestatustypes","title":"enum IsoTpReceiveStatusTypes","text":"<pre><code>enum IsoTpReceiveStatusTypes {\n    ISOTP_RECEIVE_STATUS_IDLE,\n    ISOTP_RECEIVE_STATUS_INPROGRESS,\n    ISOTP_RECEIVE_STATUS_FULL\n};\n</code></pre>"},{"location":"docs/isotp__defines_8h/#enum-isotpsendstatustypes","title":"enum IsoTpSendStatusTypes","text":"<pre><code>enum IsoTpSendStatusTypes {\n    ISOTP_SEND_STATUS_IDLE,\n    ISOTP_SEND_STATUS_INPROGRESS,\n    ISOTP_SEND_STATUS_ERROR\n};\n</code></pre>"},{"location":"docs/isotp__defines_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"docs/isotp__defines_8h/#function-isotp_packed_struct","title":"function ISOTP_PACKED_STRUCT","text":"<pre><code>ISOTP_PACKED_STRUCT (\n    { uint8_t set_to_zero_high :4;uint8_t type :4;uint8_t set_to_zero_low;uint32_t FF_DL;uint8_t data[2];} IsoTpFirstFrameLong\n) \n</code></pre>"},{"location":"docs/isotp__defines_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"docs/isotp__defines_8h/#define-isotp_invalid_bs","title":"define ISOTP_INVALID_BS","text":"<pre><code>#define ISOTP_INVALID_BS `0xFFFF`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-isotp_max_error_msg_size","title":"define ISOTP_MAX_ERROR_MSG_SIZE","text":"<pre><code>#define ISOTP_MAX_ERROR_MSG_SIZE `128`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_buffer_ovflw","title":"define ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW","text":"<pre><code>#define ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW `-8`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_error","title":"define ISOTP_PROTOCOL_RESULT_ERROR","text":"<pre><code>#define ISOTP_PROTOCOL_RESULT_ERROR `-9`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_invalid_fs","title":"define ISOTP_PROTOCOL_RESULT_INVALID_FS","text":"<pre><code>#define ISOTP_PROTOCOL_RESULT_INVALID_FS `-5`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_ok","title":"define ISOTP_PROTOCOL_RESULT_OK","text":"<pre><code>#define ISOTP_PROTOCOL_RESULT_OK `0`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_timeout_a","title":"define ISOTP_PROTOCOL_RESULT_TIMEOUT_A","text":"<pre><code>#define ISOTP_PROTOCOL_RESULT_TIMEOUT_A `-1`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_timeout_bs","title":"define ISOTP_PROTOCOL_RESULT_TIMEOUT_BS","text":"<pre><code>#define ISOTP_PROTOCOL_RESULT_TIMEOUT_BS `-2`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_timeout_cr","title":"define ISOTP_PROTOCOL_RESULT_TIMEOUT_CR","text":"<pre><code>#define ISOTP_PROTOCOL_RESULT_TIMEOUT_CR `-3`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_unexp_pdu","title":"define ISOTP_PROTOCOL_RESULT_UNEXP_PDU","text":"<pre><code>#define ISOTP_PROTOCOL_RESULT_UNEXP_PDU `-6`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_wft_ovrn","title":"define ISOTP_PROTOCOL_RESULT_WFT_OVRN","text":"<pre><code>#define ISOTP_PROTOCOL_RESULT_WFT_OVRN `-7`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-isotp_protocol_result_wrong_sn","title":"define ISOTP_PROTOCOL_RESULT_WRONG_SN","text":"<pre><code>#define ISOTP_PROTOCOL_RESULT_WRONG_SN `-4`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_error","title":"define ISOTP_RET_ERROR","text":"<pre><code>#define ISOTP_RET_ERROR `-1`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_inprogress","title":"define ISOTP_RET_INPROGRESS","text":"<pre><code>#define ISOTP_RET_INPROGRESS `-2`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_length","title":"define ISOTP_RET_LENGTH","text":"<pre><code>#define ISOTP_RET_LENGTH `-7`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_nospace","title":"define ISOTP_RET_NOSPACE","text":"<pre><code>#define ISOTP_RET_NOSPACE `-8`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_no_data","title":"define ISOTP_RET_NO_DATA","text":"<pre><code>#define ISOTP_RET_NO_DATA `-5`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_ok","title":"define ISOTP_RET_OK","text":"<pre><code>#define ISOTP_RET_OK `0`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_overflow","title":"define ISOTP_RET_OVERFLOW","text":"<pre><code>#define ISOTP_RET_OVERFLOW `-3`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_timeout","title":"define ISOTP_RET_TIMEOUT","text":"<pre><code>#define ISOTP_RET_TIMEOUT `-6`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-isotp_ret_wrong_sn","title":"define ISOTP_RET_WRONG_SN","text":"<pre><code>#define ISOTP_RET_WRONG_SN `-4`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-isotptimeafter","title":"define IsoTpTimeAfter","text":"<pre><code>#define IsoTpTimeAfter (\n    a,\n    b\n) `((int32_t) ((int32_t) (b) - (int32_t) (a)) &lt; 0)`\n</code></pre>"},{"location":"docs/isotp__defines_8h/#define-le32toh","title":"define LE32TOH","text":"<pre><code>#define LE32TOH (\n    le\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>Inc/isotp_defines.h</code></p>"},{"location":"docs/isotp__defines_8h_source/","title":"File isotp_defines.h","text":"<p>File List &gt; Inc &gt; isotp_defines.h</p> <p>Go to the documentation of this file</p> <pre><code>/*******************************************************************************\n * ISO-TP-C: ISO 15765-2 Protocol Implementation\n *\n * Project:     ISO-TP-C - Embedded-Grade Refactoring &amp; Optimization\n * Description: Internal protocol definitions and type structures for ISO-TP\n *\n * Author:      Anton Vynohradov\n * Email:       avynohradovair@gmail.com\n *\n * License:     MIT License\n *\n * Copyright (c) 2026 Anton Vynohradov\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * SPDX-License-Identifier: MIT\n ******************************************************************************/\n\n#ifndef ISOTPC_USER_DEFINITIONS_H\n#define ISOTPC_USER_DEFINITIONS_H\n\n/* ==============================================================================\n * INCLUDES\n * =============================================================================*/\n\n#include &lt;stdint.h&gt;\n\n/* ==============================================================================\n * DEFINES &amp; MACROS\n * =============================================================================*/\n\n/**************************************************************\n * compiler specific defines\n *************************************************************/\n#ifdef __GNUC__\n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n#define ISOTP_BYTE_ORDER_LITTLE_ENDIAN\n#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n#else\n#error \"unsupported byte ordering\"\n#endif\n\n#define ISOTP_PACKED_STRUCT(content) typedef struct __attribute__((packed)) content\n#endif\n\n/**************************************************************\n * OS specific defines\n *************************************************************/\n#ifdef _WIN32\n#define ISOTP_PACKED_STRUCT(content) \\\n    __pragma(pack(push, 1)) typedef struct content __pragma(pack(pop))\n\n#define snprintf _snprintf\n\n#include &lt;windows.h&gt;\n#define ISOTP_BYTE_ORDER_LITTLE_ENDIAN\n#define __builtin_bswap8 _byteswap_uint8\n#define __builtin_bswap16 _byteswap_uint16\n#define __builtin_bswap32 _byteswap_uint32\n#define __builtin_bswap64 _byteswap_uint64\n#endif\n\n#define LE32TOH(le)                                                                     \\\n    ((uint32_t) (((le) &lt;&lt; 24) | (((le) &amp; 0x0000FF00) &lt;&lt; 8) | (((le) &amp; 0x00FF0000) &gt;&gt; 8) \\\n                 | ((le) &gt;&gt; 24)))\n\n/**************************************************************\n * internal used defines\n *************************************************************/\n#define ISOTP_RET_OK 0\n#define ISOTP_RET_ERROR -1\n#define ISOTP_RET_INPROGRESS -2\n#define ISOTP_RET_OVERFLOW -3\n#define ISOTP_RET_WRONG_SN -4\n#define ISOTP_RET_NO_DATA -5\n#define ISOTP_RET_TIMEOUT -6\n#define ISOTP_RET_LENGTH -7\n#define ISOTP_RET_NOSPACE -8\n\n/* return logic true if 'a' is after 'b' */\n#define IsoTpTimeAfter(a, b) ((int32_t) ((int32_t) (b) - (int32_t) (a)) &lt; 0)\n\n/*  invalid bs */\n#define ISOTP_INVALID_BS 0xFFFF\n\n/* Define the maximum amount of characters allowed in an error message. This fixes code which would\n * otherwise break on Microsoft's dumb platform. */\n#define ISOTP_MAX_ERROR_MSG_SIZE 128\n\n/* ISOTP sender status */\ntypedef enum\n{\n    ISOTP_SEND_STATUS_IDLE,\n    ISOTP_SEND_STATUS_INPROGRESS,\n    ISOTP_SEND_STATUS_ERROR,\n} IsoTpSendStatusTypes;\n\n/* ISOTP receiver status */\ntypedef enum\n{\n    ISOTP_RECEIVE_STATUS_IDLE,\n    ISOTP_RECEIVE_STATUS_INPROGRESS,\n    ISOTP_RECEIVE_STATUS_FULL,\n} IsoTpReceiveStatusTypes;\n\n/* can fram defination */\n#if defined(ISOTP_BYTE_ORDER_LITTLE_ENDIAN)\ntypedef struct\n{\n    uint8_t reserve_1 : 4;\n    uint8_t type : 4;\n    uint8_t reserve_2[7];\n} IsoTpPciType;\n\ntypedef struct\n{\n    uint8_t SF_DL : 4;\n    uint8_t type : 4;\n    uint8_t data[7];\n} IsoTpSingleFrame;\n\ntypedef struct\n{\n    uint8_t FF_DL_high : 4;\n    uint8_t type : 4;\n    uint8_t FF_DL_low;\n    uint8_t data[6];\n} IsoTpFirstFrameShort;\n\nISOTP_PACKED_STRUCT({\n    uint8_t set_to_zero_high : 4;\n    uint8_t type : 4;\n    uint8_t set_to_zero_low;\n    uint32_t FF_DL;\n    uint8_t data[2];\n} IsoTpFirstFrameLong);\n\ntypedef struct\n{\n    uint8_t SN : 4;\n    uint8_t type : 4;\n    uint8_t data[7];\n} IsoTpConsecutiveFrame;\n\ntypedef struct\n{\n    uint8_t FS : 4;\n    uint8_t type : 4;\n    uint8_t BS;\n    uint8_t STmin;\n    uint8_t reserve[5];\n} IsoTpFlowControl;\n\n#else\n\ntypedef struct\n{\n    uint8_t type : 4;\n    uint8_t reserve_1 : 4;\n    uint8_t reserve_2[7];\n} IsoTpPciType;\n\n/*\n * single frame\n * +-------------------------+-----+\n * | byte #0                 | ... |\n * +-------------------------+-----+\n * | nibble #0   | nibble #1 | ... |\n * +-------------+-----------+ ... +\n * | PCIType = 0 | SF_DL     | ... |\n * +-------------+-----------+-----+\n */\ntypedef struct\n{\n    uint8_t type : 4;\n    uint8_t SF_DL : 4;\n    uint8_t data[7];\n} IsoTpSingleFrame;\n\n/*\n * first frame short\n * +-------------------------+-----------------------+-----+\n * | byte #0                 | byte #1               | ... |\n * +-------------------------+-----------+-----------+-----+\n * | nibble #0   | nibble #1 | nibble #2 | nibble #3 | ... |\n * +-------------+-----------+-----------+-----------+-----+\n * | PCIType = 1 | FF_DL                             | ... |\n * +-------------+-----------+-----------------------+-----+\n */\ntypedef struct\n{\n    uint8_t FF_DL_high : 4;\n    uint8_t type : 4;\n    uint8_t FF_DL_low;\n    uint8_t data[6];\n} IsoTpFirstFrameShort;\n\n/*\n * first frame long\n * +-------------------------+-----------------------+---------+---------+---------+---------+\n * | byte #0                 | byte #1               | byte #2 | byte #3 | byte #4 | byte #5 |\n * +-------------------------+-----------+-----------+---------+---------+---------+---------+\n * | nibble #0   | nibble #1 | nibble #2 | nibble #3 | ...                                   |\n * +-------------+-----------+-----------+-----------+---------------------------------------+\n * | PCIType = 1 | unused=0  | escape sequence = 0   | FF_DL                                 |\n * +-------------+-----------+-----------------------+---------------------------------------+\n */\nISOTP_PACKED_STRUCT({\n    uint8_t set_to_zero_high : 4;\n    uint8_t type : 4;\n    uint8_t set_to_zero_low;\n    uint32_t FF_DL;\n    uint8_t data[2];\n} IsoTpFirstFrameLong);\n\n/*\n * consecutive frame\n * +-------------------------+-----+\n * | byte #0                 | ... |\n * +-------------------------+-----+\n * | nibble #0   | nibble #1 | ... |\n * +-------------+-----------+ ... +\n * | PCIType = 0 | SN        | ... |\n * +-------------+-----------+-----+\n */\ntypedef struct\n{\n    uint8_t type : 4;\n    uint8_t SN : 4;\n    uint8_t data[7];\n} IsoTpConsecutiveFrame;\n\n/*\n * flow control frame\n * +-------------------------+-----------------------+-----------------------+-----+\n * | byte #0                 | byte #1               | byte #2               | ... |\n * +-------------------------+-----------+-----------+-----------+-----------+-----+\n * | nibble #0   | nibble #1 | nibble #2 | nibble #3 | nibble #4 | nibble #5 | ... |\n * +-------------+-----------+-----------+-----------+-----------+-----------+-----+\n * | PCIType = 1 | FS        | BS                    | STmin                 | ... |\n * +-------------+-----------+-----------------------+-----------------------+-----+\n */\ntypedef struct\n{\n    uint8_t type : 4;\n    uint8_t FS : 4;\n    uint8_t BS;\n    uint8_t STmin;\n    uint8_t reserve[5];\n} IsoTpFlowControl;\n\n#endif\n\ntypedef struct\n{\n    uint8_t ptr[8];\n} IsoTpDataArray;\n\ntypedef struct\n{\n    union\n    {\n        IsoTpPciType common;\n        IsoTpSingleFrame single_frame;\n        IsoTpFirstFrameShort first_frame_short;\n        IsoTpFirstFrameLong first_frame_long;\n        IsoTpConsecutiveFrame consecutive_frame;\n        IsoTpFlowControl flow_control;\n        IsoTpDataArray data_array;\n    } as;\n} IsoTpCanMessage;\n\n/**************************************************************\n * protocol specific defines\n *************************************************************/\n\n#ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK\n/* Private: Function pointer type for transmission done callback\n * Called when any transmission (single-frame or multi-frame) is completed successfully\n */\ntypedef void (*isotp_tx_done_cb)(void* link, uint32_t tx_size, void* user_arg);\n#endif\n\n#ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK\n/* Private: Function pointer type for receive done callback\n * Called when a complete message (single-frame or multi-frame) has been received successfully\n */\ntypedef void (*isotp_rx_done_cb)(void* link, const uint8_t* data, uint32_t size, void* user_arg);\n#endif\n\n/* Private: Protocol Control Information (PCI) types, for identifying each frame of an ISO-TP\n * message.\n */\ntypedef enum\n{\n    ISOTP_PCI_TYPE_SINGLE = 0x0,\n    ISOTP_PCI_TYPE_FIRST_FRAME = 0x1,\n    TSOTP_PCI_TYPE_CONSECUTIVE_FRAME = 0x2,\n    ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME = 0x3,\n\n    ISOTP_PCI_TYPE_CONSECUTIVE_FRAME =\n        0x2,  // Typo fix; but keep broken value for backwards-compat.\n} IsoTpProtocolControlInformation;\n\n/* Private: Protocol Control Information (PCI) flow control identifiers.\n */\ntypedef enum\n{\n    PCI_FLOW_STATUS_CONTINUE = 0x0,\n    PCI_FLOW_STATUS_WAIT = 0x1,\n    PCI_FLOW_STATUS_OVERFLOW = 0x2\n} IsoTpFlowStatus;\n\n/* Private: network layer resault code.\n */\n#define ISOTP_PROTOCOL_RESULT_OK 0\n#define ISOTP_PROTOCOL_RESULT_TIMEOUT_A -1\n#define ISOTP_PROTOCOL_RESULT_TIMEOUT_BS -2\n#define ISOTP_PROTOCOL_RESULT_TIMEOUT_CR -3\n#define ISOTP_PROTOCOL_RESULT_WRONG_SN -4\n#define ISOTP_PROTOCOL_RESULT_INVALID_FS -5\n#define ISOTP_PROTOCOL_RESULT_UNEXP_PDU -6\n#define ISOTP_PROTOCOL_RESULT_WFT_OVRN -7\n#define ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW -8\n#define ISOTP_PROTOCOL_RESULT_ERROR -9\n\n/* ==============================================================================\n * TYPE DEFINITIONS\n * =============================================================================*/\n\n/* ==============================================================================\n * GLOBAL VARIABLES (extern declarations)\n * =============================================================================*/\n\n/* ==============================================================================\n * PUBLIC FUNCTION DECLARATIONS\n * =============================================================================*/\n\n#endif /* ISOTPC_USER_DEFINITIONS_H */\n</code></pre>"},{"location":"docs/isotp__user_8h/","title":"File isotp_user.h","text":"<p>FileList &gt; Inc &gt; isotp_user.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"docs/isotp__user_8h/#public-functions","title":"Public Functions","text":"Type Name void isotp_user_debug (const char * message, ...) User implemented, print debug message. uint32_t isotp_user_get_us (void) User implemented, gets the amount of time passed since the last call in microseconds. int isotp_user_send_can (const uint32_t arbitration_id, const uint8_t * data, const uint8_t size) User implemented, send CAN message (should return ISOTP_RET_OK when success)"},{"location":"docs/isotp__user_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"docs/isotp__user_8h/#function-isotp_user_debug","title":"function isotp_user_debug","text":"<p>User implemented, print debug message. <pre><code>void isotp_user_debug (\n    const char * message,\n    ...\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>message</code> - Debug message format string </li> </ul> <p>Returns:</p> <p>None </p>"},{"location":"docs/isotp__user_8h/#function-isotp_user_get_us","title":"function isotp_user_get_us","text":"<p>User implemented, gets the amount of time passed since the last call in microseconds. <pre><code>uint32_t isotp_user_get_us (\n    void\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>None</code> </li> </ul> <p>Returns:</p> <p>Time elapsed in microseconds </p>"},{"location":"docs/isotp__user_8h/#function-isotp_user_send_can","title":"function isotp_user_send_can","text":"<p>User implemented, send CAN message (should return ISOTP_RET_OK when success) <pre><code>int isotp_user_send_can (\n    const uint32_t arbitration_id,\n    const uint8_t * data,\n    const uint8_t size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>arbitration_id</code> - CAN message arbitration ID </li> <li><code>data</code> - Pointer to message data buffer </li> <li><code>size</code> - Size of message data in bytes </li> </ul> <p>Returns:</p> <p>ISOTP_RET_OK on success, ISOTP_RET_NOSPACE if transfer should be retried later, or ISOTP_RET_ERROR on failure </p> <p>The documentation for this class was generated from the following file <code>Inc/isotp_user.h</code></p>"},{"location":"docs/isotp__user_8h_source/","title":"File isotp_user.h","text":"<p>File List &gt; Inc &gt; isotp_user.h</p> <p>Go to the documentation of this file</p> <pre><code>/*******************************************************************************\n * ISO-TP-C: ISO 15765-2 Protocol Implementation\n *\n * Project:     ISO-TP-C - Embedded-Grade Refactoring &amp; Optimization\n * Description: User callback interfaces and platform abstraction layer\n *\n * Author:      Anton Vynohradov\n * Email:       avynohradovair@gmail.com\n *\n * License:     MIT License\n *\n * Copyright (c) 2026 Anton Vynohradov\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * SPDX-License-Identifier: MIT\n ******************************************************************************/\n\n#ifndef ISOTPC_USER_H\n#define ISOTPC_USER_H\n\n/* ==============================================================================\n * INCLUDES\n * =============================================================================*/\n\n#include &lt;stdint.h&gt;\n\n/* ==============================================================================\n * DEFINES &amp; MACROS\n * =============================================================================*/\n\n/* ==============================================================================\n * TYPE DEFINITIONS\n * =============================================================================*/\n\n/* ==============================================================================\n * GLOBAL VARIABLES (extern declarations)\n * =============================================================================*/\n\n/* ==============================================================================\n * PUBLIC FUNCTION DECLARATIONS\n * =============================================================================*/\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n    void isotp_user_debug(const char* message, ...);\n\n    int isotp_user_send_can(const uint32_t arbitration_id, const uint8_t* data, const uint8_t size\n#ifdef ISO_TP_USER_SEND_CAN_ARG\n                            ,\n                            void* arg\n#endif\n    );\n\n    uint32_t isotp_user_get_us(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* ISOTPC_USER_H */\n</code></pre>"},{"location":"docs/dir_413f4e031a85da0d68269c6fd2f76e1c/","title":"Dir Src","text":"<p>FileList &gt; Src</p>"},{"location":"docs/dir_413f4e031a85da0d68269c6fd2f76e1c/#files","title":"Files","text":"Type Name file isotp.c <p>The documentation for this class was generated from the following file <code>Src/</code></p>"},{"location":"docs/isotp_8c/","title":"File isotp.c","text":"<p>FileList &gt; Src &gt; isotp.c</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;assert.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include \"isotp.h\"</code></li> </ul>"},{"location":"docs/isotp_8c/#public-functions","title":"Public Functions","text":"Type Name void isotp_destroy_link (IsoTpLink * link)  void isotp_init_link (IsoTpLink * link, uint32_t sendid, uint8_t * sendbuf, uint32_t sendbufsize, uint8_t * recvbuf, uint32_t recvbufsize)  void isotp_on_can_message (IsoTpLink * link, const uint8_t * data, uint8_t len)  void isotp_poll (IsoTpLink * link)  int isotp_receive (IsoTpLink * link, uint8_t * payload, const uint32_t payload_size, uint32_t * out_size)  int isotp_send (IsoTpLink * link, const uint8_t payload, uint32_t size) PUBLIC FUNCTIONS ///. int isotp_send_with_id (IsoTpLink * link, uint32_t id, const uint8_t payload, uint32_t size)"},{"location":"docs/isotp_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name int isotp_receive_consecutive_frame (IsoTpLink * link, const IsoTpCanMessage * message, uint8_t len) Receive ISO-TP consecutive frame. int isotp_receive_first_frame (IsoTpLink * link, IsoTpCanMessage * message, uint8_t len) Receive ISO-TP first frame of multi-frame message. int isotp_receive_flow_control_frame (IsoTpLink * link, IsoTpCanMessage * message, uint8_t len) Receive ISO-TP flow control frame. int isotp_receive_single_frame (IsoTpLink * link, const IsoTpCanMessage * message, uint8_t len) Receive ISO-TP single frame. int isotp_send_consecutive_frame (IsoTpLink * link) Send ISO-TP consecutive frame. int isotp_send_first_frame (IsoTpLink * link, uint32_t id) Send ISO-TP first frame of multi-frame message. int isotp_send_flow_control (const IsoTpLink * link, uint8_t flow_status, uint8_t block_size, uint32_t st_min_us) Send ISO-TP flow control frame. int isotp_send_single_frame (const IsoTpLink * link, uint32_t id) Send ISO-TP single frame. uint32_t isotp_st_min_to_us (uint8_t st_min) Convert ST_min encoding format to microseconds. uint8_t isotp_us_to_st_min (uint32_t us) Convert microseconds to ST_min encoding format."},{"location":"docs/isotp_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"docs/isotp_8c/#function-isotp_destroy_link","title":"function isotp_destroy_link","text":"<pre><code>void isotp_destroy_link (\n    IsoTpLink * link\n) \n</code></pre>"},{"location":"docs/isotp_8c/#function-isotp_init_link","title":"function isotp_init_link","text":"<pre><code>void isotp_init_link (\n    IsoTpLink * link,\n    uint32_t sendid,\n    uint8_t * sendbuf,\n    uint32_t sendbufsize,\n    uint8_t * recvbuf,\n    uint32_t recvbufsize\n) \n</code></pre>"},{"location":"docs/isotp_8c/#function-isotp_on_can_message","title":"function isotp_on_can_message","text":"<pre><code>void isotp_on_can_message (\n    IsoTpLink * link,\n    const uint8_t * data,\n    uint8_t len\n) \n</code></pre>"},{"location":"docs/isotp_8c/#function-isotp_poll","title":"function isotp_poll","text":"<pre><code>void isotp_poll (\n    IsoTpLink * link\n) \n</code></pre>"},{"location":"docs/isotp_8c/#function-isotp_receive","title":"function isotp_receive","text":"<pre><code>int isotp_receive (\n    IsoTpLink * link,\n    uint8_t * payload,\n    const uint32_t payload_size,\n    uint32_t * out_size\n) \n</code></pre>"},{"location":"docs/isotp_8c/#function-isotp_send","title":"function isotp_send","text":"<p>PUBLIC FUNCTIONS ///. <pre><code>int isotp_send (\n    IsoTpLink * link,\n    const uint8_t payload,\n    uint32_t size\n) \n</code></pre></p>"},{"location":"docs/isotp_8c/#function-isotp_send_with_id","title":"function isotp_send_with_id","text":"<pre><code>int isotp_send_with_id (\n    IsoTpLink * link,\n    uint32_t id,\n    const uint8_t payload,\n    uint32_t size\n) \n</code></pre>"},{"location":"docs/isotp_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"docs/isotp_8c/#function-isotp_receive_consecutive_frame","title":"function isotp_receive_consecutive_frame","text":"<p>Receive ISO-TP consecutive frame. <pre><code>static int isotp_receive_consecutive_frame (\n    IsoTpLink * link,\n    const IsoTpCanMessage * message,\n    uint8_t len\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>link</code> - ISO-TP link instance </li> <li><code>message</code> - Received CAN message </li> <li><code>len</code> - Message length in bytes </li> </ul> <p>Returns:</p> <p>ISOTP_RET_OK on success, error code on failure </p>"},{"location":"docs/isotp_8c/#function-isotp_receive_first_frame","title":"function isotp_receive_first_frame","text":"<p>Receive ISO-TP first frame of multi-frame message. <pre><code>static int isotp_receive_first_frame (\n    IsoTpLink * link,\n    IsoTpCanMessage * message,\n    uint8_t len\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>link</code> - ISO-TP link instance </li> <li><code>message</code> - Received CAN message </li> <li><code>len</code> - Message length in bytes </li> </ul> <p>Returns:</p> <p>ISOTP_RET_OK on success, error code on failure </p>"},{"location":"docs/isotp_8c/#function-isotp_receive_flow_control_frame","title":"function isotp_receive_flow_control_frame","text":"<p>Receive ISO-TP flow control frame. <pre><code>static int isotp_receive_flow_control_frame (\n    IsoTpLink * link,\n    IsoTpCanMessage * message,\n    uint8_t len\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>link</code> - ISO-TP link instance </li> <li><code>message</code> - Received CAN message </li> <li><code>len</code> - Message length in bytes </li> </ul> <p>Returns:</p> <p>ISOTP_RET_OK on success, error code on failure </p>"},{"location":"docs/isotp_8c/#function-isotp_receive_single_frame","title":"function isotp_receive_single_frame","text":"<p>Receive ISO-TP single frame. <pre><code>static int isotp_receive_single_frame (\n    IsoTpLink * link,\n    const IsoTpCanMessage * message,\n    uint8_t len\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>link</code> - ISO-TP link instance </li> <li><code>message</code> - Received CAN message </li> <li><code>len</code> - Message length in bytes </li> </ul> <p>Returns:</p> <p>ISOTP_RET_OK on success, error code on failure </p>"},{"location":"docs/isotp_8c/#function-isotp_send_consecutive_frame","title":"function isotp_send_consecutive_frame","text":"<p>Send ISO-TP consecutive frame. <pre><code>static int isotp_send_consecutive_frame (\n    IsoTpLink * link\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>link</code> - ISO-TP link instance </li> </ul> <p>Returns:</p> <p>ISOTP_RET_OK on success, error code on failure </p>"},{"location":"docs/isotp_8c/#function-isotp_send_first_frame","title":"function isotp_send_first_frame","text":"<p>Send ISO-TP first frame of multi-frame message. <pre><code>static int isotp_send_first_frame (\n    IsoTpLink * link,\n    uint32_t id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>link</code> - ISO-TP link instance </li> <li><code>id</code> - CAN arbitration ID </li> </ul> <p>Returns:</p> <p>ISOTP_RET_OK on success, error code on failure </p>"},{"location":"docs/isotp_8c/#function-isotp_send_flow_control","title":"function isotp_send_flow_control","text":"<p>Send ISO-TP flow control frame. <pre><code>static int isotp_send_flow_control (\n    const IsoTpLink * link,\n    uint8_t flow_status,\n    uint8_t block_size,\n    uint32_t st_min_us\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>link</code> - ISO-TP link instance </li> <li><code>flow_status</code> - Flow control status </li> <li><code>block_size</code> - Block size for flow control </li> <li><code>st_min_us</code> - Minimum separation time in microseconds </li> </ul> <p>Returns:</p> <p>ISOTP_RET_OK on success, error code on failure </p>"},{"location":"docs/isotp_8c/#function-isotp_send_single_frame","title":"function isotp_send_single_frame","text":"<p>Send ISO-TP single frame. <pre><code>static int isotp_send_single_frame (\n    const IsoTpLink * link,\n    uint32_t id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>link</code> - ISO-TP link instance </li> <li><code>id</code> - CAN arbitration ID </li> </ul> <p>Returns:</p> <p>ISOTP_RET_OK on success, error code on failure </p>"},{"location":"docs/isotp_8c/#function-isotp_st_min_to_us","title":"function isotp_st_min_to_us","text":"<p>Convert ST_min encoding format to microseconds. <pre><code>static uint32_t isotp_st_min_to_us (\n    uint8_t st_min\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>st_min</code> - Encoded ST_min value </li> </ul> <p>Returns:</p> <p>Time in microseconds </p>"},{"location":"docs/isotp_8c/#function-isotp_us_to_st_min","title":"function isotp_us_to_st_min","text":"<p>Convert microseconds to ST_min encoding format. <pre><code>static uint8_t isotp_us_to_st_min (\n    uint32_t us\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>us</code> - Time in microseconds </li> </ul> <p>Returns:</p> <p>Encoded ST_min value </p> <p>The documentation for this class was generated from the following file <code>Src/isotp.c</code></p>"},{"location":"docs/isotp_8c_source/","title":"File isotp.c","text":"<p>File List &gt; Src &gt; isotp.c</p> <p>Go to the documentation of this file</p> <pre><code>/*******************************************************************************\n * ISO-TP-C: ISO 15765-2 Protocol Implementation\n *\n * Project:     ISO-TP-C - Embedded-Grade Refactoring &amp; Optimization\n * Description: Core ISO-TP protocol implementation with multi-frame support\n *\n * Author:      Anton Vynohradov\n * Email:       avynohradovair@gmail.com\n *\n * License:     MIT License\n *\n * Copyright (c) 2026 Anton Vynohradov\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * SPDX-License-Identifier: MIT\n ******************************************************************************/\n\n/* ==============================================================================\n * INCLUDES\n * =============================================================================*/\n\n#include &lt;assert.h&gt;\n#include &lt;stdint.h&gt;\n\n#include \"isotp.h\"\n\n/* ==============================================================================\n * DEFINES &amp; MACROS\n * =============================================================================*/\n\n/* ==============================================================================\n * PRIVATE TYPE DEFINITIONS\n * =============================================================================*/\n\n/* ==============================================================================\n * PRIVATE VARIABLES (static)\n * =============================================================================*/\n\n/* ==============================================================================\n * PRIVATE FUNCTION DECLARATIONS (static)\n * =============================================================================*/\n\nstatic uint8_t isotp_us_to_st_min(uint32_t us);\n\nstatic uint32_t isotp_st_min_to_us(uint8_t st_min);\n\nstatic int isotp_send_flow_control(const IsoTpLink* link, uint8_t flow_status, uint8_t block_size,\n                                   uint32_t st_min_us);\n\nstatic int isotp_send_single_frame(const IsoTpLink* link, uint32_t id);\n\nstatic int isotp_send_first_frame(IsoTpLink* link, uint32_t id);\n\nstatic int isotp_send_consecutive_frame(IsoTpLink* link);\n\nstatic int isotp_receive_single_frame(IsoTpLink* link, const IsoTpCanMessage* message, uint8_t len);\n\nstatic int isotp_receive_first_frame(IsoTpLink* link, IsoTpCanMessage* message, uint8_t len);\n\nstatic int isotp_receive_consecutive_frame(IsoTpLink* link, const IsoTpCanMessage* message,\n                                           uint8_t len);\n\nstatic int isotp_receive_flow_control_frame(IsoTpLink* link, IsoTpCanMessage* message, uint8_t len);\n\n/* ==============================================================================\n * PRIVATE FUNCTION IMPLEMENTATIONS\n * =============================================================================*/\n\n/* st_min to microsecond */\nstatic uint8_t isotp_us_to_st_min(uint32_t us)\n{\n    // ISO 15765-2:2016 defines STmin encoding:\n    // 0x00..0x7F: value in milliseconds (0..127 ms)\n    // 0xF1..0xF9: value in 100 microsecond steps (100..900 us)\n    const uint32_t STMIN_MS_MAX = 127000;  // 127 ms in us\n    const uint32_t STMIN_US_MIN = 100;     // 100 us\n    const uint32_t STMIN_US_MAX = 900;     // 900 us\n    const uint8_t STMIN_US_BASE = 0xF0;    // base for 100us steps\n\n    if (us &lt;= STMIN_MS_MAX)\n    {\n        if (us &gt;= STMIN_US_MIN &amp;&amp; us &lt;= STMIN_US_MAX)\n        {\n            return (uint8_t) (STMIN_US_BASE + (us / 100));\n        }\n        else\n        {\n            return (uint8_t) (us / 1000u);\n        }\n    }\n\n    return 0;\n}\n\n/* st_min to usec  */\nstatic uint32_t isotp_st_min_to_us(uint8_t st_min)\n{\n    // ISO 15765-2:2016 defines STmin encoding:\n    // 0x00..0x7F: value in milliseconds (0..127 ms)\n    // 0xF1..0xF9: value in 100 microsecond steps (100..900 us)\n    const uint8_t STMIN_MS_MAX = 0x7F;       // 127 ms\n    const uint8_t STMIN_US_MIN_CODE = 0xF1;  // 100 us\n    const uint8_t STMIN_US_MAX_CODE = 0xF9;  // 900 us\n    const uint8_t STMIN_US_BASE = 0xF0;      // base for 100us steps\n    const uint32_t US_PER_MS = 1000;\n    const uint32_t US_STEP = 100;\n\n    if (st_min &lt;= STMIN_MS_MAX)\n    {\n        return st_min * US_PER_MS;\n    }\n    else if (st_min &gt;= STMIN_US_MIN_CODE &amp;&amp; st_min &lt;= STMIN_US_MAX_CODE)\n    {\n        return (st_min - STMIN_US_BASE) * US_STEP;\n    }\n    return 0;\n}\n\nstatic int isotp_send_flow_control(const IsoTpLink* link, uint8_t flow_status, uint8_t block_size,\n                                   uint32_t st_min_us)\n{\n    IsoTpCanMessage message;\n    (void) memset(&amp;message, 0, sizeof(message));\n    int ret;\n    uint8_t size = 0;\n\n    /* setup message  */\n    message.as.flow_control.type = ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME;\n    message.as.flow_control.FS = flow_status;\n    message.as.flow_control.BS = block_size;\n    message.as.flow_control.STmin = isotp_us_to_st_min(st_min_us);\n\n    /* send message */\n#ifdef ISO_TP_FRAME_PADDING\n    (void) memset(message.as.flow_control.reserve, ISO_TP_FRAME_PADDING_VALUE,\n                  sizeof(message.as.flow_control.reserve));\n    size = sizeof(message);\n#else\n    size = 3;\n#endif\n\n    ret = isotp_user_send_can(link-&gt;send_arbitration_id, message.as.data_array.ptr, size\n#if defined(ISO_TP_USER_SEND_CAN_ARG)\n                              ,\n                              link-&gt;user_send_can_arg\n#endif\n    );\n\n    return ret;\n}\n\nstatic int isotp_send_single_frame(const IsoTpLink* link, uint32_t id)\n{\n    (void) id;  // Prevent unused variable warning\n\n    IsoTpCanMessage message;\n    int ret;\n    uint8_t size = 0;\n\n    /* multi frame message length must greater than 7  */\n    assert(link-&gt;send_size &lt;= 7);\n\n    /* setup message  */\n    message.as.single_frame.type = ISOTP_PCI_TYPE_SINGLE;\n    message.as.single_frame.SF_DL = (uint8_t) link-&gt;send_size;\n    (void) memcpy(message.as.single_frame.data, link-&gt;send_buffer, link-&gt;send_size);\n\n    /* send message */\n#ifdef ISO_TP_FRAME_PADDING\n    (void) memset(message.as.single_frame.data + link-&gt;send_size, ISO_TP_FRAME_PADDING_VALUE,\n                  sizeof(message.as.single_frame.data) - link-&gt;send_size);\n    size = sizeof(message);\n#else\n    size = link-&gt;send_size + (uint8_t) 1;\n#endif\n\n    ret = isotp_user_send_can(link-&gt;send_arbitration_id, message.as.data_array.ptr, size\n#if defined(ISO_TP_USER_SEND_CAN_ARG)\n                              ,\n                              link-&gt;user_send_can_arg\n#endif\n    );\n\n    return ret;\n}\n\nstatic int isotp_send_first_frame(IsoTpLink* link, uint32_t id)\n{\n    IsoTpCanMessage message = {0};\n    int ret = 0;\n\n    /* multi frame message length must greater than 7  */\n    assert(link-&gt;send_size &gt; 7);\n\n    if (link-&gt;send_size &lt;= 4095)\n    {\n        /* setup 'short' message */\n        message.as.first_frame_short.type = ISOTP_PCI_TYPE_FIRST_FRAME;\n        message.as.first_frame_short.FF_DL_low = (uint8_t) link-&gt;send_size;\n        message.as.first_frame_short.FF_DL_high = (uint8_t) (0x0F &amp; (link-&gt;send_size &gt;&gt; 8));\n        (void) memcpy(message.as.first_frame_short.data, link-&gt;send_buffer,\n                      sizeof(message.as.first_frame_short.data));\n\n        /* send 'short' message */\n        ret = isotp_user_send_can(id, message.as.data_array.ptr, sizeof(message)\n#if defined(ISO_TP_USER_SEND_CAN_ARG)\n                                                                     ,\n                                  link-&gt;user_send_can_arg\n#endif\n        );\n\n        if (ISOTP_RET_OK == ret)\n        {\n            link-&gt;send_offset += sizeof(message.as.first_frame_short.data);\n        }\n    }\n    else\n    {  // ISO15765-2:2016\n        /* setup 'long' message */\n        message.as.first_frame_long.set_to_zero_high = 0;\n        message.as.first_frame_long.set_to_zero_low = 0;\n        message.as.first_frame_long.type = ISOTP_PCI_TYPE_FIRST_FRAME;\n        message.as.first_frame_long.FF_DL = LE32TOH(link-&gt;send_size);\n        (void) memcpy(message.as.first_frame_long.data, link-&gt;send_buffer,\n                      sizeof(message.as.first_frame_long.data));\n\n        /* send 'long' message */\n        ret = isotp_user_send_can(id, message.as.data_array.ptr, sizeof(message)\n#if defined(ISO_TP_USER_SEND_CAN_ARG)\n                                                                     ,\n                                  link-&gt;user_send_can_arg\n#endif\n        );\n\n        if (ISOTP_RET_OK == ret)\n        {\n            link-&gt;send_offset += sizeof(message.as.first_frame_long.data);\n        }\n    }\n\n    link-&gt;send_sn = 1;\n\n    return ret;\n}\n\nstatic int isotp_send_consecutive_frame(IsoTpLink* link)\n{\n    IsoTpCanMessage message;\n    uint32_t data_length;\n    int ret;\n    uint8_t size = 0;\n\n    /* multi frame message length must greater than 7  */\n    assert(link-&gt;send_size &gt; 7);\n\n    /* setup message  */\n    message.as.consecutive_frame.type = ISOTP_PCI_TYPE_CONSECUTIVE_FRAME;\n    message.as.consecutive_frame.SN = link-&gt;send_sn;\n    data_length = link-&gt;send_size - link-&gt;send_offset;\n    if (data_length &gt; sizeof(message.as.consecutive_frame.data))\n    {\n        data_length = sizeof(message.as.consecutive_frame.data);\n    }\n    (void) memcpy(message.as.consecutive_frame.data, link-&gt;send_buffer + link-&gt;send_offset,\n                  data_length);\n\n    /* send message */\n#ifdef ISO_TP_FRAME_PADDING\n    (void) memset(message.as.consecutive_frame.data + data_length, ISO_TP_FRAME_PADDING_VALUE,\n                  sizeof(message.as.consecutive_frame.data) - data_length);\n    size = sizeof(message);\n#else\n    size = data_length + 1;\n#endif\n\n    ret = isotp_user_send_can(link-&gt;send_arbitration_id, message.as.data_array.ptr, size\n#if defined(ISO_TP_USER_SEND_CAN_ARG)\n                              ,\n                              link-&gt;user_send_can_arg\n#endif\n    );\n\n    if (ISOTP_RET_OK == ret)\n    {\n        link-&gt;send_offset += data_length;\n        if (++(link-&gt;send_sn) &gt; 0x0F)\n        {\n            link-&gt;send_sn = 0;\n        }\n    }\n\n    return ret;\n}\n\nstatic int isotp_receive_single_frame(IsoTpLink* link, const IsoTpCanMessage* message, uint8_t len)\n{\n    /* check data length */\n    if ((0 == message-&gt;as.single_frame.SF_DL) || (message-&gt;as.single_frame.SF_DL &gt; (len - 1)))\n    {\n        isotp_user_debug(\"Single-frame length too small.\");\n        return ISOTP_RET_LENGTH;\n    }\n\n    /* copying data */\n    (void) memcpy(link-&gt;receive_buffer, message-&gt;as.single_frame.data,\n                  message-&gt;as.single_frame.SF_DL);\n    link-&gt;receive_size = message-&gt;as.single_frame.SF_DL;\n\n    return ISOTP_RET_OK;\n}\n\nstatic int isotp_receive_first_frame(IsoTpLink* link, IsoTpCanMessage* message, uint8_t len)\n{\n    uint8_t is_long_packet = 0;\n    uint32_t payload_length;\n\n    if (8 != len)\n    {\n        isotp_user_debug(\"First frame should be 8 bytes in length.\");\n        return ISOTP_RET_LENGTH;\n    }\n\n    /* check data length */\n    payload_length = message-&gt;as.first_frame_short.FF_DL_high;\n    payload_length = (payload_length &lt;&lt; 8) + message-&gt;as.first_frame_short.FF_DL_low;\n\n    /* if length is ZERO we get a long message &gt; 4095bytes of payload */\n    if (payload_length == 0)\n    {\n        is_long_packet = 1;\n        payload_length = LE32TOH(message-&gt;as.first_frame_long.FF_DL);\n    }\n\n    /* should not use multiple frame transmition */\n    if (payload_length &lt;= 7)\n    {\n        isotp_user_debug(\"Should not use multiple frame transmission.\");\n        return ISOTP_RET_LENGTH;\n    }\n\n    if (payload_length &gt; link-&gt;receive_buf_size)\n    {\n        isotp_user_debug(\"Multi-frame response too large for receiving buffer.\");\n        return ISOTP_RET_OVERFLOW;\n    }\n\n    /* copying data */\n    if (is_long_packet)\n    {\n        (void) memcpy(link-&gt;receive_buffer, message-&gt;as.first_frame_long.data,\n                      sizeof(message-&gt;as.first_frame_long.data));\n        link-&gt;receive_offset = sizeof(message-&gt;as.first_frame_long.data);\n    }\n    else\n    {\n        (void) memcpy(link-&gt;receive_buffer, message-&gt;as.first_frame_short.data,\n                      sizeof(message-&gt;as.first_frame_short.data));\n        link-&gt;receive_offset = sizeof(message-&gt;as.first_frame_short.data);\n    }\n\n    link-&gt;receive_size = payload_length;\n    link-&gt;receive_sn = 1;\n\n    return ISOTP_RET_OK;\n}\n\nstatic int isotp_receive_consecutive_frame(IsoTpLink* link, const IsoTpCanMessage* message,\n                                           uint8_t len)\n{\n    uint32_t remaining_bytes;\n\n    /* check sn */\n    if (link-&gt;receive_sn != message-&gt;as.consecutive_frame.SN)\n    {\n        return ISOTP_RET_WRONG_SN;\n    }\n\n    /* check data length */\n    remaining_bytes = link-&gt;receive_size - link-&gt;receive_offset;\n    if (remaining_bytes &gt; sizeof(message-&gt;as.consecutive_frame.data))\n    {\n        remaining_bytes = sizeof(message-&gt;as.consecutive_frame.data);\n    }\n    if (remaining_bytes &gt; (uint32_t) (len - 1))\n    {\n        isotp_user_debug(\"Consecutive frame too short.\");\n        return ISOTP_RET_LENGTH;\n    }\n\n    /* copying data */\n    (void) memcpy(link-&gt;receive_buffer + link-&gt;receive_offset, message-&gt;as.consecutive_frame.data,\n                  remaining_bytes);\n\n    link-&gt;receive_offset += remaining_bytes;\n    if (++(link-&gt;receive_sn) &gt; 0x0F)\n    {\n        link-&gt;receive_sn = 0;\n    }\n\n    return ISOTP_RET_OK;\n}\n\nstatic int isotp_receive_flow_control_frame(IsoTpLink* link, IsoTpCanMessage* message, uint8_t len)\n{\n    /* unused args */\n    (void) link;\n    (void) message;\n\n    /* check message length */\n    if (len &lt; 3)\n    {\n        isotp_user_debug(\"Flow control frame too short.\");\n        return ISOTP_RET_LENGTH;\n    }\n\n    return ISOTP_RET_OK;\n}\n\n\nint isotp_send(IsoTpLink* link, const uint8_t payload[], uint32_t size)\n{\n    return isotp_send_with_id(link, link-&gt;send_arbitration_id, payload, size);\n}\n\nint isotp_send_with_id(IsoTpLink* link, uint32_t id, const uint8_t payload[], uint32_t size)\n{\n    int ret;\n\n    if (link == 0x0)\n    {\n        isotp_user_debug(\"Link is null!\");\n        return ISOTP_RET_ERROR;\n    }\n\n    if (size &gt; link-&gt;send_buf_size)\n    {\n        isotp_user_debug(\"Message size too large. Increase ISO_TP_MAX_MESSAGE_SIZE to set \"\n                         \"a larger buffer\\n\");\n\n        char message[ISOTP_MAX_ERROR_MSG_SIZE] = {0};\n        int32_t writtenChars = snprintf(&amp;message[0], ISOTP_MAX_ERROR_MSG_SIZE,\n                                        \"Attempted to send %u bytes; max size is %u!\\n\",\n                                        (unsigned int) size, (unsigned int) link-&gt;send_buf_size);\n\n        assert(writtenChars &lt;= ISOTP_MAX_ERROR_MSG_SIZE);\n        (void) writtenChars;\n\n        isotp_user_debug(message);\n        return ISOTP_RET_OVERFLOW;\n    }\n\n    if (ISOTP_SEND_STATUS_INPROGRESS == link-&gt;send_status)\n    {\n        isotp_user_debug(\"Abort previous message, transmission in progress.\\n\");\n        return ISOTP_RET_INPROGRESS;\n    }\n\n    /* copy into local buffer */\n    link-&gt;send_size = size;\n    link-&gt;send_offset = 0;\n    (void) memcpy(link-&gt;send_buffer, payload, size);\n\n    if (link-&gt;send_size &lt; 8)\n    {\n        /* send single frame */\n        ret = isotp_send_single_frame(link, id);\n#ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK\n        if (ret == ISOTP_RET_OK &amp;&amp; link-&gt;tx_done_cb)\n        {\n            link-&gt;tx_done_cb(link, link-&gt;send_size, link-&gt;tx_done_cb_arg);\n        }\n#endif\n    }\n    else\n    {\n        /* send multi-frame */\n        ret = isotp_send_first_frame(link, id);\n\n        /* init multi-frame control flags */\n        if (ISOTP_RET_OK == ret)\n        {\n            link-&gt;send_bs_remain = 0;\n            link-&gt;send_st_min_us = 0;\n            link-&gt;send_wtf_count = 0;\n            link-&gt;send_timer_st = isotp_user_get_us();\n            link-&gt;send_timer_bs = isotp_user_get_us() + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US;\n            link-&gt;send_protocol_result = ISOTP_PROTOCOL_RESULT_OK;\n            link-&gt;send_status = ISOTP_SEND_STATUS_INPROGRESS;\n        }\n    }\n\n    return ret;\n}\n\nvoid isotp_on_can_message(IsoTpLink* link, const uint8_t* data, uint8_t len)\n{\n    IsoTpCanMessage message;\n    int ret;\n\n    if (len &lt; 2 || len &gt; 8)\n    {\n        return;\n    }\n\n    memcpy(message.as.data_array.ptr, data, len);\n    memset(message.as.data_array.ptr + len, 0, sizeof(message.as.data_array.ptr) - len);\n\n    switch (message.as.common.type)\n    {\n        case ISOTP_PCI_TYPE_SINGLE:\n        {\n            /* update protocol result */\n            if (ISOTP_RECEIVE_STATUS_INPROGRESS == link-&gt;receive_status)\n            {\n                link-&gt;receive_protocol_result = ISOTP_PROTOCOL_RESULT_UNEXP_PDU;\n            }\n            else\n            {\n                link-&gt;receive_protocol_result = ISOTP_PROTOCOL_RESULT_OK;\n            }\n\n            /* handle message */\n            ret = isotp_receive_single_frame(link, &amp;message, len);\n\n            if (ISOTP_RET_OK == ret)\n            {\n                /* change status */\n                link-&gt;receive_status = ISOTP_RECEIVE_STATUS_FULL;\n            }\n            break;\n        }\n        case ISOTP_PCI_TYPE_FIRST_FRAME:\n        {\n            /* update protocol result */\n            if (ISOTP_RECEIVE_STATUS_INPROGRESS == link-&gt;receive_status)\n            {\n                link-&gt;receive_protocol_result = ISOTP_PROTOCOL_RESULT_UNEXP_PDU;\n            }\n            else\n            {\n                link-&gt;receive_protocol_result = ISOTP_PROTOCOL_RESULT_OK;\n            }\n\n            /* handle message */\n            ret = isotp_receive_first_frame(link, &amp;message, len);\n\n            /* if overflow happened */\n            if (ISOTP_RET_OVERFLOW == ret)\n            {\n                /* update protocol result */\n                link-&gt;receive_protocol_result = ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW;\n                /* change status */\n                link-&gt;receive_status = ISOTP_RECEIVE_STATUS_IDLE;\n                /* send error message */\n                isotp_send_flow_control(link, PCI_FLOW_STATUS_OVERFLOW, 0, 0);\n                break;\n            }\n\n            /* if receive successful */\n            if (ISOTP_RET_OK == ret)\n            {\n                /* change status */\n                link-&gt;receive_status = ISOTP_RECEIVE_STATUS_INPROGRESS;\n                /* send fc frame */\n                link-&gt;receive_bs_count = ISO_TP_DEFAULT_BLOCK_SIZE;\n                isotp_send_flow_control(link, PCI_FLOW_STATUS_CONTINUE, link-&gt;receive_bs_count,\n                                        ISO_TP_DEFAULT_ST_MIN_US);\n                /* refresh timer cs */\n                link-&gt;receive_timer_cr = isotp_user_get_us() + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US;\n            }\n\n            break;\n        }\n        case ISOTP_PCI_TYPE_CONSECUTIVE_FRAME:\n        {\n            /* check if in receiving status */\n            if (ISOTP_RECEIVE_STATUS_INPROGRESS != link-&gt;receive_status)\n            {\n                link-&gt;receive_protocol_result = ISOTP_PROTOCOL_RESULT_UNEXP_PDU;\n                break;\n            }\n\n            /* handle message */\n            ret = isotp_receive_consecutive_frame(link, &amp;message, len);\n\n            /* if wrong sn */\n            if (ISOTP_RET_WRONG_SN == ret)\n            {\n                link-&gt;receive_protocol_result = ISOTP_PROTOCOL_RESULT_WRONG_SN;\n                link-&gt;receive_status = ISOTP_RECEIVE_STATUS_IDLE;\n                break;\n            }\n\n            /* if success */\n            if (ISOTP_RET_OK == ret)\n            {\n                /* refresh timer cs */\n                link-&gt;receive_timer_cr = isotp_user_get_us() + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US;\n\n                /* receive finished */\n                if (link-&gt;receive_offset &gt;= link-&gt;receive_size)\n                {\n                    link-&gt;receive_status = ISOTP_RECEIVE_STATUS_FULL;\n                }\n                else\n                {\n                    /* send fc when bs reaches limit */\n                    if (0 == --link-&gt;receive_bs_count)\n                    {\n                        link-&gt;receive_bs_count = ISO_TP_DEFAULT_BLOCK_SIZE;\n                        isotp_send_flow_control(link, PCI_FLOW_STATUS_CONTINUE,\n                                                link-&gt;receive_bs_count, ISO_TP_DEFAULT_ST_MIN_US);\n                    }\n                }\n            }\n\n            break;\n        }\n        case ISOTP_PCI_TYPE_FLOW_CONTROL_FRAME:\n            /* handle fc frame only when sending in progress  */\n            if (ISOTP_SEND_STATUS_INPROGRESS != link-&gt;send_status)\n            {\n                break;\n            }\n\n            /* handle message */\n            ret = isotp_receive_flow_control_frame(link, &amp;message, len);\n\n            if (ISOTP_RET_OK == ret)\n            {\n                /* refresh bs timer */\n                link-&gt;send_timer_bs = isotp_user_get_us() + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US;\n\n                /* overflow */\n                if (PCI_FLOW_STATUS_OVERFLOW == message.as.flow_control.FS)\n                {\n                    link-&gt;send_protocol_result = ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW;\n                    link-&gt;send_status = ISOTP_SEND_STATUS_ERROR;\n                }\n\n                /* wait */\n                else if (PCI_FLOW_STATUS_WAIT == message.as.flow_control.FS)\n                {\n                    link-&gt;send_wtf_count += 1;\n                    /* wait exceed allowed count */\n                    if (link-&gt;send_wtf_count &gt; ISO_TP_MAX_WFT_NUMBER)\n                    {\n                        link-&gt;send_protocol_result = ISOTP_PROTOCOL_RESULT_WFT_OVRN;\n                        link-&gt;send_status = ISOTP_SEND_STATUS_ERROR;\n                    }\n                }\n\n                /* permit send */\n                else if (PCI_FLOW_STATUS_CONTINUE == message.as.flow_control.FS)\n                {\n                    if (0 == message.as.flow_control.BS)\n                    {\n                        link-&gt;send_bs_remain = ISOTP_INVALID_BS;\n                    }\n                    else\n                    {\n                        link-&gt;send_bs_remain = message.as.flow_control.BS;\n                    }\n                    uint32_t message_st_min_us = isotp_st_min_to_us(message.as.flow_control.STmin);\n                    link-&gt;send_st_min_us =\n                        message_st_min_us &gt; ISO_TP_DEFAULT_ST_MIN_US ?\n                            message_st_min_us :\n                            ISO_TP_DEFAULT_ST_MIN_US;  // prefer as much st_min as possible\n                                                       // for stability?\n                    link-&gt;send_wtf_count = 0;\n                }\n            }\n            break;\n        default:\n            break;\n    };\n\n#ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK\n    /* Notify user via callback if registered */\n    if (link-&gt;receive_status == ISOTP_RECEIVE_STATUS_FULL &amp;&amp; link-&gt;rx_done_cb != NULL)\n    {\n        link-&gt;rx_done_cb(link, link-&gt;receive_buffer, link-&gt;receive_size, link-&gt;rx_done_cb_arg);\n        link-&gt;receive_status = ISOTP_RECEIVE_STATUS_IDLE;\n    }\n#endif\n    return;\n}\n\nint isotp_receive(IsoTpLink* link, uint8_t* payload, const uint32_t payload_size,\n                  uint32_t* out_size)\n{\n    uint32_t copylen;\n\n#ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK\n    /* If callback is registered, isotp_receive should not be used */\n    if (link-&gt;rx_done_cb != NULL)\n    {\n        return ISOTP_RET_ERROR; /* Callback mode active, use callback instead */\n    }\n#endif\n\n    if (ISOTP_RECEIVE_STATUS_FULL != link-&gt;receive_status)\n    {\n        return ISOTP_RET_NO_DATA;\n    }\n\n    copylen = link-&gt;receive_size;\n    if (copylen &gt; payload_size)\n    {\n        copylen = payload_size;\n    }\n\n    memcpy(payload, link-&gt;receive_buffer, copylen);\n    *out_size = copylen;\n\n    link-&gt;receive_status = ISOTP_RECEIVE_STATUS_IDLE;\n\n    return ISOTP_RET_OK;\n}\n\nvoid isotp_init_link(IsoTpLink* link, uint32_t sendid, uint8_t* sendbuf, uint32_t sendbufsize,\n                     uint8_t* recvbuf, uint32_t recvbufsize)\n{\n    memset(link, 0, sizeof(*link));\n    link-&gt;receive_status = ISOTP_RECEIVE_STATUS_IDLE;\n    link-&gt;send_status = ISOTP_SEND_STATUS_IDLE;\n    link-&gt;send_arbitration_id = sendid;\n    link-&gt;send_buffer = sendbuf;\n    link-&gt;send_buf_size = sendbufsize;\n    link-&gt;receive_buffer = recvbuf;\n    link-&gt;receive_buf_size = recvbufsize;\n\n#ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK\n    link-&gt;tx_done_cb = NULL;\n    link-&gt;tx_done_cb_arg = NULL;\n#endif\n\n#ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK\n    link-&gt;rx_done_cb = NULL;\n    link-&gt;rx_done_cb_arg = NULL;\n#endif\n\n    return;\n}\n\nvoid isotp_destroy_link(IsoTpLink* link)\n{\n    if (link == NULL)\n    {\n        return;\n    }\n\n    // Clear callbacks\n#ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK\n    link-&gt;tx_done_cb = NULL;\n    link-&gt;tx_done_cb_arg = NULL;\n#endif\n\n#ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK\n    link-&gt;rx_done_cb = NULL;\n    link-&gt;rx_done_cb_arg = NULL;\n#endif\n\n    // Reset link state (optional, but good practice)\n    memset(link, 0, sizeof(IsoTpLink));\n}\n\nvoid isotp_poll(IsoTpLink* link)\n{\n    int ret = 0;\n\n    /* only polling when operation in progress */\n    if (ISOTP_SEND_STATUS_INPROGRESS == link-&gt;send_status)\n    {\n        /* continue send data */\n        if (/* send data if bs_remain is invalid or bs_remain large than zero */\n            (ISOTP_INVALID_BS == link-&gt;send_bs_remain || link-&gt;send_bs_remain &gt; 0) &amp;&amp;\n            /* and if st_min is zero or go beyond interval time */\n            (0 == link-&gt;send_st_min_us || IsoTpTimeAfter(isotp_user_get_us(), link-&gt;send_timer_st)))\n        {\n            ret = isotp_send_consecutive_frame(link);\n            if (ISOTP_RET_OK == ret)\n            {\n                if (ISOTP_INVALID_BS != link-&gt;send_bs_remain)\n                {\n                    link-&gt;send_bs_remain -= 1;\n                }\n                link-&gt;send_timer_bs = isotp_user_get_us() + ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US;\n                link-&gt;send_timer_st = isotp_user_get_us() + link-&gt;send_st_min_us;\n\n                /* check if send finish */\n                if (link-&gt;send_offset &gt;= link-&gt;send_size)\n                {\n                    link-&gt;send_status = ISOTP_SEND_STATUS_IDLE;\n#ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK\n                    if (link-&gt;tx_done_cb != NULL)\n                    {\n                        link-&gt;tx_done_cb(link, link-&gt;send_size, link-&gt;tx_done_cb_arg);\n                    }\n#endif\n                }\n            }\n            else if (ISOTP_RET_NOSPACE == ret)\n            {\n                /* shim reported that it isn't able to send a frame at present, retry on\n                 * next call\n                 */\n            }\n            else\n            {\n                link-&gt;send_status = ISOTP_SEND_STATUS_ERROR;\n            }\n        }\n\n        /* check timeout */\n        if (IsoTpTimeAfter(isotp_user_get_us(), link-&gt;send_timer_bs))\n        {\n            link-&gt;send_protocol_result = ISOTP_PROTOCOL_RESULT_TIMEOUT_BS;\n            link-&gt;send_status = ISOTP_SEND_STATUS_ERROR;\n        }\n    }\n\n    /* only polling when operation in progress */\n    if (ISOTP_RECEIVE_STATUS_INPROGRESS == link-&gt;receive_status)\n    {\n        /* check timeout */\n        if ((link-&gt;receive_timer_cr &gt; 0)\n            &amp;&amp; IsoTpTimeAfter(isotp_user_get_us(), link-&gt;receive_timer_cr))\n        {\n            link-&gt;receive_protocol_result = ISOTP_PROTOCOL_RESULT_TIMEOUT_CR;\n            link-&gt;receive_status = ISOTP_RECEIVE_STATUS_IDLE;\n        }\n    }\n\n    return;\n}\n\n#ifdef ISO_TP_TRANSMIT_COMPLETE_CALLBACK\nvoid isotp_set_tx_done_cb(IsoTpLink* link, isotp_tx_done_cb cb, void* arg)\n{\n    if (link != NULL)\n    {\n        link-&gt;tx_done_cb = cb;\n        link-&gt;tx_done_cb_arg = arg;\n    }\n}\n#endif\n\n#ifdef ISO_TP_RECEIVE_COMPLETE_CALLBACK\nvoid isotp_set_rx_done_cb(IsoTpLink* link, isotp_rx_done_cb cb, void* arg)\n{\n    if (link != NULL)\n    {\n        link-&gt;rx_done_cb = cb;\n        link-&gt;rx_done_cb_arg = arg;\n    }\n}\n#endif\n</code></pre>"},{"location":"docs/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"docs/classes/","title":"Class Index","text":""},{"location":"docs/classes/#i","title":"i","text":"<ul> <li>IsoTpCanMessage</li> <li>IsoTpConsecutiveFrame</li> <li>IsoTpDataArray</li> <li>IsoTpFirstFrameShort</li> <li>IsoTpFlowControl</li> <li>IsoTpPciType</li> <li>IsoTpSingleFrame</li> </ul>"},{"location":"docs/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>struct IsoTpCanMessage </li> <li>struct IsoTpConsecutiveFrame </li> <li>struct IsoTpDataArray </li> <li>struct IsoTpFirstFrameShort </li> <li>struct IsoTpFlowControl </li> <li>struct IsoTpPciType </li> <li>struct IsoTpSingleFrame </li> </ul>"},{"location":"docs/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"docs/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"docs/class_members/","title":"Class Members","text":""},{"location":"docs/class_members/#a","title":"a","text":"<ul> <li>as (IsoTpCanMessage)</li> </ul>"},{"location":"docs/class_members/#b","title":"b","text":"<ul> <li>BS (IsoTpFlowControl)</li> </ul>"},{"location":"docs/class_members/#c","title":"c","text":"<ul> <li>common (IsoTpCanMessage)</li> <li>consecutive_frame (IsoTpCanMessage)</li> </ul>"},{"location":"docs/class_members/#d","title":"d","text":"<ul> <li>data_array (IsoTpCanMessage)</li> <li>data (IsoTpConsecutiveFrame, IsoTpFirstFrameShort, IsoTpSingleFrame)</li> </ul>"},{"location":"docs/class_members/#f","title":"f","text":"<ul> <li>first_frame_long (IsoTpCanMessage)</li> <li>first_frame_short (IsoTpCanMessage)</li> <li>flow_control (IsoTpCanMessage)</li> <li>FF_DL_high (IsoTpFirstFrameShort)</li> <li>FF_DL_low (IsoTpFirstFrameShort)</li> <li>FS (IsoTpFlowControl)</li> </ul>"},{"location":"docs/class_members/#p","title":"p","text":"<ul> <li>ptr (IsoTpDataArray)</li> </ul>"},{"location":"docs/class_members/#r","title":"r","text":"<ul> <li>reserve (IsoTpFlowControl)</li> <li>reserve_1 (IsoTpPciType)</li> <li>reserve_2 (IsoTpPciType)</li> </ul>"},{"location":"docs/class_members/#s","title":"s","text":"<ul> <li>single_frame (IsoTpCanMessage)</li> <li>SN (IsoTpConsecutiveFrame)</li> <li>STmin (IsoTpFlowControl)</li> <li>SF_DL (IsoTpSingleFrame)</li> </ul>"},{"location":"docs/class_members/#t","title":"t","text":"<ul> <li>type (IsoTpConsecutiveFrame, IsoTpFirstFrameShort, IsoTpFlowControl, IsoTpPciType, IsoTpSingleFrame)</li> </ul>"},{"location":"docs/class_member_functions/","title":"Class Member Functions","text":"<p>Nothing related to Class Member Functions found.</p>"},{"location":"docs/class_member_variables/","title":"Class Member Variables","text":""},{"location":"docs/class_member_variables/#a","title":"a","text":"<ul> <li>as (IsoTpCanMessage)</li> </ul>"},{"location":"docs/class_member_variables/#b","title":"b","text":"<ul> <li>BS (IsoTpFlowControl)</li> </ul>"},{"location":"docs/class_member_variables/#c","title":"c","text":"<ul> <li>common (IsoTpCanMessage)</li> <li>consecutive_frame (IsoTpCanMessage)</li> </ul>"},{"location":"docs/class_member_variables/#d","title":"d","text":"<ul> <li>data_array (IsoTpCanMessage)</li> <li>data (IsoTpConsecutiveFrame, IsoTpFirstFrameShort, IsoTpSingleFrame)</li> </ul>"},{"location":"docs/class_member_variables/#f","title":"f","text":"<ul> <li>first_frame_long (IsoTpCanMessage)</li> <li>first_frame_short (IsoTpCanMessage)</li> <li>flow_control (IsoTpCanMessage)</li> <li>FF_DL_high (IsoTpFirstFrameShort)</li> <li>FF_DL_low (IsoTpFirstFrameShort)</li> <li>FS (IsoTpFlowControl)</li> </ul>"},{"location":"docs/class_member_variables/#p","title":"p","text":"<ul> <li>ptr (IsoTpDataArray)</li> </ul>"},{"location":"docs/class_member_variables/#r","title":"r","text":"<ul> <li>reserve (IsoTpFlowControl)</li> <li>reserve_1 (IsoTpPciType)</li> <li>reserve_2 (IsoTpPciType)</li> </ul>"},{"location":"docs/class_member_variables/#s","title":"s","text":"<ul> <li>single_frame (IsoTpCanMessage)</li> <li>SN (IsoTpConsecutiveFrame)</li> <li>STmin (IsoTpFlowControl)</li> <li>SF_DL (IsoTpSingleFrame)</li> </ul>"},{"location":"docs/class_member_variables/#t","title":"t","text":"<ul> <li>type (IsoTpConsecutiveFrame, IsoTpFirstFrameShort, IsoTpFlowControl, IsoTpPciType, IsoTpSingleFrame)</li> </ul>"},{"location":"docs/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"docs/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"docs/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"docs/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"docs/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"docs/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"docs/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"docs/functions/","title":"Functions","text":""},{"location":"docs/functions/#i","title":"i","text":"<ul> <li>ISOTP_PACKED_STRUCT (isotp_defines.h)</li> <li>isotp_user_debug (isotp_user.h)</li> <li>isotp_user_get_us (isotp_user.h)</li> <li>isotp_user_send_can (isotp_user.h)</li> <li>isotp_destroy_link (isotp.c)</li> <li>isotp_init_link (isotp.c)</li> <li>isotp_on_can_message (isotp.c)</li> <li>isotp_poll (isotp.c)</li> <li>isotp_receive (isotp.c)</li> <li>isotp_receive_consecutive_frame (isotp.c)</li> <li>isotp_receive_first_frame (isotp.c)</li> <li>isotp_receive_flow_control_frame (isotp.c)</li> <li>isotp_receive_single_frame (isotp.c)</li> <li>isotp_send (isotp.c)</li> <li>isotp_send_consecutive_frame (isotp.c)</li> <li>isotp_send_first_frame (isotp.c)</li> <li>isotp_send_flow_control (isotp.c)</li> <li>isotp_send_single_frame (isotp.c)</li> <li>isotp_send_with_id (isotp.c)</li> <li>isotp_st_min_to_us (isotp.c)</li> <li>isotp_us_to_st_min (isotp.c)</li> </ul>"},{"location":"docs/macros/","title":"Macros","text":""},{"location":"docs/macros/#i","title":"i","text":"<ul> <li>ISO_TP_DEFAULT_BLOCK_SIZE (isotp_config.h)</li> <li>ISO_TP_DEFAULT_RESPONSE_TIMEOUT_US (isotp_config.h)</li> <li>ISO_TP_DEFAULT_ST_MIN_US (isotp_config.h)</li> <li>ISO_TP_FRAME_PADDING_VALUE (isotp_config.h)</li> <li>ISO_TP_MAX_WFT_NUMBER (isotp_config.h)</li> <li>ISOTP_INVALID_BS (isotp_defines.h)</li> <li>ISOTP_MAX_ERROR_MSG_SIZE (isotp_defines.h)</li> <li>ISOTP_PROTOCOL_RESULT_BUFFER_OVFLW (isotp_defines.h)</li> <li>ISOTP_PROTOCOL_RESULT_ERROR (isotp_defines.h)</li> <li>ISOTP_PROTOCOL_RESULT_INVALID_FS (isotp_defines.h)</li> <li>ISOTP_PROTOCOL_RESULT_OK (isotp_defines.h)</li> <li>ISOTP_PROTOCOL_RESULT_TIMEOUT_A (isotp_defines.h)</li> <li>ISOTP_PROTOCOL_RESULT_TIMEOUT_BS (isotp_defines.h)</li> <li>ISOTP_PROTOCOL_RESULT_TIMEOUT_CR (isotp_defines.h)</li> <li>ISOTP_PROTOCOL_RESULT_UNEXP_PDU (isotp_defines.h)</li> <li>ISOTP_PROTOCOL_RESULT_WFT_OVRN (isotp_defines.h)</li> <li>ISOTP_PROTOCOL_RESULT_WRONG_SN (isotp_defines.h)</li> <li>ISOTP_RET_ERROR (isotp_defines.h)</li> <li>ISOTP_RET_INPROGRESS (isotp_defines.h)</li> <li>ISOTP_RET_LENGTH (isotp_defines.h)</li> <li>ISOTP_RET_NOSPACE (isotp_defines.h)</li> <li>ISOTP_RET_NO_DATA (isotp_defines.h)</li> <li>ISOTP_RET_OK (isotp_defines.h)</li> <li>ISOTP_RET_OVERFLOW (isotp_defines.h)</li> <li>ISOTP_RET_TIMEOUT (isotp_defines.h)</li> <li>ISOTP_RET_WRONG_SN (isotp_defines.h)</li> <li>IsoTpTimeAfter (isotp_defines.h)</li> </ul>"},{"location":"docs/macros/#l","title":"l","text":"<ul> <li>LE32TOH (isotp_defines.h)</li> </ul>"},{"location":"docs/variables/","title":"Variables","text":""},{"location":"docs/variables/#i","title":"i","text":"<ul> <li>IsoTpFlowStatus (isotp_defines.h)</li> <li>IsoTpProtocolControlInformation (isotp_defines.h)</li> <li>IsoTpReceiveStatusTypes (isotp_defines.h)</li> <li>IsoTpSendStatusTypes (isotp_defines.h)</li> </ul>"},{"location":"docs/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}