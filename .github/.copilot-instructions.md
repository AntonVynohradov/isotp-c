# Copilot Code Review Guidelines for ISO-TP-C

**Purpose:** This document provides comprehensive code review guidelines for pull requests to the ISO-TP-C project, based on the **CERT C Coding Standard** and embedded systems best practices.

---

## Code Review Standards

All code contributions must adhere to the following standards:

### 1. CERT C Coding Standard Compliance

#### 1.1 Preprocessor (PRE)

**PRE00-C:** Avoid relying on undefined behavior  
- ✅ Do not use undefined preprocessor directives
- ✅ Use standard preprocessor features only

**PRE01-C:** Use parentheses within macros around parameter names  
- ✅ All macro parameters must be enclosed in parentheses
- ✅ Example: `#define SQUARE(x) ((x) * (x))`

**PRE02-C:** Macro replacement lists should be parenthesized  
- ✅ Entire macro body must be wrapped in parentheses
- ✅ Example: `#define ADD(a, b) ((a) + (b))`

**PRE03-C:** Prefer typedef to define for type aliases  
- ✅ Use `typedef` for types, not `#define`
- ✅ Avoid `#define` for anything except constants

**PRE04-C:** Recognize that dead code may be created by preprocessor directives  
- ✅ Document why code is conditionally compiled
- ✅ Verify all code paths are tested

**PRE05-C:** Understand macro replacement when concatenating tokens in C  
- ✅ Avoid token concatenation operators (`##`)
- ✅ If used, thoroughly test the result

**PRE06-C:** Understand that the arguments to object-like macros are not evaluated  
- ✅ Be aware macros are text substitution, not function calls
- ✅ Use `static inline` functions as safer alternative

**PRE07-C:** Avoid using repeated question marks  
- ✅ Never use `??` sequences (trigraphs)
- ✅ Use escape sequences instead

**PRE08-C:** Guarantee that header file names are unique  
- ✅ Use unique header guard names
- ✅ Example: `#ifndef ISOTP_H` ... `#define ISOTP_H` ... `#endif`

**PRE09-C:** Do not replace a function name with a macro  
- ✅ Never shadow function names with macros
- ✅ Prefix macros with module name to avoid conflicts

**PRE10-C:** Avoid including a nonstandard header file more than once  
- ✅ Use header guards to prevent multiple inclusion
- ✅ `#ifndef`, `#define`, `#endif` pattern

**PRE11-C:** Do not suggest or require a particular resource allocation strategy  
- ✅ Allow flexibility in resource management
- ✅ Document assumptions clearly

**PRE12-C:** Do not define unsafe macros that rely on operator precedence  
- ✅ Always parenthesize macro arguments
- ✅ Always parenthesize macro body

**PRE13-C:** Avoid using undefined preprocessing operators  
- ✅ Use only standard preprocessor directives
- ✅ Check preprocessor syntax carefully

**PRE14-C:** Avoid relying on unpredictable initialization with static storage duration  
- ✅ Explicitly initialize all static variables
- ✅ Document initialization order

**PRE15-C:** Understand what happens to a #define'd identifier expression  
- ✅ Be aware of macro substitution side effects
- ✅ Prefer `static const` or `enum` to macros for constants

**PRE16-C:** Prefer typedef to define for type aliases  
- ✅ Use `typedef struct` instead of `#define` for structs
- ✅ Improves type safety and readability

**Review Focus:** Header guards, macro safety, parenthesization, typedef usage.

---

#### 1.2 Declarations and Initialization (DCL)

**DCL00-C:** Const-qualify immutable objects  
- ✅ Mark all read-only data with `const`
- ✅ Enables compiler optimizations and error detection

**DCL01-C:** Do not reuse variable names in subscopes  
- ✅ Avoid shadowing outer scope variables
- ✅ Use descriptive names to prevent shadowing confusion

**DCL02-C:** Use visually distinct identifiers  
- ✅ Avoid confusing variable names (e.g., `l`, `O`, `I`)
- ✅ Use clear, descriptive names

**DCL03-C:** Use a static assertion to test the properties of types and expressions  
- ✅ Use `static_assert()` for compile-time checks
- ✅ Verify size assumptions: `static_assert(sizeof(uint32_t) == 4);`

**DCL04-C:** Do not declare more than one variable per declaration statement  
- ✅ One declaration per line
- ✅ Improves readability and prevents errors

**DCL05-C:** Use typedef instead of struct, union, and enum tags in type declarations  
- ✅ Use `typedef struct` ... { ... } name_t;`
- ✅ Reduces verbosity in declarations

**DCL06-C:** Use meaningful symbolic constants to represent literal values in program logic  
- ✅ Replace magic numbers with named constants
- ✅ Example: `#define MAX_BUFFER_SIZE 4096` or `static const uint32_t MAX_BUFFER_SIZE = 4096;`

**DCL07-C:** Include an explicit type in every declaration  
- ✅ Never rely on implicit types
- ✅ Always specify `int`, `uint8_t`, `const`, `static`, etc.

**DCL08-C:** Properly encode relationships in constant definitions  
- ✅ Define related constants together
- ✅ Document dependencies between constants

**DCL09-C:** Declare functions with appropriate storage-class specifiers  
- ✅ Use `static` for file-scope functions
- ✅ Use `extern` for external declarations
- ✅ Document visibility intent

**DCL10-C:** Maintain the validity of objects throughout their lifetime  
- ✅ Ensure object validity from creation to destruction
- ✅ Use initialization to establish valid state

**DCL11-C:** Understand the concepts of a declaration and a definition  
- ✅ One definition per object (ODR)
- ✅ Multiple declarations allowed, single definition required

**DCL12-C:** Implement thin abstraction layers using typedefs and tag names  
- ✅ Use typedef for abstraction
- ✅ Hide implementation details

**DCL13-C:** Hide implementation details  
- ✅ Use opaque pointers for internal state
- ✅ Expose only necessary interface

**DCL14-C:** Define variables with appropriate scope  
- ✅ Minimize variable scope
- ✅ Use `static` for file scope, block scope for temporaries

**DCL15-C:** Declare loop variables in the smallest scope  
- ✅ Declare loop counters in for loop initialization
- ✅ `for (int i = 0; i < count; i++)` (if C99+)

**DCL16-C:** Bundle the declaration of variables with their use  
- ✅ Declare variables close to first use
- ✅ Improves readability and reduces errors

**DCL17-C:** Ensure that all bits in a bit-field are explicitly initialized  
- ✅ Always initialize all members of bit-field structs
- ✅ Document bit-field layout and padding

**DCL18-C:** Do not begin identifier names with an underscore followed by an uppercase letter or an underscore  
- ✅ Avoid `_Reserved` names (reserved for implementation)
- ✅ Use safe naming conventions

**DCL19-C:** Avoid naming variables with names that are a subset of or similar to reserved identifiers  
- ✅ Do not use names like `errno_t`, `sys_errno`
- ✅ Check reserved identifier lists

**DCL20-C:** Use typedef for function pointers rather than declaring them inline  
- ✅ Use `typedef int (*callback_t)(void);`
- ✅ Improves readability and reusability

**DCL21-C:** Do not include a function declaration or definition with different levels of indirection  
- ✅ Declaration must match definition
- ✅ Pointer levels must be consistent

**DCL22-C:** Use volatile when accessing data whose value might change in ways unexpected by the implementation  
- ✅ Mark volatile hardware registers
- ✅ Use `volatile uint32_t *gpio_register = (volatile uint32_t *)0x40000000;`

**DCL23-C:** Complete the initialization before assigning a value to a global pointer  
- ✅ Initialize all data before first use
- ✅ Avoid using partially initialized global structures

**DCL24-C:** Do not declare conflicting names in the same scope  
- ✅ Unique names within scope
- ✅ Prevents linker and compilation errors

**DCL25-C:** Implementation-defined behavior is unspecified, do not rely upon it  
- ✅ Avoid relying on undefined behavior
- ✅ Code must work across implementations

**Review Focus:** Const correctness, static vs extern, typedef usage, initialization.

---

#### 1.3 Expressions (EXP)

**EXP00-C:** Use parentheses for clarity in expressions  
- ✅ Parenthesize complex expressions
- ✅ Do not rely on operator precedence

**EXP01-C:** Do not take the size of a pointer to determine the size of the pointed-to type  
- ✅ Use `sizeof(type)`, not `sizeof(pointer)`
- ✅ Never assume pointer size equals pointed-to size

**EXP02-C:** Be aware of the short-circuit behavior of the logical AND and OR operators  
- ✅ Right operand may not evaluate
- ✅ Design code assuming short-circuit behavior

**EXP03-C:** Do not compare or subtract pointers that do not address elements of the same array  
- ✅ Pointer arithmetic valid only within same array
- ✅ Comparison between array elements is safe, cross-array is not

**EXP04-C:** Do not perform byte-by-byte comparisons with memcmp() on objects that may contain padding  
- ✅ Padding bytes may be uninitialized
- ✅ Compare field-by-field for structs with padding

**EXP05-C:** Do not cast away a const qualification  
- ✅ Never use `(type *)const_ptr` to remove const
- ✅ If removal is needed, redesign the API

**EXP06-C:** Operands to sizeof shall not contain side effects  
- ✅ `sizeof()` is compile-time, does not evaluate operand
- ✅ Never rely on side effects in sizeof argument

**EXP07-C:** Do not diminish the transparency of invariants  
- ✅ Use expressions that maintain class invariants
- ✅ Do not bypass invariant checks

**EXP08-C:** Ensure that operations on signed integers do not result in overflow  
- ✅ Check for overflow before operations
- ✅ Consider range of values carefully

**EXP09-C:** Do not rely on the order of evaluation of subexpressions or arguments in an expression statement  
- ✅ Evaluation order is unspecified
- ✅ Do not write code dependent on specific order

**EXP10-C:** Do not depend on the order of evaluation of function designators, arguments, and other subexpressions  
- ✅ Avoid code relying on evaluation order
- ✅ Use intermediate variables if order matters

**EXP11-C:** Do not apply the address-of operator to an expression of type register  
- ✅ `register` keyword is hint, cannot take address reliably
- ✅ Modern compilers ignore `register`, but still dangerous

**EXP12-C:** Do not ignore values returned by functions  
- ✅ Check return values of all functions
- ✅ Use `(void)` cast if return value intentionally ignored

**EXP13-C:** Do not use assignment operators in selections statements  
- ✅ Avoid `if (x = y)` patterns
- ✅ Use `if ((x = y) != 0)` if assignment needed in condition

**EXP14-C:** Ensure that the true and false branches of a conditional expression have compatible types  
- ✅ `condition ? value1 : value2` must have same or compatible types
- ✅ Avoid unnecessary conversions

**EXP15-C:** Do not cast a pointer to a function pointer of the wrong type  
- ✅ Function pointer casts can cause undefined behavior
- ✅ Match signatures exactly

**EXP16-C:** Do not compare function pointers to NULL, use actual function addresses for comparisons  
- ✅ Function pointers are never NULL by standard
- ✅ Compare to valid function address or use conditional expression

**EXP17-C:** Ensure that the invariants and constraints of the original type are maintained when assigning a value to a character pointer  
- ✅ Character pointers may point to strings or buffers
- ✅ Ensure null termination if string is expected

**Review Focus:** Parenthesization, pointer safety, overflow, evaluation order, return values.

---

#### 1.4 Integers (INT)

**INT00-C:** Understand the data model used by your implementation  
- ✅ Know size of int, long, short on your platform
- ✅ Use fixed-width types instead

**INT01-C:** Use rvalues instead of values for in-out parameters  
- ✅ Parameters should be clearly input or output
- ✅ Avoid ambiguous in-out parameters

**INT02-C:** Understand integer conversion rules  
- ✅ Know how signed/unsigned conversions work
- ✅ Use explicit casts to clarify intent

**INT03-C:** Use a secure integer library  
- ✅ Use checked arithmetic for overflow detection
- ✅ Implement or use validated integer library

**INT04-C:** Enforce limits on integer values originating from untrusted sources  
- ✅ Validate input ranges
- ✅ Reject out-of-range values

**INT05-C:** Do not use input from an untrusted source to size an object in a function argument  
- ✅ Always validate size parameters
- ✅ Check for integer overflow in size calculations

**INT06-C:** Use static assertions to prevent runtime errors and other problems  
- ✅ Use `static_assert()` for type size assumptions
- ✅ Verify platform-dependent values at compile time

**INT07-C:** Use only explicitly-sized integer types defined in <stdint.h>  
- ✅ Use `uint8_t`, `uint16_t`, `uint32_t`, `int32_t`, not `int`, `long`
- ✅ Ensures portability across platforms

**INT08-C:** Verify that all integer values are in range  
- ✅ Validate before operations
- ✅ Check function input parameters

**INT09-C:** Ensure enumeration constants do not result in integer overflow  
- ✅ Enumeration values must fit in `int`
- ✅ Check for very large enum values

**INT10-C:** Ensure that the result of getc(), fgetc(), or getchar() is compared against EOF  
- ✅ `EOF` is typically -1, cannot store in `unsigned char`
- ✅ Store in `int` and compare against `EOF`

**INT11-C:** Do not assume the representation of a signed integer  
- ✅ Signed integers may use two's complement, one's complement, or sign-magnitude
- ✅ Do not rely on specific representation

**INT12-C:** Do not make assumptions about the state of bits that are not part of the range of a type  
- ✅ Padding bits value is undefined
- ✅ Do not examine or set padding bits

**INT13-C:** Use bitwise operators only on unsigned integer types  
- ✅ Bitwise operations on signed types can have implementation-defined behavior
- ✅ Use unsigned types for bit manipulation

**INT14-C:** Avoid performing bitwise operations on signed types  
- ✅ Use unsigned types for bit fields
- ✅ Signed shift operations can be implementation-defined

**INT15-C:** Ensure that division and modulo operations do not result in divide-by-zero errors  
- ✅ Always validate divisor is non-zero
- ✅ Check denominator before division

**INT16-C:** Do not make assumptions about the width of bit-fields  
- ✅ Bit-field width is implementation-defined
- ✅ Document assumptions explicitly

**INT17-C:** Define and use a consistent type model for integer values  
- ✅ Consistent type usage across project
- ✅ Document type conventions

**INT18-C:** Evaluate integer expressions in a larger size before comparing or assigning to that variable  
- ✅ Perform operations in wider types to prevent overflow
- ✅ Check intermediate values

**INT19-C:** Ensure that unsigned integer operations do not wrap  
- ✅ Unsigned overflow wraps (by standard), but may be undesired
- ✅ Check that values stay in range

**INT20-C:** Ensure that integer operations do not result in integer overflow  
- ✅ Comprehensive overflow checking
- ✅ Especially critical for arithmetic on untrusted input

**INT21-C:** Ensure that integer conversions do not result in lost information  
- ✅ Check conversion is safe (no truncation)
- ✅ Example: `uint32_t` to `uint8_t` may lose data

**INT22-C:** Avoid relying on the properties of signed integer representation  
- ✅ Portable code must not assume two's complement
- ✅ Although almost all modern systems use it

**INT23-C:** Ensure that the operands of a division or modulo operation are not equal to 0  
- ✅ Verify divisor before division/modulo
- ✅ Return error on divide-by-zero

**INT24-C:** Do not shift a negative number of bits or more bits than exist in the operand  
- ✅ Shift amount must be in range [0, sizeof(type)*8)
- ✅ Validate shift amount

**INT25-C:** Ensure that the operands of a shift operator are of the correct type  
- ✅ Left operand should be of integer type
- ✅ Right operand must be non-negative and less than operand width

**INT26-C:** Ensure that operations on signed integer types do not result in signed integer overflow  
- ✅ Signed overflow is undefined behavior
- ✅ Always check for overflow

**INT27-C:** Check for integer overflow when converting a floating-point number to an integer type  
- ✅ Validate float is in integer range before conversion
- ✅ Check for NaN and infinity

**INT28-C:** Ensure that integer conversion errors are detected and handled  
- ✅ Catch conversion errors
- ✅ Implement safe conversion functions

**INT29-C:** Ensure that integer division and modulo operations do not result in divide-by-zero errors  
- ✅ Always validate divisor
- ✅ Document error handling

**INT30-C:** Ensure that unsigned integer wrap-around is not used  
- ✅ Unsigned wrap-around is allowed but often undesired
- ✅ Use wider types or check to prevent wrap

**INT31-C:** Ensure that integer-like conversion functions correctly convert between types  
- ✅ Use proper conversion functions
- ✅ Document conversion behavior

**INT32-C:** Ensure that operations on signed integers do not result in signed integer overflow  
- ✅ Signed overflow is undefined behavior
- ✅ Comprehensive overflow prevention

**INT33-C:** Ensure that division and remainder operations do not result in divide-by-zero errors  
- ✅ Always validate divisor before use
- ✅ Return error status on invalid divisor

**Review Focus:** Use `stdint.h` types, overflow/underflow checks, signed/unsigned mixing, division-by-zero.

---

#### 1.5 Floating Point (FLP)

**FLP00-C:** Understand floating-point numbers  
- ✅ Know limitations of IEEE 754 floating-point
- ✅ Understand precision, rounding, and special values (NaN, Inf)

**FLP01-C:** Take care in rounding floating-point numbers  
- ✅ Rounding can introduce subtle errors
- ✅ Use explicit rounding functions when needed

**FLP02-C:** Avoid using floating-point numbers when precise computation is needed  
- ✅ Use fixed-point arithmetic for financial/precise calculations
- ✅ Floating-point not suitable for exact decimal arithmetic

**FLP03-C:** Detect and handle floating-point errors  
- ✅ Check for NaN: `if (isnan(x))` requires `<math.h>`
- ✅ Check for infinity: `if (isinf(x))`
- ✅ Check for overflow/underflow

**FLP04-C:** Evaluate floating-point expressions in a larger size then assign to a smaller size  
- ✅ Perform calculations in `double` if intermediate, assign to `float` if final
- ✅ Reduces accumulation of rounding errors

**FLP05-C:** Consider using the POSIX isgreater and related functions  
- ✅ Use `isgreater()`, `isless()` for robust floating-point comparison
- ✅ Handle NaN correctly (unlike `<` and `>`)

**FLP06-C:** Do not use compare operators with floating-point types  
- ✅ Never use `==` or `!=` for float comparison
- ✅ Use epsilon-based comparison: `if (fabs(a - b) < epsilon)`
- ✅ Or use `isgreater()`, `isless()` from `<math.h>`

**FLP07-C:** Ensure that floating-point conversion operations do not result in lost information  
- ✅ Check that float fits in integer type before conversion
- ✅ Validate range before casting

**FLP08-C:** Do not test for equality with floating-point values  
- ✅ No `if (x == 0.0)` for floating-point
- ✅ Use `if (fabs(x) < epsilon)`

**FLP09-C:** Ensure that floating-point conversion operations do not result in lost information  
- ✅ Track precision loss during conversions
- ✅ Document assumptions about precision

**FLP10-C:** Take care in using the floating-point math library  
- ✅ Know which functions are available (sin, cos, sqrt, etc.)
- ✅ Link with `-lm` for math library

**FLP11-C:** Do not assume that floating-point math operations will behave as mathematical operations  
- ✅ Floating-point is not pure mathematics
- ✅ Rounding and precision limitations apply

**Review Focus:** Floating-point is rare in ISO-TP-C; if used, ensure proper comparison and error handling.

---

#### 1.6 Arrays (ARR)

**ARR00-C:** Understand how arrays work  
- ✅ Arrays decay to pointers in most contexts
- ✅ Cannot determine array size from pointer alone

**ARR01-C:** Do not apply the sizeof operator to a pointer to dynamically allocated memory  
- ✅ `sizeof(ptr)` returns pointer size, not allocation size
- ✅ Track allocation size separately

**ARR02-C:** Explicitly specify array bounds, even if implicitly determinable by an initializer  
- ✅ Use `uint8_t buffer[ISOTP_BUFSIZE];` instead of `uint8_t buffer[] = {...};`
- ✅ Makes size explicit for reviewers and tools

**ARR03-C:** Do not underestimate the size of a variable-length array (VLA)  
- ✅ Avoid VLAs in embedded code (`int arr[n];`)
- ✅ Use fixed-size arrays or dynamic allocation

**ARR04-C:** Do not allow buffer overflows when using sprintf()  
- ✅ Never use `sprintf(buffer, ...)` without bounds checking
- ✅ Use `snprintf(buffer, sizeof(buffer), ...)` instead

**ARR05-C:** Do not use pointer arithmetic to traverse multidimensional arrays  
- ✅ Use array indexing instead of manual pointer arithmetic
- ✅ Safer and clearer: `array[i][j]` instead of `*(array + i*cols + j)`

**ARR06-C:** Ensure that array access is within the specified bounds  
- ✅ Bounds check before every array access
- ✅ Validate indices against array size

**ARR07-C:** Use only explicitly-sized fundamental data types in structure definitions  
- ✅ Use `uint32_t`, not `int`, in structs
- ✅ Ensures portable struct layout

**ARR08-C:** Do not verify that size arguments to buffer copy functions are correct  
- ✅ Always verify size parameters match actual buffer size
- ✅ Check: `memcpy(dest, src, size)` - verify size ≤ both buffers

**ARR09-C:** Do not assume that the narrators of a string literal is the same as the size of the storage  
- ✅ String `"hello"` is 6 bytes (5 chars + null terminator)
- ✅ Account for null terminator in size calculations

**ARR10-C:** Do not rely on an implicitly specified array bound  
- ✅ Explicitly specify array sizes
- ✅ Do not use `int arr[] = {1, 2, 3};` (implicitly sized)

**ARR11-C:** Do not assume the iteration of nested loops will not exceed the bounds of an array  
- ✅ Verify loop bounds match array dimensions
- ✅ Multi-dimensional array bounds must match loop structure

**ARR12-C:** Ensure that array access is within the specified bounds  
- ✅ Comprehensive bounds checking
- ✅ Validate all array accesses

**ARR13-C:** Do not allow buffer overflows when using off-the-shelf library functions  
- ✅ Know safe alternatives: `strncpy`, `strncat`, `snprintf`
- ✅ Check documentation for size limits

**ARR14-C:** Do not modify the original array when using library functions  
- ✅ Some functions modify input; be aware
- ✅ Document behavior of used functions

**ARR15-C:** Do not do anything to an array whose length is unknown  
- ✅ Always know array size before operations
- ✅ Pass size to functions that need it

**ARR16-C:** Ensure that array access validations are performed before function calls  
- ✅ Validate bounds in calling function, not called function alone
- ✅ Fail fast at validation point

**ARR17-C:** Do not rely on the properties of an integer when reading from a stream  
- ✅ `getc()` returns `int`, not `char`
- ✅ Store in `int` and compare to `EOF`

**ARR18-C:** Ensure that allocated memory is properly freed  
- ✅ Each allocation must have corresponding deallocation
- ✅ Use RAII patterns where possible

**ARR19-C:** Do not create multidimensional arrays through the use of pointer-to-array types  
- ✅ Use true 2D arrays: `uint8_t matrix[rows][cols];`
- ✅ Avoid `uint8_t **matrix;` without careful initialization

**ARR20-C:** Ensure that allocated memory is used properly  
- ✅ Allocate correct size
- ✅ Use correct type for casts

**Review Focus:** Bounds checking, VLA avoidance, buffer overflow prevention, size validation.

---

#### 1.7 Characters and Strings (STR)

**STR00-C:** Understand the data model  
- ✅ Know character encoding (ASCII, UTF-8, etc.)
- ✅ Understand null termination requirements

**STR01-C:** Adopt and implement a consistent plan for managing strings  
- ✅ Consistent string handling approach across project
- ✅ Document assumptions (null-terminated, max length, etc.)

**STR02-C:** Specify the size of an output buffer in an output parameter, not the return value  
- ✅ Pass buffer size to functions that fill buffers
- ✅ Document size expectations

**STR03-C:** Do not inadvertently truncate a string  
- ✅ Check string length before copying
- ✅ Use safe functions like `snprintf()` with size limit

**STR04-C:** Use plain char for characters in the standard ASCII range  
- ✅ Use `char` for ASCII characters
- ✅ Use `uint8_t` or `int` for extended character handling

**STR05-C:** Use appropriate conversions when supplying character data to byte-oriented legacy library functions  
- ✅ Legacy functions may expect `unsigned char` or `int`
- ✅ Explicit cast may be needed

**STR06-C:** Do not assume that the narrators of a string literal is the same as the size of the storage  
- ✅ `strlen("hello")` is 5, but storage is 6 (with null)
- ✅ Account for null terminator in size calculations

**STR07-C:** Use the bounds-checking interfaces instead of the standard string manipulation functions  
- ✅ Use `snprintf()` instead of `sprintf()`
- ✅ Use `strncpy()` instead of `strcpy()` (with caution)
- ✅ Use `strncat()` instead of `strcat()`

**STR08-C:** Do not use getchar() to handle characters other than unsigned char and EOF  
- ✅ Store result in `int`, not `char`
- ✅ Compare against `EOF` (not just check value)

**STR09-C:** Do not use functions that stop reading a formatted input on whitespace for parsing structurally complex input  
- ✅ `scanf()` stops at whitespace, use `fgets()` + manual parsing for complex input
- ✅ Or use specialized parsing functions

**STR10-C:** Do not pass the result of a cast implicitly to a wider integer type to a string manipulation function that expects a specific type  
- ✅ Cast `char` to `unsigned char` before passing to ctype functions
- ✅ Example: `isalpha((unsigned char)c)` not `isalpha(c)`

**STR11-C:** Do not specify a bound that exceeds the size of the object referenced by the format argument in calls to the snprintf, snwprintf, strftime, and swftime functions  
- ✅ Bound passed to `snprintf()` must be ≤ actual buffer size
- ✅ Prefer: `snprintf(buf, sizeof(buf), fmt, args)`

**STR12-C:** Do not pass a string that is not null-terminated to a library function that expects a null-terminated string  
- ✅ All strings must be null-terminated
- ✅ Validate null termination before passing to string functions

**STR13-C:** Use a lightweight mechanism to detect invalid function arguments at runtime  
- ✅ Add input validation to string functions
- ✅ Check for NULL pointers and unexpected sizes

**Review Focus:** Null termination, bounds checking, safe string functions, UTF-8 if used.

---

#### 1.8 Memory Management (MEM)

**MEM00-C:** Allocate sufficiently large storage for library functions that write to a buffer  
- ✅ Always allocate enough space for function output
- ✅ Read function documentation for size requirements

**MEM01-C:** Store the address of dynamically allocated memory in an appropriately qualified pointer  
- ✅ Use `void *` or specific type pointer for malloc return
- ✅ Never lose pointer to allocated memory

**MEM02-C:** Ensure that object size parameters are correct in function calls  
- ✅ `malloc(sizeof(type) * count)` to allocate arrays
- ✅ Verify size calculation doesn't overflow

**MEM03-C:** Clear sensitive information from memory before freeing it  
- ✅ Use `memset(ptr, 0, size)` before `free(ptr)` for sensitive data
- ✅ Prevent disclosure of freed memory contents

**MEM04-C:** Do not perform zero-length allocations  
- ✅ Check that allocation size > 0
- ✅ Return error for size 0 allocation requests

**MEM05-C:** Avoid using _alloca() for large allocations  
- ✅ Stack allocation is limited
- ✅ Large allocations should use heap
- ✅ Avoid `alloca()` in embedded code altogether

**MEM06-C:** Ensure that the pointers to objects returned by memory allocation functions are null-checked prior to dereference  
- ✅ Always check `malloc()` return for NULL
- ✅ Example: `ptr = malloc(size); if (ptr == NULL) return error;`

**MEM07-C:** Ensure that the function argument to realloc() is an allocated pointer  
- ✅ Do not pass uninitialized or freed pointers to `realloc()`
- ✅ Verify pointer was returned by previous allocation

**MEM08-C:** Do not return uninitialized memory from a function  
- ✅ Initialize all returned memory
- ✅ Or document that caller must initialize

**MEM09-C:** Do not assume memory is cleared when a pointer to that memory is set to null  
- ✅ Setting pointer to NULL doesn't clear data
- ✅ Use `memset()` to clear sensitive data

**MEM10-C:** Ensure that all allocated memory is freed  
- ✅ Pair every allocation with deallocation
- ✅ Use cleanup handlers or RAII patterns

**MEM11-C:** Do not use pointer arithmetic to access an array in a function argument  
- ✅ Use array indexing, not pointer math
- ✅ Safer: `buf[i]` instead of `*(buf + i)`

**MEM12-C:** Define and use a consistent object allocation strategy within a program  
- ✅ Consistent approach to allocation/deallocation
- ✅ Document chosen strategy (static, dynamic, etc.)

**MEM13-C:** Ensure that all exit paths from a loop deallocate dynamically allocated memory  
- ✅ Deallocate on normal exit and error cases
- ✅ Use cleanup labels or loop variable tracking

**MEM14-C:** Ensure that memory allocation size arguments do not undergo integer conversion that can result in an unexpected allocation size  
- ✅ Check `sizeof` calculations for overflow
- ✅ Example: `malloc(sizeof(type) * count)` - verify count fit

**MEM15-C:** Ensure that memory allocation is correctly paired with deallocation  
- ✅ malloc/free, new/delete, etc. must be paired
- ✅ Document ownership clearly

**MEM16-C:** Ensure that dynamically allocated memory is properly freed  
- ✅ All allocations must be freed
- ✅ No memory leaks allowed

**Review Focus:** Static allocation preference, NULL checks, malloc/free pairs, no memory leaks.

---

#### 1.9 Input/Output (FIO)

**FIO00-C:** Take care when creating format strings  
- ✅ Never use user input directly as format string
- ✅ Always use fixed format string: `printf("%s", user_input)` not `printf(user_input)`

**FIO01-C:** Be careful using functions that use file names for creation  
- ✅ Validate file names to prevent directory traversal
- ✅ Use whitelist of allowed file names

**FIO02-C:** Canonicalize path names originating from tainted sources  
- ✅ Resolve symlinks and relative paths
- ✅ Verify file is within expected directory

**FIO03-C:** Do not make assumptions about fopen() and file creation  
- ✅ Know that `fopen("file", "w")` truncates existing file
- ✅ Use `fopen("file", "a")` to append

**FIO04-C:** Detect and handle input output errors  
- ✅ Check return values of I/O functions
- ✅ Check `ferror()` and `feof()` after operations

**FIO05-C:** Identify files using multiple file attributes  
- ✅ Use inode/device combination, not just name
- ✅ Prevent TOCTOU (Time Of Check Time Of Use) vulnerabilities

**FIO06-C:** Create files with appropriate access permissions  
- ✅ Use `umask()` and `chmod()` appropriately
- ✅ Restrict permissions on sensitive files

**FIO07-C:** Prefer fseek() over rewind()  
- ✅ `fseek(fp, 0, SEEK_SET)` is better than `rewind(fp)`
- ✅ fseek() returns error status, rewind() doesn't

**FIO08-C:** Take care to ensure the correct field width and precision are specified in format strings  
- ✅ Use correct format specifiers: `%d` for int, `%ld` for long, etc.
- ✅ Specify width/precision when needed: `%10s`, `%.2f`

**FIO09-C:** Be careful with format strings that result in a number of arguments in excess of an implementation limit  
- ✅ Very large format strings may exceed limits
- ✅ Keep format strings reasonable in size

**FIO10-C:** Take care to ensure the correct format is specified in format strings  
- ✅ Match format specifier to argument type
- ✅ `printf("%d", (unsigned)val)` if val is unsigned

**FIO11-C:** Take care to prevent a data representation error in code generated from format strings  
- ✅ Validate input before formatting
- ✅ Prevent buffer overflows in formatted output

**FIO12-C:** Take care regarding portable file names  
- ✅ Use portable characters in filenames
- ✅ Avoid special characters that may not be portable

**FIO13-C:** Never push back anything other than one read character  
- ✅ `ungetc()` only pushes back one character
- ✅ Do not call multiple times without reading

**FIO14-C:** Understand the difference between text mode and binary mode  
- ✅ Text mode: newline translation may occur
- ✅ Binary mode: no translation
- ✅ Use appropriate mode for file type

**FIO15-C:** Ensure that file operations are performed in a secure manner  
- ✅ Use secure file operations
- ✅ Limit permissions appropriately

**FIO16-C:** Provide a mechanism to revoke access to files, even after they have been deleted  
- ✅ Overwrite file contents before deletion
- ✅ Use secure deletion functions for sensitive files

**FIO17-C:** Do not rely on an ending newline to process file content that is read with fgets()  
- ✅ fgets() may not include newline if buffer is too small
- ✅ Check for newline to detect buffer overflow

**FIO18-C:** On Windows, use the Windows API to operate on files  
- ✅ Use Windows-specific API for maximum security
- ✅ Standard C functions may not support all Windows features

**FIO19-C:** Take care when passing a FILE object to multiple functions whose return values are inconsistent  
- ✅ Be aware functions may clear error/EOF flags
- ✅ Check flags after each operation

**FIO20-C:** Ensure that a file is properly closed and that all resources are released when the file is no longer needed  
- ✅ Always call `fclose()` after opening
- ✅ Use cleanup handlers to ensure close on exit

**FIO21-C:** Do not create a temporary file that the process could overwrite  
- ✅ Use secure temporary file creation
- ✅ Modern: `mkstemp()` on Unix, `GetTempFileName()` on Windows

**Review Focus:** Format string safety, I/O error handling, return value checking, file permissions.

---

#### 1.10 Environment (ENV)

**ENV00-C:** Do not trust the argv and envp arrays  
- ✅ Validate all command-line arguments
- ✅ Validate all environment variables before use

**ENV01-C:** Do not trust the size of the results of certain library functions  
- ✅ Functions like `getcwd()` may fail if buffer too small
- ✅ Check return values

**ENV02-C:** Do not trust user-supplied format strings  
- ✅ Never use user input as format string
- ✅ Use fixed format string with user input as argument

**ENV03-C:** Sanitize the environment when invoking external processes  
- ✅ Clear or restrict `PATH` and library paths when spawning processes
- ✅ Use absolute paths for external binaries

**ENV04-C:** Do not call system()  
- ✅ `system()` is inherently unsafe
- ✅ Use `fork()/exec()` or `CreateProcess()` with explicit arguments

**ENV05-C:** Do not invoke an external process with unsanitized user data  
- ✅ Validate and escape all arguments to external processes
- ✅ Use argument arrays, not shell commands

**Review Focus:** Environment validation, argument sanitization, avoiding system().

---

#### 1.11 Concurrency (CON)

**CON00-C:** Do not use bit-fields as iterative objects in functions used to dynamically control group size  
- ✅ Bit-field access is not thread-safe
- ✅ Use regular variables for concurrent access

**CON01-C:** Do not create data races by using thread-unsafe functions  
- ✅ Know which functions are thread-safe
- ✅ Use thread-safe alternatives

**CON02-C:** Do not use blocking synchronization primitives  
- ✅ Avoid deadlocks with careful lock ordering
- ✅ Use timeouts on blocking operations

**CON03-C:** Do not assume the order of evaluation with respect to volatiles  
- ✅ `volatile` doesn't provide synchronization
- ✅ Use proper synchronization primitives

**CON04-C:** Use atomic operations instead of locks or mutexes to protect shared access to primitive integer and floating-point types  
- ✅ Atomic operations more efficient for simple values
- ✅ Use `_Atomic` or platform atomics

**CON05-C:** Use volatile for accessing values that may be concurrently modified by unknown code  
- ✅ Mark concurrent data as `volatile`
- ✅ But also use proper synchronization

**CON06-C:** Use getenv() only in single-threaded contexts  
- ✅ `getenv()` is not thread-safe
- ✅ Avoid in multithreaded code

**CON07-C:** Ensure that library code is thread-safe  
- ✅ Embedded systems often use libraries - ensure thread-safety
- ✅ Or document single-threaded assumption

**CON08-C:** Do not assume that a group of calls to independently atomic functions is atomic  
- ✅ Atomic function calls may be interrupted
- ✅ Use locks for atomic operation groups

**CON09-C:** Be careful when passing a pointer to a structure that contains atomics or volatile members  
- ✅ Passing pointer may lose volatile/atomic semantics
- ✅ Document carefully

**Review Focus:** Thread safety (if multithreaded), atomic operations, volatile usage.

---

#### 1.12 Other Important CERT C Rules

**MSC00-C:** Ensure that code is deterministic and does not depend on random behavior  
- ✅ Avoid non-deterministic operations
- ✅ Test with various initial conditions

**MSC01-C:** Use strtok_r() instead of strtok()  
- ✅ `strtok()` is not thread-safe (maintains state)
- ✅ Use `strtok_r()` for reentrant safe version

**MSC02-C:** Avoid errors of omission  
- ✅ Complete error handling
- ✅ Test error paths

**MSC03-C:** Avoid errors of addition  
- ✅ Do not add unnecessary code
- ✅ Keep code simple and focused

**MSC04-C:** Use comments consistently and wisely  
- ✅ Comment non-obvious logic
- ✅ Comments should explain "why", not "what"

**MSC05-C:** Do not assume that every Unicode code point fits in a wchar_t  
- ✅ `wchar_t` may be 16-bit or 32-bit
- ✅ Unicode needs up to 32 bits

**MSC06-C:** Beware of compiler optimizations  
- ✅ Understand what optimizations your compiler does
- ✅ Use `volatile` for values that must not be optimized

**Review Focus:** Determinism, thread-safe functions, code clarity, understanding optimizations.

---

### 2. Embedded Systems Best Practices

#### 2.1 Memory Efficiency

- ✅ Minimize static memory footprint
- ✅ Document memory requirements in comments
- ✅ Use bit fields only when space is critical and portability is acceptable
- ✅ Avoid large automatic variables on the stack
- ✅ Reuse buffers where safe to do so

#### 2.2 Real-Time Constraints

- ✅ Ensure functions have bounded execution time
- ✅ Avoid unbounded loops
- ✅ Document timing constraints
- ✅ Minimize time in critical sections
- ❌ Do not use malloc/free in interrupt handlers

#### 2.3 Robustness

- ✅ Validate all state transitions
- ✅ Implement watchdog-friendly code
- ✅ Provide recovery mechanisms for error states
- ✅ Use defensive programming techniques
- ✅ Add assertions for invariants (debug builds)

#### 2.4 Code Quality

- ✅ Functions should be small and focused (< 100 lines ideally)
- ✅ Cyclomatic complexity should be low (< 10)
- ✅ Use meaningful variable and function names
- ✅ Add comments for non-obvious logic
- ✅ Maintain consistent code style

---

### 3. ISO-TP-C Specific Guidelines

#### 3.1 Protocol Compliance

- ✅ Verify all ISO-TP frame types are handled correctly
- ✅ Ensure timeout handling matches ISO 15765-2 requirements
- ✅ Validate state machine transitions
- ✅ Check multi-frame message assembly logic
- ✅ Ensure CAN ID matching is correct

#### 3.2 Configuration & Portability

- ✅ All configurable parameters should be in `isotp_config.h`
- ✅ User callbacks must be implemented correctly
- ✅ Test with multiple compiler configurations
- ✅ Ensure platform-agnostic code (no OS-specific dependencies)

#### 3.3 Error Handling

- ✅ All functions should return appropriate error codes
- ✅ Document error conditions in function comments
- ✅ Ensure graceful degradation on errors
- ✅ Avoid silent failures

---

## Code Review Checklist

Use this checklist when reviewing pull requests:

### Pre-Submission

- [ ] Code compiles without warnings on all supported platforms
- [ ] No unused variables or functions (`-Wall -Wextra` clean)
- [ ] All CERT C rules have been considered
- [ ] Function documentation includes pre/post conditions
- [ ] Memory safety has been verified
- [ ] Integer overflow/underflow has been checked

### Security & Safety

- [ ] All input is validated
- [ ] No buffer overflows possible
- [ ] No use-after-free vulnerabilities
- [ ] No memory leaks
- [ ] No integer overflows
- [ ] No uninitialized variable access

### Functionality

- [ ] Behavior matches specification
- [ ] Error cases are handled
- [ ] State machine transitions are correct
- [ ] Edge cases are considered
- [ ] Performance is acceptable

### Quality

- [ ] Code is readable and maintainable
- [ ] Variable names are clear
- [ ] Comments explain "why", not "what"
- [ ] Code style is consistent
- [ ] Complexity is reasonable

### Testing

- [ ] Unit tests are included for new code
- [ ] Tests cover normal and error cases
- [ ] Tests validate edge conditions
- [ ] All tests pass locally

---

## Static Analysis Tools

The following tools are **recommended** for pre-submission checking:

- **Clang Static Analyzer**: `scan-build make all`
- **cppcheck**: `cppcheck --enable=all Src/ Inc/`
- **MISRA Checker**: Use commercial or open-source MISRA-C:2012 checkers
- **Compiler Warnings**: `-Wall -Wextra -Wpedantic -Wconversion`

Example compile command with strict warnings:
```bash
gcc -std=c99 -Wall -Wextra -Wpedantic -Wconversion -Wsign-conversion \
    -Wformat=2 -Wstrict-prototypes -Wwrite-strings \
    -c Src/isotp.c -I Inc/
```

---

## Common Issues & Solutions

### Issue: Integer Overflow
```c
// ❌ Problem
uint32_t total = a + b;

// ✅ Solution
if (a > UINT32_MAX - b) {
    return error_overflow();
}
uint32_t total = a + b;
```

### Issue: Buffer Overflow
```c
// ❌ Problem
memcpy(buffer, source, 4096);

// ✅ Solution
if (source_len > buffer_size) {
    return error_buffer_too_small();
}
memcpy(buffer, source, source_len);
```

### Issue: Uninitialized Variables
```c
// ❌ Problem
uint32_t count;
if (some_condition) {
    count = get_count();
}
use_count(count);  // count may be uninitialized

// ✅ Solution
uint32_t count = 0;  // Initialize at declaration
if (some_condition) {
    count = get_count();
}
use_count(count);
```

### Issue: Implicit Type Conversion
```c
// ❌ Problem
uint8_t value = large_int;

// ✅ Solution
if (large_int > UINT8_MAX) {
    return error_out_of_range();
}
uint8_t value = (uint8_t)large_int;
```

---

## References

- **CERT C Coding Standard**: https://wiki.sei.cmu.edu/confluence/display/c/
- **ISO/IEC 9899:2018 (C18 Standard)**
- **MISRA C:2012**: https://www.misra.org.uk/
- **ISO 15765-2 (ISO-TP Protocol)**
- **Embedded C Best Practices**

---

## Review Process

1. **Automated Checks**: Run static analysis tools before submission
2. **Manual Review**: Two maintainers must approve changes
3. **Testing**: All tests must pass on CI/CD pipeline
4. **Documentation**: README and comments updated if needed
5. **Final Verification**: Code merged only when all conditions met

---

**Document Version:** 1.0  
**Last Updated:** February 2026  
**Status:** Active  

For questions or clarifications, please open an issue or contact the maintainers.
